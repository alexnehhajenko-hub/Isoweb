<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Трассировка труб — линии + арматура + подписи</title>
<style>
  :root{--ui:#6c4dfc;--txt:#fff}
  html,body{height:100%;margin:0;background:#0f1116;color:#e9e9f0;font-family:system-ui,-apple-system,Inter,Roboto,Arial}
  .toolbar{position:fixed;left:12px;right:12px;top:10px;display:flex;gap:10px;justify-content:center;z-index:5;flex-wrap:wrap}
  .btn{background:#2b2f3a;color:var(--txt);border:0;border-radius:14px;padding:8px 14px;font-weight:600}
  .btn.active{background:var(--ui);box-shadow:0 6px 18px rgba(108,77,252,.25)}
  .wrap{position:fixed;inset:64px 10px 10px 10px;display:grid;place-items:center}
  .stage{width:95vw;height:calc(95vh - 64px);border:1px solid rgba(255,255,255,.15);border-radius:10px;position:relative;background:#0f1116;overflow:hidden;touch-action:none}
  canvas{position:absolute;inset:0;width:100%;height:100%}
  .toast{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.6);color:#cfe9cd;padding:8px 12px;border-radius:10px;font-size:14px}
  dialog{border:0;border-radius:14px;background:#1b1e27;color:#fff;width:min(92vw,460px)}
  .dlg-head{padding:14px 16px;font-weight:700}
  .dlg-body{padding:0 16px 16px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:10px 0}
  .row-col{display:flex;flex-direction:column;gap:10px;margin:10px 0}
  .grid-btns{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .chip{background:#2b2f3a;color:#fff;border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:10px;text-align:center}
  .chip.active{background:var(--ui)}
  .dlg-actions{display:flex;gap:10px;justify-content:flex-end;padding:12px 16px 16px}
  input[type="range"]{width:180px}
  input[type="text"]{flex:1;min-width:140px;border-radius:12px;border:1px solid rgba(255,255,255,.15);background:#11141b;color:#fff;padding:8px 10px}
  label.switch{display:flex;align-items:center;gap:12px}

  /* мини-панель правки/штампа/подписи */
  .editbar{
    position:fixed; left:50%; top:56px; transform:translateX(-50%);
    display:none; gap:8px; z-index:6;
    background:#1b1e27; padding:6px; border-radius:12px; border:1px solid rgba(255,255,255,.15);
  }
  .editbar .mini{padding:8px 10px; border-radius:10px; background:#2b2f3a; color:#fff; border:0; font-weight:700}
  .editbar .mini:active{transform:translateY(1px)}

  .toolbar, .btn, .zbtn { touch-action: manipulation; }
  *{ -webkit-tap-highlight-color:transparent; }
</style>
</head>
<body>
  <div class="toolbar">
    <button id="lineBtn" class="btn">Линия</button>
    <button id="panBtn"  class="btn active">Перемещение</button>
    <button id="undoBtn" class="btn">Стереть</button>
    <button id="centerBtn" class="btn">Центр</button>
    <button id="zoomOutBtn" class="btn">–</button>
    <button id="zoomInBtn"  class="btn">+</button>
    <button id="saveBtn"   class="btn">Сохранить</button>
    <button id="settingsBtn" class="btn">Настройки</button>
  </div>

  <!-- мини-панель: правка концов + масштаб выбранного штампа/подписи -->
  <div id="editBar" class="editbar">
    <button id="alignH" class="mini">H</button>
    <button id="alignV" class="mini">V</button>
    <button id="stampMinus" class="mini">A−</button>
    <button id="stampPlus"  class="mini">A+</button>
    <button id="labelMinus" class="mini">T−</button>
    <button id="labelPlus"  class="mini">T+</button>
    <button id="editDone" class="mini">Готово</button>
  </div>

  <div class="wrap">
    <div id="stage" class="stage"><canvas id="cv"></canvas></div>
  </div>

  <div id="toast" class="toast">Режим: перемещение</div>

  <dialog id="dlg">
    <div class="dlg-head">Параметры</div>
    <div class="dlg-body">
      <div class="row"><label>Ø (мм)</label><input id="diam" type="range" min="10" max="300" step="2" value="60"><span id="diamV">60</span></div>
      <div class="row"><label>Сетка</label><input id="grid" type="range" min="24" max="80" step="1" value="40"><span id="gridV">40</span></div>
      <div class="row"><label class="switch"><input id="magnet" type="checkbox" checked> Магнит (привязка к концам)</label></div>
      <div class="row"><label>Масштаб фото</label><input id="bgScale" type="range" min="10" max="200" step="5" value="100"><span id="bgScaleV">100%</span></div>
      <div class="row"><label>Размер арматуры</label><input id="stampScale" type="range" min="50" max="200" step="5" value="100"><span id="stampScaleV">100%</span></div>

      <div class="row-col">
        <div style="font-weight:700;margin-bottom:4px">Арматура (штамп)</div>
        <div class="grid-btns">
          <button class="chip" data-comp="BALL">Шаровой кран</button>
          <button class="chip" data-comp="CHECK">Обратный клапан</button>
          <button class="chip" data-comp="PUMP">Насос</button>
          <button class="chip" data-comp="VALVE">Вентиль</button>
        </div>/* кнопки/панели не должны зумиться от double-tap */
.toolbar, .toolbar .btn, .editbar, .editbar .mini, dialog, dialog .btn {
  touch-action: manipulation;
}

/* убираем синий/серый подсвет при тапе в iOS */
* { -webkit-tap-highlight-color: transparent; }

/* лайфхак против авто-зума текста в iOS при <16px */
html { -webkit-text-size-adjust: 100%; }
        <small style="opacity:.8">Выбери элемент, закрой окно и тапни по трубе. После установки режим «штамп» выключится. Штамп можно перетаскивать вдоль трубы и менять размер (A−/A+ или пинч).</small>
      </div>

      <div class="row-col" style="margin-top:8px">
        <div style="font-weight:700;margin-bottom:4px">Подпись</div>
        <div class="row" style="gap:10px">
          <input id="labelText" type="text" placeholder="Например: Ø32 ПП-R"/>
          <button id="labelPlaceBtn" class="btn">Поставить подпись</button>
        </div>
        <div class="row"><label>Размер подписей</label><input id="labelScale" type="range" min="60" max="200" step="5" value="100"><span id="labelScaleV">100%</span></div>
        <small style="opacity:.8">После нажатия «Поставить подпись» тапни по трубе — подпись прилипнет и повернётся по её направлению. Подпись можно двигать вдоль трубы, масштабировать T−/T+ или пинчем.</small>
      </div>
    </div>
    <div class="dlg-actions"><button id="dlgClose" class="btn">Закрыть</button></div>
  </dialog>

<script>
(()=>{
/* ===== DOM ===== */
const stage = document.getElementById('stage');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const toast = document.getElementById('toast');

const lineBtn = document.getElementById('lineBtn');
const panBtn  = document.getElementById('panBtn');
const undoBtn = document.getElementById('undoBtn');
const centerBtn = document.getElementById('centerBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const zoomInBtn  = document.getElementById('zoomInBtn');
const saveBtn = document.getElementById('saveBtn');
const settingsBtn = document.getElementById('settingsBtn');

const dlg = document.getElementById('dlg');
const diam = document.getElementById('diam'); const diamV = document.getElementById('diamV');
const grid = document.getElementById('grid'); const gridV = document.getElementById('gridV');
const magnet = document.getElementById('magnet');
const bgScale = document.getElementById('bgScale'); const bgScaleV = document.getElementById('bgScaleV');
const stampScale = document.getElementById('stampScale'); const stampScaleV = document.getElementById('stampScaleV');
const labelScale = document.getElementById('labelScale'); const labelScaleV = document.getElementById('labelScaleV');
const bg = document.getElementById('bg'); const dlgClose = document.getElementById('dlgClose');

const editBar = document.getElementById('editBar');
const alignH = document.getElementById('alignH');
const alignV = document.getElementById('alignV');
const stampMinus = document.getElementById('stampMinus');
const stampPlus  = document.getElementById('stampPlus');
const labelMinus = document.getElementById('labelMinus');
const labelPlus  = document.getElementById('labelPlus');
const editDone = document.getElementById('editDone');

const compButtons = [...document.querySelectorAll('.chip[data-comp]')];

const labelText = document.getElementById('labelText');
const labelPlaceBtn = document.getElementById('labelPlaceBtn');

/* ===== Сцена ===== */
let scale = 1, minScale=0.05, maxScale=6;
let offX = 0, offY = 0;
let gridStep = 40;
let pipeD = 60;

const pipes = [];           // сегменты труб
const stamps = [];          // [{type,x,y,s,ang}]
const labels = [];          // [{text,x,y,s,ang,dx,dy}] dx/dy — сдвиг от трубы (чтобы не перекрывалась)
let mode = 'pan';           // 'pan'|'pickA'|'pickB'|'edit'|'stamp'|'label'
let tempA = null;
let hoverW = null;
let snapTarget = null;

let editing = null;         // редактирование конца трубы
let longPressTimer = null;
let movedForLong = false;

let stampType = null;
let movingStampIndex = -1;
let selectedStampIndex = -1;

let movingLabelIndex = -1;
let selectedLabelIndex = -1;

let dpr = window.devicePixelRatio || 1;
let cssW=0, cssH=0;
let bgImg = null;
let bgScaleF = 1;
let stampScaleF = 1;
let labelScaleF = 1;

function fit(){
  const r = cv.getBoundingClientRect();
  cssW = Math.max(1, Math.round(r.width));
  cssH = Math.max(1, Math.round(r.height));
  dpr = window.devicePixelRatio || 1;
  cv.width  = Math.round(cssW * dpr);
  cv.height = Math.round(cssH * dpr);
  redraw();
}
function center(){
  offX = 0; offY = 0; scale = 1;
  redraw();
  setToast(
    mode==='pan'   ? 'Режим: перемещение'
    : mode==='stamp'? 'Режим: штамп арматуры'
    : mode==='label'? 'Режим: подпись'
    : mode==='edit' ? 'Правка конца'
    : 'Режим: линия'
  );
}

function worldToScreen(wx, wy){ return {x:(wx - offX) * scale + cssW/2, y:(wy - offY) * scale + cssH/2}; }
function screenToWorld(sx, sy){ return {x:(sx - cssW/2)/scale + offX, y:(sy - cssH/2)/scale + offY}; }
function setToast(t){ toast.textContent = t; }
function showEditBar(show){ editBar.style.display = show ? 'flex' : 'none'; }

/* ===== SVG → Image для штампов ===== */
function svgToImg(svg){ const img=new Image(); img.decoding='async'; img.src='data:image/svg+xml;utf8,'+encodeURIComponent(svg); return img; }
const ICONS_SVG = {
  BALL:`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 140 100">
    <rect x="20" y="40" width="100" height="20" rx="6" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <circle cx="70" cy="50" r="12" fill="#fff" stroke="#000" stroke-width="3"/>
    <rect x="60" y="10" width="20" height="20" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <line x1="70" y1="10" x2="70" y2="0" stroke="#000" stroke-width="4"/>
  </svg>`,
  CHECK:`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 140 100">
    <circle cx="70" cy="50" r="30" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <defs><marker id="a" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
      <path d="M0,0 L0,8 L12,4 Z" fill="#fff"/></marker></defs>
    <line x1="40" y1="50" x2="98" y2="50" stroke="#fff" stroke-width="7" marker-end="url(#a)"/>
  </svg>`,
  PUMP:`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 180 140">
    <defs><radialGradient id="g1" cx="60%" cy="45%"><stop offset="0" stop-color="#7b66ff"/><stop offset="1" stop-color="#5c44e6"/></radialGradient></defs>
    <g stroke="#111" stroke-width="3" stroke-linejoin="round" stroke-linecap="round">
      <rect x="5"  y="58" width="26" height="24" rx="4" fill="#6c4dfc"/>
      <rect x="149" y="58" width="26" height="24" rx="4" fill="#6c4dfc"/>
      <circle cx="90" cy="70" r="40" fill="url(#g1)"/>
      <rect x="70" y="6" width="40" height="26" rx="5" fill="#6c4dfc"/>
      <g stroke="#222"><line x1="76" x2="104" y1="12" y2="12"/><line x1="76" x2="104" y1="18" y2="18"/><line x1="76" x2="104" y1="24" y2="24"/></g>
      <line x1="90" y1="32" x2="90" y2="6" />
      <!-- треугольник в середине -->
      <polygon points="90,52 105,88 75,88" fill="#ffffff" stroke="#111" stroke-width="2"/>
    </g>
  </svg>`,
  VALVE:`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 180">
    <rect x="40" y="40" width="40" height="100" rx="10" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <circle cx="60" cy="90" r="18" fill="#fff" stroke="#000" stroke-width="3"/>
    <circle cx="60" cy="90" r="8" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <rect x="50" y="5" width="20" height="30" rx="3" fill="#6c4dfc" stroke="#000" stroke-width="3"/>
    <line x1="60" y1="35" x2="60" y2="40" stroke="#000" stroke-width="4"/>
  </svg>`
};
const ICONS_IMG = {}; for(const k of Object.keys(ICONS_SVG)) ICONS_IMG[k]=svgToImg(ICONS_SVG[k]);

/* ===== Рендер ===== */
function redraw(){
  ctx.setTransform(scale*dpr, 0, 0, scale*dpr, (cssW/2 - offX*scale)*dpr, (cssH/2 - offY*scale)*dpr);
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cv.width,cv.height); ctx.restore();

  if(bgImg){
    const w = bgImg.naturalWidth*bgScaleF, h = bgImg.naturalHeight*bgScaleF;
    ctx.drawImage(bgImg, -w/2, -h/2, w, h);
  }
  drawGrid();
  for(const s of pipes) drawPipe(s);
  for(const st of stamps) drawStamp(st);
  for(const lb of labels) drawLabel(lb);

  if(mode==='pickB' && tempA){
    ctx.save();
    const r1 = 7/scale, r2 = 12/scale;
    ctx.fillStyle = '#00d8ff';
    ctx.beginPath(); ctx.arc(tempA.x,tempA.y,r1,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,216,255,.6)'; ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(tempA.x,tempA.y,r2,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  if(mode==='pickB' && tempA && hoverW){
    ctx.save();
    ctx.setLineDash([10, 10]);
    ctx.lineWidth = Math.max(2, pipeD/4);
    ctx.strokeStyle = '#7cf';
    ctx.beginPath(); ctx.moveTo(tempA.x,tempA.y); ctx.lineTo(hoverW.x,hoverW.y); ctx.stroke();
    ctx.setLineDash([]); ctx.restore();
  }
  if(snapTarget){
    const r = 10/scale;
    ctx.save(); ctx.strokeStyle = '#ffd166'; ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(snapTarget.x, snapTarget.y, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
  }
  if(mode==='edit' && editing){
    const seg = pipes[editing.i];
    const p = editing.end==='a' ? seg.a : seg.b;
    const r = 12/scale;
    ctx.save(); ctx.strokeStyle = '#ffe08a'; ctx.lineWidth = 3/scale;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
  }
}
function drawGrid(){
  const step = gridStep, extent = 3000;
  ctx.save(); ctx.lineWidth = 1/scale;
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.beginPath();
  for(let x=-extent;x<=extent;x+=step){ ctx.moveTo(x,-extent); ctx.lineTo(x,extent); }
  for(let y=-extent;y<=extent;y+=step){ ctx.moveTo(-extent,y); ctx.lineTo(extent,y); }
  ctx.stroke();
  ctx.strokeStyle='rgba(255,120,120,.35)'; ctx.beginPath(); ctx.moveTo(-extent,0); ctx.lineTo(extent,0); ctx.stroke();
  ctx.strokeStyle='rgba(120,170,255,.35)'; ctx.beginPath(); ctx.moveTo(0,-extent); ctx.lineTo(0,extent); ctx.stroke();
  ctx.restore();
}
function drawPipe(s){
  const w = Math.max(2, s.d/4);
  ctx.save();
  ctx.lineWidth = w;
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#4da1ff';
  ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
  const r = (w/2);
  ctx.fillStyle='#4da1ff';
  for(const p of [s.a,s.b]){ ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); }
  ctx.restore();
}
function drawStamp(st){
  const img = ICONS_IMG[st.type]; if(!img || !img.complete) return;
  const baseH = Math.max(60, 4*pipeD);
  const typeMul = (st.type==='VALVE') ? 1.25 : 1.0;
  const targetH = baseH * typeMul * stampScaleF;
  const k = targetH / img.naturalHeight * (st.s||1);
  const w = img.naturalWidth * k, h = img.naturalHeight * k;
  ctx.save(); ctx.translate(st.x, st.y); if(st.ang) ctx.rotate(st.ang);
  ctx.drawImage(img, -w/2, -h/2, w, h); ctx.restore();
}
function drawLabel(lb){
  const s = (lb.s||1) * labelScaleF;
  const fontPx = 16 * s;
  const pad = 6 * s, r = 8 * s;
  ctx.save();
  ctx.translate(lb.x + (lb.dx||0), lb.y + (lb.dy||0));
  if(lb.ang) ctx.rotate(lb.ang);
  ctx.font = `600 ${fontPx}px system-ui,-apple-system,Inter,Roboto`;
  const metrics = ctx.measureText(lb.text);
  const w = metrics.width + pad*2, h = fontPx + pad*2;
  // плашка
  ctx.fillStyle = 'rgba(0,0,0,.62)';
  roundRectPath(-w/2, -h/2, w, h, r);
  ctx.fill();
  // текст
  ctx.fillStyle = '#ffffff';
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'center';
  ctx.fillText(lb.text, 0, 0);
  ctx.restore();
}
function roundRectPath(x,y,w,h,r){
  const rr=Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

/* ===== Геометрия / поиск ===== */
function applySnap(w){
  snapTarget = null;
  if(!magnet.checked) return w;
  const thr = 18/scale;
  let best=null, bestDist=Infinity;
  for(const seg of pipes){
    for(const p of [seg.a, seg.b]){
      const d = Math.hypot(w.x-p.x, w.y-p.y);
      if(d < bestDist && d <= thr){ best = p; bestDist = d; }
    }
  }
  if(best){ snapTarget = best; return {x:best.x, y:best.y}; }
  return w;
}
function nearestOnPipe(w){
  let bestP=null, bestAng=0, bestD=Infinity;
  for(const s of pipes){
    const ax=s.a.x, ay=s.a.y, bx=s.b.x, by=s.b.y;
    const ABx=bx-ax, ABy=by-ay, APx=w.x-ax, APy=w.y-ay;
    const ab2=ABx*ABx+ABy*ABy || 1e-6;
    let t=(APx*ABx+APy*ABy)/ab2; t=Math.max(0,Math.min(1,t));
    const px=ax+t*ABx, py=ay+t*ABy;
    const d=Math.hypot(w.x-px,w.y-py);
    if(d<bestD){ bestD=d; bestP={x:px,y:py}; bestAng=Math.atan2(by-ay,bx-ax); }
  }
  const allowDist = 24/scale;
  return (bestP && bestD<=allowDist) ? {ok:true, x:bestP.x, y:bestP.y, ang:bestAng} : {ok:false};
}
function hitStamp(w){
  const thr = 26/scale;
  for(let i=stamps.length-1;i>=0;i--){
    const st = stamps[i];
    const d = Math.hypot(w.x - st.x, w.y - st.y);
    if(d <= thr) return i;
  }
  return -1;
}
function hitLabel(w){
  // грубая проверка кругом
  const thr = 28/scale;
  for(let i=labels.length-1;i>=0;i--){
    const lb = labels[i];
    const d = Math.hypot(w.x - (lb.x+(lb.dx||0)), w.y - (lb.y+(lb.dy||0)));
    if(d <= thr) return i;
  }
  return -1;
}

/* ===== Режимы / кнопки ===== */
function setMode(newMode){
  mode = newMode;
  lineBtn.classList.toggle('active', mode==='pickA' || mode==='pickB');
  panBtn.classList.toggle('active',  mode==='pan');
  // мини-панель показываем, если правка концов/выбран штамп/выбрана подпись
  showEditBar(mode==='edit' || selectedStampIndex!==-1 || selectedLabelIndex!==-1);
  setToast(
    mode==='pan'   ? 'Режим: перемещение'
    : mode==='edit'? 'Правка конца (двигай пальцем, либо H/V)'
    : mode==='stamp'? 'Режим: штамп арматуры'
    : mode==='label'? 'Режим: подпись'
    : mode==='pickA'? 'Линия: поставь точку 1'
    : 'Линия: поставь точку 2'
  );
}
lineBtn.onclick = ()=>{ tempA=null; hoverW=null; cancelEdit(); stampType=null; selectedStampIndex=-1; selectedLabelIndex=-1; setMode('pickA'); };
panBtn.onclick  = ()=>{ tempA=null; hoverW=null; cancelEdit(); stampType=null; selectedStampIndex=-1; selectedLabelIndex=-1; setMode('pan'); };

undoBtn.onclick = ()=>{
  if(selectedLabelIndex!==-1){ labels.splice(selectedLabelIndex,1); selectedLabelIndex=-1; }
  else if(selectedStampIndex!==-1){ stamps.splice(selectedStampIndex,1); selectedStampIndex=-1; }
  else if(stamps.length) stamps.pop();
  else if(labels.length) labels.pop();
  else if(pipes.length) pipes.pop();
  redraw(); setToast('Стерто');
};
centerBtn.onclick = center;
saveBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=cv.toDataURL('image/png'); a.download='pipes.png'; a.click(); };
settingsBtn.onclick = ()=> dlg.showModal();
dlgClose.onclick = ()=> dlg.close();

diam.oninput = ()=>{ pipeD=+diam.value; diamV.textContent=pipeD; redraw(); };
grid.oninput = ()=>{ gridStep=+grid.value; gridV.textContent=gridStep; redraw(); };
bg.onchange = e=>{ const f=e.target.files?.[0]; if(!f) return; const img=new Image(); img.onload=()=>{ bgImg=img; redraw(); }; img.src=URL.createObjectURL(f); };
bgScale.oninput = ()=>{ bgScaleF=bgScale.value/100; bgScaleV.textContent=bgScale.value+'%'; redraw(); };
stampScale.oninput = ()=>{ stampScaleF = stampScale.value/100; stampScaleV.textContent = stampScale.value+'%'; redraw(); };
labelScale.oninput = ()=>{ labelScaleF = labelScale.value/100; labelScaleV.textContent = labelScale.value+'%'; redraw(); };

compButtons.forEach(b=>{
  b.addEventListener('click', ()=>{
    compButtons.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    stampType = b.dataset.comp;
    setMode('stamp');
  });
});
labelPlaceBtn.onclick = ()=>{
  if(!labelText.value.trim()){ setToast('Введи текст подписи'); return; }
  setMode('label'); dlg.close();
  setToast('Режим: подпись — тапни по трубе');
};

/* ===== Зажатие –/+ ===== */
let holdTimer=null, holdRAF=null;
function startHold(fn){ stopHold(); fn(); holdTimer=setTimeout(function loop(){ fn(); holdRAF=requestAnimationFrame(loop); }, 140); }
function stopHold(){ clearTimeout(holdTimer); cancelAnimationFrame(holdRAF); holdTimer=null; holdRAF=null; }
zoomOutBtn.addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomButton(-1));},{passive:false});
zoomOutBtn.addEventListener('mousedown',   ()=>startHold(()=>zoomButton(-1)));
zoomInBtn .addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomButton(+1));},{passive:false});
zoomInBtn .addEventListener('mousedown',   ()=>startHold(()=>zoomButton(+1)));
['mouseleave','mouseup','touchend','touchcancel'].forEach(ev=>{
  zoomOutBtn.addEventListener(ev, stopHold); zoomInBtn.addEventListener(ev, stopHold);
});
function zoomButton(dir){
  const rect=cv.getBoundingClientRect();
  const cx=rect.width/2, cy=rect.height/2;
  zoomAt(cx,cy, dir>0 ? 1.15 : 0.85);
  redraw();
}

/* ===== Жесты ===== */
let lastTouches=[];
let fingerPanning=false, prevFinger={x:0,y:0};
let lastPinchDist = 0;

stage.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===1){
    const t=ev.touches[0];
    const rect = cv.getBoundingClientRect();
    const sx = t.clientX - rect.left;
    const sy = t.clientY - rect.top;
    const w = screenToWorld(sx, sy);

    // long-press для концов трубы
    const hitEnd = hitEndpoint(w);
    movedForLong = false;
    clearTimeout(longPressTimer);
    if(hitEnd){
      longPressTimer = setTimeout(()=>{
        editing = hitEnd; deselectAll(); setMode('edit'); redraw();
      }, 600);
    }

    // выбор/перетаскивание штампа
    movingStampIndex = -1;
    movingLabelIndex = -1;

    const si = hitStamp(w);
    const li = hitLabel(w);

    if(mode==='pan' && (si!==-1 || li!==-1)){
      if(si!==-1){ selectedStampIndex = si; selectedLabelIndex=-1; showEditBar(true); movingStampIndex = si; }
      else       { selectedLabelIndex = li; selectedStampIndex=-1; showEditBar(true); movingLabelIndex = li; }
      redraw(); return;
    }

    if(mode==='pan'){
      fingerPanning=true; prevFinger={x:t.clientX,y:t.clientY};
    }else if(mode==='stamp'){
      placeStampAt(sx,sy);
    }else if(mode==='label'){
      placeLabelAt(sx,sy);
    }else if(mode==='pickA' || mode==='pickB'){
      onTap({clientX:t.clientX, clientY:t.clientY});
    }
  }else if(ev.touches.length===2){
    fingerPanning=false;
    clearTimeout(longPressTimer);
    movingStampIndex = -1; movingLabelIndex=-1;
    lastTouches = copyTouches(ev.touches);
    if(selectedStampIndex !== -1 || selectedLabelIndex !== -1){
      lastPinchDist = pinchDistance(ev.touches);
    }else{
      lastPinchDist = 0;
    }
  }
},{passive:false});

stage.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===1){
    const t=ev.touches[0];
    const rect=cv.getBoundingClientRect();
    const sx=t.clientX-rect.left, sy=t.clientY-rect.top;

    if(!movedForLong) movedForLong = true, clearTimeout(longPressTimer);

    if(movingStampIndex !== -1){
      const near = nearestOnPipe(screenToWorld(sx,sy));
      if(near.ok){
        const st = stamps[movingStampIndex];
        st.x = near.x; st.y = near.y; st.ang = near.ang;
        redraw();
      }
      return;
    }
    if(movingLabelIndex !== -1){
      const near = nearestOnPipe(screenToWorld(sx,sy));
      if(near.ok){
        const lb = labels[movingLabelIndex];
        lb.x = near.x; lb.y = near.y; lb.ang = near.ang;
        redraw();
      }
      return;
    }

    if(mode==='edit' && editing){
      const w = applySnap(screenToWorld(sx,sy));
      const seg = pipes[editing.i];
      if(editing.end==='a'){ seg.a.x=w.x; seg.a.y=w.y; } else { seg.b.x=w.x; seg.b.y=w.y; }
      redraw();
    }else if(mode==='pan' && fingerPanning){
      const dx=t.clientX-prevFinger.x, dy=t.clientY-prevFinger.y;
      offX -= dx/scale; offY -= dy/scale;
      prevFinger={x:t.clientX,y:t.clientY};
      redraw();
    }else if(mode==='pickB' && tempA){
      updateHoverFromPointer({clientX:t.clientX, clientY:t.clientY});
    }
  }else if(ev.touches.length===2){
    if((selectedStampIndex !== -1 || selectedLabelIndex !== -1) && lastPinchDist>0){
      const dist = pinchDistance(ev.touches);
      const ratio = dist / lastPinchDist;
      lastPinchDist = dist;
      if(selectedStampIndex !== -1){
        const st = stamps[selectedStampIndex];
        st.s = clamp((st.s||1) * Math.pow(ratio, 0.9), 0.5, 2.0);
      }else if(selectedLabelIndex !== -1){
        const lb = labels[selectedLabelIndex];
        lb.s = clamp((lb.s||1) * Math.pow(ratio, 0.9), 0.6, 2.0);
      }
      redraw();
    }else{
      pinchPan(ev.touches);
    }
  }
},{passive:false});

stage.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  clearTimeout(longPressTimer);
  if(ev.touches.length===0) { fingerPanning=false; movingStampIndex=-1; movingLabelIndex=-1; lastPinchDist=0; }
  if(ev.touches.length<2) lastTouches=[];
},{passive:false});

/* ===== Мышь ===== */
let dragging=false, prev={x:0,y:0};
stage.addEventListener('mousedown', e=>{
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
  const w = screenToWorld(sx, sy);

  if(mode==='stamp'){ placeStampAt(sx,sy); return; }
  if(mode==='label'){ placeLabelAt(sx,sy); return; }

  movingStampIndex=-1; movingLabelIndex=-1;

  const si = hitStamp(w);
  const li = hitLabel(w);
  if(mode==='pan' && (si!==-1 || li!==-1)){
    if(si!==-1){ selectedStampIndex=si; selectedLabelIndex=-1; showEditBar(true); movingStampIndex=si; }
    else       { selectedLabelIndex=li; selectedStampIndex=-1; showEditBar(true); movingLabelIndex=li; }
    return;
  }

  const hit = hitEndpoint(w);
  if(hit){ editing = hit; deselectAll(); setMode('edit'); redraw(); return; }
  if(mode!=='pan'){ onTap(e); return; }
  dragging=true; prev={x:e.clientX,y:e.clientY};
});
stage.addEventListener('mousemove', e=>{
  if(movingStampIndex !== -1){
    const rect=cv.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    const near = nearestOnPipe(screenToWorld(sx,sy));
    if(near.ok){
      const st = stamps[movingStampIndex];
      st.x = near.x; st.y = near.y; st.ang = near.ang;
      redraw();
    }
    return;
  }
  if(movingLabelIndex !== -1){
    const rect=cv.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    const near = nearestOnPipe(screenToWorld(sx,sy));
    if(near.ok){
      const lb = labels[movingLabelIndex];
      lb.x = near.x; lb.y = near.y; lb.ang = near.ang;
      redraw();
    }
    return;
  }

  if(mode==='edit' && editing){
    const rect=cv.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    const w=applySnap(screenToWorld(sx,sy));
    const seg=pipes[editing.i];
    if(editing.end==='a'){ seg.a.x=w.x; seg.a.y=w.y; } else { seg.b.x=w.x; seg.b.y=w.y; }
    redraw();
    return;
  }
  if(mode==='pickB' && tempA){ updateHoverFromPointer(e); return; }
  if(!dragging) return;
  const dx=e.clientX-prev.x, dy=e.clientY-prev.y;
  offX -= dx/scale; offY -= dy/scale;
  prev={x:e.clientX,y:e.clientY}; redraw();
});
stage.addEventListener('mouseup', ()=>{ dragging=false; movingStampIndex=-1; movingLabelIndex=-1; });
stage.addEventListener('mouseleave', ()=>{ dragging=false; movingStampIndex=-1; movingLabelIndex=-1; });

/* ===== Колесо — зум сцены ===== */
stage.addEventListener('wheel', e=>{
  const rect=cv.getBoundingClientRect();
  const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  zoomAt(cx, cy, e.deltaY>0? 0.85:1.15);
  e.preventDefault();
},{passive:false});

/* ===== Управление размером: A−/A+ и T−/T+ ===== */
function adjustSelectedStamp(f){
  if(selectedStampIndex === -1) return;
  const st = stamps[selectedStampIndex];
  st.s = clamp((st.s||1) * f, 0.5, 2.0);
  redraw();
}
function adjustSelectedLabel(f){
  if(selectedLabelIndex === -1) return;
  const lb = labels[selectedLabelIndex];
  lb.s = clamp((lb.s||1) * f, 0.6, 2.0);
  redraw();
}
stampMinus.onclick = ()=>adjustSelectedStamp(0.9);
stampPlus.onclick  = ()=>adjustSelectedStamp(1.1);
labelMinus.onclick = ()=>adjustSelectedLabel(0.9);
labelPlus.onclick  = ()=>adjustSelectedLabel(1.1);

/* ===== Постановка штампа/подписи ===== */
function placeStampAt(sx,sy){
  if(!stampType) return;
  const near = nearestOnPipe(screenToWorld(sx,sy));
  if(!near.ok){ setToast('Поставьте по трубе'); return; }
  stamps.push({type:stampType, x:near.x, y:near.y, s:1, ang:near.ang});
  selectedStampIndex = stamps.length-1; selectedLabelIndex=-1;
  stampType = null; compButtons.forEach(x=>x.classList.remove('active'));
  setMode('pan'); redraw();
}
function placeLabelAt(sx,sy){
  const t = (labelText.value||'').trim(); if(!t){ setToast('Введи текст подписи'); return; }
  const near = nearestOnPipe(screenToWorld(sx,sy));
  if(!near.ok){ setToast('Поставьте подпись по трубе'); return; }
  // небольшой вынос от оси трубы наверх
  const n = {x: -Math.sin(near.ang), y: Math.cos(near.ang)};
  const offset = 10; // в world (без деления на scale, тк мы в мировых)
  labels.push({text:t, x:near.x, y:near.y, s:1, ang:near.ang, dx:n.x*offset, dy:n.y*offset});
  selectedLabelIndex = labels.length-1; selectedStampIndex=-1;
  setMode('pan'); redraw();
}

/* ===== Линия (3 шага) ===== */
function onTap(e){
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const wpos = applySnap(screenToWorld(sx, sy));

  if(mode==='pickA'){
    tempA = wpos; hoverW=null; setMode('pickB'); redraw();
  }else if(mode==='pickB' && tempA){
    pipes.push({a:{...tempA}, b:wpos, d:pipeD});
    tempA=null; hoverW=null; snapTarget=null;
    setMode('pan');
    setToast('Линия готова. Чтобы нарисовать новую, нажми «Линия».');
    redraw();
  }
}
function hitEndpoint(w){
  const thr = 14/scale;
  for(let i=0;i<pipes.length;i++){
    const s=pipes[i];
    if(Math.hypot(w.x-s.a.x, w.y-s.a.y)<=thr) return {i, end:'a'};
    if(Math.hypot(w.x-s.b.x, w.y-s.b.y)<=thr) return {i, end:'b'};
  }
  return null;
}
function updateHoverFromPointer(pt){
  const rect=cv.getBoundingClientRect();
  const sx=pt.clientX-rect.left, sy=pt.clientY-rect.top;
  hoverW = applySnap(screenToWorld(sx,sy));
  redraw();
}

/* ===== Пинч-зуум сцены ===== */
function copyTouches(ts){ return [...ts].map(t=>({x:t.clientX,y:t.clientY})); }
function pinchDistance(ts){ const a=ts[0], b=ts[1]; return Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); }
function pinchPan(ts){
  const now = copyTouches(ts); if(now.length<2||lastTouches.length<2) return;
  const prevD = Math.hypot(lastTouches[0].x-lastTouches[1].x, lastTouches[0].y-lastTouches[1].y);
  const currD = Math.hypot(now[0].x-now[1].x, now[0].y-now[1].y);
  const rect = cv.getBoundingClientRect();
  const pcx=(lastTouches[0].x+lastTouches[1].x)/2 - rect.left;
  const pcy=(lastTouches[0].y+lastTouches[1].y)/2 - rect.top;
  const ncx=(now[0].x+now[1].x)/2 - rect.left;
  const ncy=(now[0].y+now[1].y)/2 - rect.top;

  zoomAt(ncx, ncy, Math.pow(currD/prevD, 1));
  offX -= (ncx-pcx)/scale;
  offY -= (ncy-pcy)/scale;

  lastTouches = now; redraw();
}
function zoomAt(sx,sy,zoom){
  const before = screenToWorld(sx,sy);
  scale = Math.min(maxScale, Math.max(minScale, scale*zoom));
  const after = screenToWorld(sx,sy);
  offX += before.x - after.x;
  offY += before.y - after.y;
  showEditBar(mode==='edit' || selectedStampIndex!==-1 || selectedLabelIndex!==-1);
}

/* ===== Вспомогательное ===== */
function deselectAll(){ selectedStampIndex=-1; selectedLabelIndex=-1; showEditBar(mode==='edit'); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

/* ===== Блокируем double-tap zoom на панели ===== */
const toolbar = document.querySelector('.toolbar');
let lastTouchEnd = 0;
toolbar.addEventListener('touchend', (e) => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });
toolbar.addEventListener('dblclick', (e) => e.preventDefault(), { passive:false });

/* ===== init ===== */
new ResizeObserver(()=>{ fit(); }).observe(stage);
fit();
center();
})();
</script>
</body>
</html>