<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî snap + long-press endpoint edit</title>
<style>
  :root{--violet:#6b1dff; --violet2:#7c5bff; --border:#e7e3f7}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{position:fixed;inset:0;display:block;width:100vw;height:100vh;background:#fff;touch-action:none;-webkit-user-select:none;user-select:none}

  .bar{position:fixed;left:8px;top:8px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .btn{height:44px;padding:0 14px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:linear-gradient(180deg,#8c8c8c,#6a6a6a)}

  .zoom{position:fixed;right:8px;top:8px;z-index:11;display:flex;gap:8px}
  .zbtn{height:44px;min-width:44px;border:0;border-radius:12px;background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.1);font-size:18px}

  .gear{position:fixed;right:8px;top:64px;z-index:12;height:44px;width:44px;border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.08);font-size:20px}
  .status{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.70);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;z-index:11;max-width:92vw}

  .panel-wrap{position:fixed;inset:0;z-index:20;display:none}
  .panel-wrap.open{display:block}
  .panel-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.18)}
  .panel{position:absolute;top:64px;right:8px;background:#fff;border:1px solid var(--border);
         border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:12px;width:min(92vw,380px);
         max-height:80vh;overflow:auto}
  .panel h4{margin:6px 0 8px;font-size:15px}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{min-width:140px;font-size:13px;color:#444}
  .close{position:sticky;top:0;margin:-6px -6px 6px auto;background:#fff;border:1px solid var(--border);width:32px;height:32px;border-radius:8px}
  input[type=range]{width:100%}
  .num{font-variant-numeric:tabular-nums;color:#111;font-weight:700}
  .radio-row{display:flex;gap:10px;flex-wrap:wrap}
  .radio{display:flex;align-items:center;gap:6px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;font-size:12px;color:#333}
  .radio input{accent-color:#6b1dff}
  .upl{position:relative;min-width:120px;display:inline-flex;justify-content:center}
  .upl input{position:absolute;inset:0;opacity:0}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine"  class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnUndo"  class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
  </div>

  <div class="zoom">
    <button id="btnMinus" class="zbtn" title="–£–º–µ–Ω—å—à–∏—Ç—å">‚àí</button>
    <button id="btnPlus"  class="zbtn" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
  </div>

  <button id="btnSettings" class="gear" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öô</button>

  <div id="panelWrap" class="panel-wrap" aria-hidden="true">
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <div id="panel" class="panel" role="dialog" aria-modal="true">
      <button id="btnClosePanel" class="close" title="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>

      <h4>–§–æ—Ç–æ (—Ñ–æ–Ω)</h4>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <label class="btn ghost upl">üì∑ –ö–∞–º–µ—Ä–∞
          <input id="fileCam" type="file" accept="image/*" capture="environment">
        </label>
        <label class="btn ghost upl">üìÇ –ì–∞–ª–µ—Ä–µ—è
          <input id="fileGal" type="file" accept="image/*">
        </label>
        <button id="btnClearBg" class="btn ghost" style="margin-left:auto">üßπ –£–¥–∞–ª–∏—Ç—å —Ñ–æ–Ω</button>
      </div>

      <h4>–ß–µ—Ä—Ç—ë–∂</h4>
      <div class="row">
        <label for="rangeLine">–¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏</label>
        <input id="rangeLine" type="range" min="2" max="56" step="1">
        <span id="lineVal" class="num">10</span>
      </div>

      <div class="row">
        <label for="rangeComp">–ê—Ä–º–∞—Ç—É—Ä–∞ √ó</label>
        <input id="rangeComp" type="range" min="0.5" max="3.0" step="0.01">
        <span id="compVal" class="num">1.15</span>
      </div>

      <div class="row" style="margin-top:8px">
        <label>–¢–∏–ø –∞—Ä–º–∞—Ç—É—Ä—ã</label>
        <div class="radio-row">
          <label class="radio"><input type="radio" name="comp" value="valve" checked> –ö—Ä–∞–Ω</label>
          <label class="radio"><input type="radio" name="comp" value="check"> –ö–ª–∞–ø–∞–Ω</label>
          <label class="radio"><input type="radio" name="comp" value="pump"> –ù–∞—Å–æ—Å</label>
        </div>
      </div>

      <div class="row" style="justify-content:flex-end;gap:8px">
        <button id="btnPlaceComp" class="btn">–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —Ç—Ä—É–±—É</button>
      </div>
    </div>
  </div>

  <div id="status" class="status">–°—Ç–∞—Ç—É—Å: –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>

<script>
(()=>{"use strict";

/* ===== –û—à–∏–±–∫–∏ —Å—Ä–∞–∑—É –Ω–∞ —ç–∫—Ä–∞–Ω–µ ===== */
window.onerror = function (msg, src, line, col) {
  alert("‚ùå –û—à–∏–±–∫–∞: " + msg + "\n" + (src||"") + "@" + line + ":" + col);
};

/* ===== –±–∞–∑–æ–≤—ã–µ ===== */
const DPR=Math.min(1.5,Math.max(1,window.devicePixelRatio||1));
const cv=document.getElementById('cv'), ctx=cv.getContext('2d',{alpha:false});
const statusEl=document.getElementById('status');

const view={tx:0,ty:0,scale:1};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const clampScale=s=>clamp(s,0.25,6);

function fit(){ cv.width=Math.round(innerWidth*DPR); cv.height=Math.round(innerHeight*DPR); if(bg && view.scale===1 && view.tx===0 && view.ty===0) fitToScreen(); need(); }
addEventListener('resize',fit,{passive:true});

/* ===== —Ñ–æ–Ω (—Ñ–æ—Ç–æ) ===== */
let bg=null,bw=0,bh=0;
function fitToScreen(){ if(!bg) return; const k=Math.min(cv.width/bw, cv.height/bh); view.scale=k; view.tx=(cv.width-bw*k)/2; view.ty=(cv.height-bh*k)/2; need(); }
function loadImageFile(f){
  if(!f) return;
  const img=new Image();
  img.onload=()=>{
    const maxSide=Math.max(img.naturalWidth,img.naturalHeight);
    let w=img.naturalWidth,h=img.naturalHeight;
    if(maxSide>2200){ const sc=2200/maxSide; w=Math.round(w*sc); h=Math.round(h*sc); }
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    c.getContext('2d',{alpha:false}).drawImage(img,0,0,w,h);
    bg=c; bw=w; bh=h; fitToScreen(); updateStatus('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ'); need();
  };
  img.src=URL.createObjectURL(f);
}
document.getElementById('fileCam').onchange=e=>loadImageFile(e.target.files?.[0]);
document.getElementById('fileGal').onchange=e=>loadImageFile(e.target.files?.[0]);
document.getElementById('btnClearBg').onclick=()=>{ bg=null; need(); updateStatus('–§–æ–Ω —É–¥–∞–ª—ë–Ω'); };

/* ===== –¥–∞–Ω–Ω—ã–µ —á–µ—Ä—Ç–µ–∂–∞ ===== */
const segs=[];              // {a:{x,y}, b:{x,y}}
const comps=[];             // {segIndex,t,type}
const stack=[];             // 'seg' | 'comp'
let tool='idle';            // 'idle' | 'awaitFirst' | 'awaitSecond' | 'placeComp' | 'editEnd'
let first=null, preview=null;
let currentComp='valve';    // valve | check | pump
const params={ linePx:10, lineColor:'#1f6bff', compScale:1.15 };
const SNAP_PX = 18 * DPR;   // –ø—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –∫ —Å—Ç—ã–∫–∞–º
const LONG_PRESS_MS = 700;  // –¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –¥–ª—è –ø—Ä–∞–≤–∫–∏ –∫–æ–Ω—Ü–∞

/* ===== —Å—Ç–∞—Ç—É—Å ===== */
function updateStatus(msg=''){
  const t = tool==='awaitFirst' ? '–ñ–¥—É 1-—é —Ç–æ—á–∫—É' :
            tool==='awaitSecond' ? '–ñ–¥—É 2-—é —Ç–æ—á–∫—É' :
            tool==='placeComp' ? '–ê—Ä–º–∞—Ç—É—Ä–∞' :
            tool==='editEnd' ? '–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞' : '–ì–æ—Ç–æ–≤';
  statusEl.textContent = `–°—Ç–∞—Ç—É—Å: ${msg} | ${t} | –õ–∏–Ω–∏—è ${params.linePx}px | –ê—Ä–º–∞—Ç—É—Ä–∞√ó${params.compScale.toFixed(2)}`;
}

/* ===== —É—Ç–∏–ª–∏—Ç—ã ===== */
function s2w(sx,sy){ return { x:(sx-view.tx)/view.scale, y:(sy-view.ty)/view.scale }; }
function w2s(x,y){ return { x:x*view.scale+view.tx, y:y*view.scale+view.ty }; }
function darker(hex,k=0.45){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return '#333';
  let [r,g,b]=[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)];
  r=Math.max(0,Math.floor(r*(1-k))); g=Math.max(0,Math.floor(g*(1-k))); b=Math.max(0,Math.floor(b*(1-k)));
  return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
}
function segGeom(seg){ const vx=seg.b.x-seg.a.x, vy=seg.b.y-seg.a.y; const L=Math.hypot(vx,vy)||1; return {vx,vy,L,nx:vx/L,ny:vy/L}; }
function compBasis(seg,t){ const g=segGeom(seg); return {x:seg.a.x+g.nx*g.L*t, y:seg.a.y+g.ny*g.L*t, ux:g.nx,uy:g.ny,nx:-g.ny,ny:g.nx}; }

/* ===== SNAP: —Å—Ç—ã–∫–∏ ===== */
function allVertices(){ const pts=[]; for(const s of segs){ pts.push({seg:s,ref:'a',p:s.a}); pts.push({seg:s,ref:'b',p:s.b}); } return pts; }
function findSnapVertexScreen(sx,sy){
  let best=null, bd=1e9;
  for(const {p} of allVertices()){
    const sp=w2s(p.x,p.y);
    const d=Math.hypot(sp.x-sx, sp.y-sy);
    if(d<bd){ bd=d; best=p; }
  }
  return (best && bd<=SNAP_PX) ? {pt:best, dist:bd} : null;
}

/* ===== –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ===== */
function drawSegments(){
  ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  const col=params.lineColor, sh=darker(col,0.45);
  for(const s of segs){
    ctx.strokeStyle=sh; ctx.globalAlpha=.75; ctx.lineWidth=(params.linePx+2)/view.scale;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    ctx.strokeStyle=col; ctx.globalAlpha=1; ctx.lineWidth=params.linePx/view.scale;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
  }
}

/* ‚Äî‚Äî‚Äî –ê—Ä–º–∞—Ç—É—Ä–∞ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ) ‚Äî‚Äî‚Äî */
function drawValve(seg,t){
  const b=compBasis(seg,t), base=params.linePx*params.compScale;
  const bodyLen=base*10.5, bodyR=base*2.6, coneL=base*3.2, pipeR=base*1.4;
  const ballR=base*2.0, neckH=base*2.6, neckR=base*0.9, handleL=base*6.5, handleW=base*0.9;

  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;
  const L={x:b.x-ux*bodyLen/2,y:b.y-uy*bodyLen/2};
  const R={x:b.x+ux*bodyLen/2,y:b.y+uy*bodyLen/2};
  const P1={x:L.x-ux*coneL,y:L.y-uy*coneL}, P2={x:R.x+ux*coneL,y:R.y+uy*coneL};

  ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.fillStyle='#6b1dff'; ctx.strokeStyle='#2b145f'; ctx.lineWidth=2/view.scale;

  ctx.beginPath();
  ctx.moveTo(L.x-nx*bodyR, L.y-ny*bodyR);
  ctx.lineTo(R.x-nx*bodyR, R.y-ny*bodyR);
  ctx.arc(R.x,R.y,bodyR, Math.atan2(-ny,-nx), Math.atan2(ny,-nx), false);
  ctx.lineTo(L.x+nx*bodyR, L.y+ny*bodyR);
  ctx.arc(L.x,L.y,bodyR, Math.atan2(ny,nx), Math.atan2(-ny,nx), false);
  ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(P1.x-nx*pipeR,P1.y-ny*pipeR);
  ctx.lineTo(L.x-nx*bodyR,L.y-ny*bodyR); ctx.lineTo(L.x+nx*bodyR,L.y+ny*bodyR);
  ctx.lineTo(P1.x+nx*pipeR,P1.y+ny*pipeR); ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(R.x-nx*bodyR,R.y-ny*bodyR);
  ctx.lineTo(P2.x-nx*pipeR,P2.y-ny*pipeR); ctx.lineTo(P2.x+nx*pipeR,P2.y+ny*pipeR);
  ctx.lineTo(R.x+nx*bodyR,R.y+ny*bodyR); ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.beginPath(); ctx.arc(b.x,b.y,ballR,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.strokeStyle='#1b1b1b'; ctx.stroke();
  const top={x:b.x+nx*bodyR,y:b.y+ny*bodyR};
  const neckTop={x:top.x+nx*neckH,y:top.y+ny*neckH};
  ctx.beginPath(); ctx.arc(b.x,b.y,neckR,0,Math.PI*2); ctx.strokeStyle='#1b1b1b'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(top.x,top.y); ctx.lineTo(neckTop.x,neckTop.y); ctx.stroke();

  const hw=handleW/2; ctx.fillStyle='#111';
  ctx.beginPath();
  ctx.moveTo(neckTop.x-nx*hw, neckTop.y-ny*hw);
  ctx.lineTo(neckTop.x+ux*handleL-nx*hw, neckTop.y+uy*handleL-ny*hw);
  ctx.lineTo(neckTop.x+ux*handleL+nx*hw, neckTop.y+uy*handleL+ny*hw);
  ctx.lineTo(neckTop.x+nx*hw, neckTop.y+ny*hw);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawCheck(seg,t){
  const b=compBasis(seg,t), base=params.linePx*params.compScale;
  const bodyLen=base*10.5, bodyR=base*2.6, coneL=base*3.2, pipeR=base*1.4;

  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;
  const L={x:b.x-ux*bodyLen/2,y:b.y-uy*bodyLen/2};
  const R={x:b.x+ux*bodyLen/2,y:b.y+uy*bodyLen/2};
  const P1={x:L.x-ux*coneL,y:L.y-uy*coneL}, P2={x:R.x+ux*coneL,y:R.y+uy*cone–õ};

  ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.fillStyle='#6b1dff'; ctx.strokeStyle='#2b145f'; ctx.lineWidth=2/view.scale;

  ctx.beginPath();
  ctx.moveTo(L.x-nx*bodyR, L.y-ny*bodyR);
  ctx.lineTo(R.x-nx*bodyR, R.y-ny*bodyR);
  ctx.arc(R.x,R.y,bodyR, Math.atan2(-ny,-nx), Math.atan2(ny,-nx), false);
  ctx.lineTo(L.x+nx*bodyR, L.y+ny*bodyR);
  ctx.arc(L.x,L.y,bodyR, Math.atan2(ny,nx), Math.atan2(-ny,nx), false);
  ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(P1.x-nx*pipeR,P1.y-ny*pipeR);
  ctx.lineTo(L.x-nx*bodyR,L.y-ny*bodyR); ctx.lineTo(L.x+nx*bodyR,L.y+ny*bodyR);
  ctx.lineTo(P1.x+nx*pipeR,P1.y+ny*pipeR); ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(R.x-nx*bodyR,R.y-ny*bodyR);
  ctx.lineTo(P2.x-nx*pipeR,P2.y-ny*pipeR); ctx.lineTo(P2.x+nx*pipeR,P2.y+ny*pipeR);
  ctx.lineTo(R.x+nx*bodyR,R.y+ny*bodyR); ctx.closePath(); ctx.fill(); ctx.stroke();

  const triBase=base*3.2, triRise=base*3.0;
  const A={x:b.x - nx*triBase/2, y:b.y - ny*triBase/2};
  const B={x:b.x + nx*triBase/2, y:b.y + ny*triBase/2};
  const T={x:b.x + ux*triRise,   y:b.y + uy*triRise};
  ctx.fillStyle='#ffffff'; ctx.strokeStyle='#1b1b1b'; ctx.lineWidth=1.6/view.scale;
  ctx.beginPath(); ctx.moveTo(T.x,T.y); ctx.lineTo(B.x,B.y); ctx.lineTo(A.x,A.y); ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.restore();
}

function drawPump(seg,t){
  const b=compBasis(seg,t), base=params.linePx*params.compScale;
  const volR=base*4.2, flLen=base*2.6, flHalf=base*1.6;
  const motorW=base*6.0, motorH=base*4.0;

  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;
  const Lc={x:b.x-ux*(volR+flLen*0.9), y:b.y-uy*(volR+flLen*0.9)};
  const Rc={x:b.x+ux*(volR+flLen*0.9), y:b.y+uy*(volR+flLen*0.9)};

  ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.fillStyle='#6b1dff'; ctx.strokeStyle='#2b145f'; ctx.lineWidth=2/view.scale;

  ctx.beginPath(); ctx.arc(b.x,b.y,volR,0,Math.PI*2); ctx.fill(); ctx.stroke();

  function flange(cx,cy){
    const ax=ux*(flLen/2), ay=uy*(flLen/2), px=nx*flHalf, py=ny*flHalf;
    ctx.beginPath();
    ctx.moveTo(cx-ax-px, cy-ay-py); ctx.lineTo(cx+ax-px, cy+ay-py);
    ctx.lineTo(cx+ax+px, cy+ay+py); ctx.lineTo(cx-ax+px, cy-ay+py);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
  flange(Lc.x,Lc.y); flange(Rc.x,Rc.y);

  const dotUp = nx*0 + ny*(-1);
  const sign = (dotUp >= 0) ? 1 : -1;
  const mOff = volR + motorW/2 + base*1.2;
  const mCx = b.x + nx * mOff * sign;
  const mCy = b.y + ny * mOff * sign;
  ctx.beginPath(); ctx.rect(mCx - motorW/2, mCy - motorH/2, motorW, motorH); ctx.fill(); ctx.stroke();

  ctx.restore();
}

/* ===== –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: —Å–æ—Å—Ç–æ—è–Ω–∏–µ ===== */
let snapPreview=null; // {x,y}
let edit=null;        // {segIndex, end:'a'|'b', start:{x,y}, axis:null|'x'|'y'}
let pressTimer=null;

/* ===== –æ–±—â–∏–π —Ä–µ–Ω–¥–µ—Ä ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);

  if(bg){ ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.drawImage(bg,0,0,bw,bh); }

  drawSegments();

  for(const c of comps){
    const seg=segs[c.segIndex]; if(!seg) continue;
    if(c.type==='valve') drawValve(seg,c.t);
    else if(c.type==='check') drawCheck(seg,c.t);
    else if(c.type==='pump') drawPump(seg,c.t);
  }

  // –ø—Ä–µ–≤—å—é –ª–∏–Ω–∏–∏
  if(tool==='awaitSecond' && first && preview){
    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.strokeStyle=params.lineColor; ctx.lineWidth=Math.max(3,params.linePx-2)/view.scale;
    ctx.beginPath(); ctx.moveTo(first.x,first.y); ctx.lineTo(preview.x,preview.y); ctx.stroke();
  }

  // –ø–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞
  if(first){
    const p=w2s(first.x,first.y);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
  }

  // –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è
  if(snapPreview){
    const sp=w2s(snapPreview.x, snapPreview.y);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 9, 0, Math.PI*2);
    ctx.lineWidth=2; ctx.strokeStyle='rgba(0,180,255,.9)'; ctx.stroke();
  }

  // –≥–∞–π–¥ –¥–ª—è –ø—Ä–∞–≤–∫–∏ –∫–æ–Ω—Ü–∞
  if(edit){
    const seg=segs[edit.segIndex], P=seg[edit.end];
    const sp=w2s(P.x,P.y);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='rgba(0,180,255,.9)'; ctx.beginPath(); ctx.arc(sp.x,sp.y,7,0,Math.PI*2); ctx.fill();
    if(edit.axis){
      ctx.setLineDash([8,6]); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,180,255,.8)';
      ctx.beginPath();
      if(edit.axis==='x'){ // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∞—è
        ctx.moveTo(0, sp.y); ctx.lineTo(cv.width, sp.y);
      }else{
        ctx.moveTo(sp.x, 0); ctx.lineTo(sp.x, cv.height);
      }
      ctx.stroke(); ctx.setLineDash([]);
    }
  }
}
let raf=0, dirty=false; function need(){ dirty=true; if(!raf){ raf=requestAnimationFrame(()=>{ raf=0; if(dirty){ dirty=false; draw(); } }); } }

/* ===== –≤—ã–±–æ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞ –¥–ª—è –∞—Ä–º–∞—Ç—É—Ä—ã ===== */
function w2sPoint(p){ return w2s(p.x,p.y); }
function findNearestSegment(sx,sy,maxDistPx=28){
  let best=-1,bd=1e9,bt=0;
  for(let i=0;i<segs.length;i++){
    const s=segs[i]; const A=w2sPoint(s.a), B=w2sPoint(s.b);
    const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy; if(!len2) continue;
    const t=Math.max(0,Math.min(1,((sx-A.x)*vx+(sy-A.y)*vy)/len2));
    const px=A.x+vx*t, py=A.y+vy*t, d=Math.hypot(px-sx,py-sy);
    if(d<bd){ bd=d; best=i; bt=t; }
  }
  return (best!==-1 && bd<=maxDistPx)?{segIndex:best,t:bt}:null;
}
function findNearestEndpoint(sx,sy){ // –ø–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–≥–æ –∫–æ–Ω—Ü–∞ —Å–µ–≥–º–µ–Ω—Ç–∞ (–≤ —ç–∫—Ä–∞–Ω–∞—Ö)
  let res=null, bd=1e9;
  segs.forEach((s,i)=>{
    const pts=[{end:'a',p:s.a},{end:'b',p:s.b}];
    for(const {end,p} of pts){
      const sp=w2s(p.x,p.y);
      const d=Math.hypot(sp.x-sx, sp.y-sy);
      if(d<bd){ bd=d; res={segIndex:i,end,p,dist:d}; }
    }
  });
  return (res && bd<=SNAP_PX) ? res : null;
}

/* ===== –≤–≤–æ–¥ ===== */
const pointers=new Map();
let panStart=null, panLast=null, isPanning=false;
const PAN_THRESH = 6*DPR;
let prevCenter=null, prevDist=null;

function canvasXY(e){ const r=cv.getBoundingClientRect(); return { sx:(e.clientX-r.left)*(cv.width/r.width), sy:(e.clientY-r.top)*(cv.height/r.height) }; }
function centroid(){ const a=[...pointers.values()]; if(!a.length) return null; let sx=0,sy=0; for(const p of a){ sx+=p.sx; sy+=p.sy; } return {sx:sx/a.length, sy:sy/a.length}; }

cv.addEventListener('pointerdown', e=>{
  e.preventDefault();
  const {sx,sy}=canvasXY(e); pointers.set(e.pointerId,{sx,sy});
  if(pointers.size===2){
    const [p0,p1]=[...pointers.values()];
    prevCenter=centroid(); prevDist=Math.hypot(p0.sx-p1.sx,p0.sy-p1.sy);
    return;
  }

  // –¥–æ–ª–≥–∏–π —Ç–∞–ø –Ω–∞ –∫–æ–Ω—Ü–µ –¥–ª—è –ø—Ä–∞–≤–∫–∏
  const nearEnd=findNearestEndpoint(sx,sy);
  if(nearEnd){
    clearTimeout(pressTimer);
    pressTimer=setTimeout(()=>{
      edit={segIndex:nearEnd.segIndex,end:nearEnd.end,start:{sx,sy},axis:null};
      tool='editEnd'; updateStatus('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–æ—Ç—è–Ω–∏ –ø–æ –æ—Å–∏'); need();
    }, LONG_PRESS_MS);
  }

  if(tool==='placeComp'){
    const near=findNearestSegment(sx,sy,28*DPR);
    if(near){ comps.push({segIndex:near.segIndex,t:near.t,type:currentComp}); stack.push('comp'); tool='idle'; updateStatus('–ê—Ä–º–∞—Ç—É—Ä–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞'); need(); }
    else updateStatus('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏');
    return;
  }

  if(tool==='awaitFirst'){
    const snap=findSnapVertexScreen(sx,sy);
    first = snap ? {x:snap.pt.x, y:snap.pt.y} : s2w(sx,sy);
    preview=null; tool='awaitSecond'; updateStatus('1-—è —Ç–æ—á–∫–∞'); need(); return;
  }

  if(tool==='awaitSecond'){
    const snap=findSnapVertexScreen(sx,sy);
    const end = snap ? {x:snap.pt.x, y:snap.pt.y} : s2w(sx,sy);
    segs.push({a:first,b:end}); stack.push('seg');
    first=null; preview=null; snapPreview=null; tool='idle';
    updateStatus('–õ–∏–Ω–∏—è –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª –¥–ª—è –Ω–æ–≤–æ–π.'); need(); return;
  }

  panStart={sx,sy}; panLast={sx,sy}; isPanning=false;
},{passive:false});

cv.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  const {sx,sy}=canvasXY(e); pointers.set(e.pointerId,{sx,sy});

  // –µ—Å–ª–∏ –¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –µ—â—ë –∏–¥—ë—Ç –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–¥–≤–∏–Ω—É–ª ‚Äî –æ—Ç–º–µ–Ω–∏–º –∑–∞–ø—É—Å–∫
  if(pressTimer){
    const p=[...pointers.values()][0];
    if(Math.hypot((p?.sx??sx)-sx,(p?.sy??sy)-sy)>8*DPR){ clearTimeout(pressTimer); pressTimer=null; }
  }

  if(tool==='editEnd' && edit){
    const seg=segs[edit.segIndex], end=edit.end, other=end==='a'?seg.b:seg.a;
    const w=s2w(sx,sy);

    // –æ—Å—å –≤—ã–±–∏—Ä–∞–µ–º –ø–æ –ø–µ—Ä–≤–æ–º—É –¥–≤–∏–∂–µ–Ω–∏—é
    if(!edit.axis){
      const dx=Math.abs(sx-edit.start.sx), dy=Math.abs(sy-edit.start.sy);
      edit.axis = dx>dy ? 'x' : 'y';
    }

    // –ø—Ä–∏—Ç—è–≥–∏–≤–∞–Ω–∏–µ –∫ –¥—Ä—É–≥–∏–º –∫–æ–Ω—Ü–∞–º
    const snap=findSnapVertexScreen(sx,sy);
    let nx=w.x, ny=w.y;
    if(snap){ nx=snap.pt.x; ny=snap.pt.y; }

    // –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –æ—Å–∏
    if(edit.axis==='x'){ ny=other.y; }
    else { nx=other.x; }

    seg[end]={x:nx,y:ny};
    need();
    return;
  }

  if(pointers.size===2){
    const [p0,p1]=[...pointers.values()];
    const nowD=Math.hypot(p0.sx-p1.sx,p0.sy-p1.sy);
    const nowC=centroid();
    if(prevCenter && prevDist){
      const k = (nowD>0 && prevDist>0) ? (nowD/prevDist) : 1;
      const smooth = 1 + (k-1)*0.55;
      const ns=clampScale(view.scale*smooth);
      const cx=nowC.sx, cy=nowC.sy;
      view.tx = cx - (cx - view.tx)*(ns/view.scale);
      view.ty = cy - (cy - view.ty)*(ns/view.scale);
      view.scale = ns; need();
    }
    prevCenter=nowC; prevDist=nowD; return;
  }

  if(panStart && tool!=='awaitSecond' && !edit){
    const moved = Math.hypot(sx-panStart.sx, sy-panStart.sy);
    if(!isPanning && moved>PAN_THRESH) isPanning=true;
    if(isPanning && panLast){
      view.tx += (sx - panLast.sx);
      view.ty += (sy - panLast.sy);
      panLast={sx,sy}; need();
    }
  }

  if(tool==='awaitSecond' && first){
    const snap=findSnapVertexScreen(sx,sy);
    if(snap){ preview={x:snap.pt.x,y:snap.pt.y}; snapPreview=preview; }
    else { preview=s2w(sx,sy); snapPreview=null; }
    need();
  }else if(!edit){
    snapPreview=null;
  }
},{passive:false});

cv.addEventListener('pointerup', e=>{
  pointers.delete(e.pointerId);
  clearTimeout(pressTimer); pressTimer=null;

  if(tool==='editEnd' && edit){
    tool='idle'; updateStatus('–ì–æ—Ç–æ–≤–æ'); need(); edit=null; return;
  }

  if(pointers.size===0){ panStart=null; panLast=null; isPanning=false; prevCenter=null; prevDist=null; }
},{passive:false});

/* ===== –∫–Ω–æ–ø–∫–∏ –∏ –ø–∞–Ω–µ–ª—å ===== */
const $=id=>document.getElementById(id);
$('btnLine').onclick =()=>{ tool='awaitFirst'; first=null; preview=null; snapPreview=null; edit=null; updateStatus('–†–µ–∂–∏–º –õ–∏–Ω–∏—è: —Ç–∫–Ω–∏ 1-—é —Ç–æ—á–∫—É'); };
$('btnUndo').onclick =()=>{
  if(tool==='awaitSecond' && first){ first=null; preview=null; snapPreview=null; tool='idle'; need(); updateStatus('–û—Ç–º–µ–Ω–µ–Ω–æ'); return; }
  const last=stack.pop(); if(!last){ updateStatus('–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å'); return; }
  if(last==='seg' && segs.length) segs.pop();
  else if(last==='comp' && comps.length) comps.pop();
  need(); updateStatus('–û—Ç–º–µ–Ω–µ–Ω–æ');
};
function zoomAt(f){ const cx=cv.width/2, cy=cv.height/2; const ns=clampScale(view.scale*f);
  view.tx=cx-(cx-view.tx)*(ns/view.scale); view.ty=cy-(cy-view.ty)*(ns/view.scale); view.scale=ns; need();
}
$('btnPlus').onclick =()=>zoomAt(1.05);
$('btnMinus').onclick=()=>zoomAt(1/1.05);

const wrap=document.getElementById('panelWrap'), panel=document.getElementById('panel');
const btnSettings=document.getElementById('btnSettings'), btnClose=document.getElementById('btnClosePanel');
const rangeLine=document.getElementById('rangeLine'), lineVal=document.getElementById('lineVal');
const rangeComp=document.getElementById('rangeComp'), compVal=document.getElementById('compVal');

function openPanel(){ wrap.classList.add('open'); wrap.setAttribute('aria-hidden','false'); }
function closePanel(){ wrap.classList.remove('open'); wrap.setAttribute('aria-hidden','true'); }
btnSettings.onclick=openPanel;
btnClose.onclick=closePanel;
document.getElementById('panelBackdrop').onclick=closePanel;
['pointerdown','pointermove','pointerup','click','wheel'].forEach(ev=>panel.addEventListener(ev, e=>e.stopPropagation(), {passive:true}));

document.querySelectorAll('input[name="comp"]').forEach(r=>r.addEventListener('change',()=>{ currentComp=r.value; }));
document.getElementById('btnPlaceComp').onclick=()=>{ closePanel(); tool='placeComp'; updateStatus('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏ ‚Äî –ø–æ—Å—Ç–∞–≤–ª—é '+(currentComp==='valve'?'–∫—Ä–∞–Ω':currentComp==='check'?'–∫–ª–∞–ø–∞–Ω':'–Ω–∞—Å–æ—Å')); };

rangeLine.value=params.linePx; lineVal.textContent=String(params.linePx);
rangeComp.value=params.compScale; compVal.textContent=params.compScale.toFixed(2);
rangeLine.oninput =()=>{ params.linePx=clamp(parseInt(rangeLine.value,10)||10,2,56); lineVal.textContent=String(params.linePx); need(); updateStatus('–¢–æ–ª—â–∏–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞'); };
rangeComp.oninput=()=>{ params.compScale=clamp(parseFloat(rangeComp.value)||1.15,0.5,3.0); compVal.textContent=params.compScale.toFixed(2); need(); updateStatus('–ê—Ä–º–∞—Ç—É—Ä–∞ √ó '+params.compScale.toFixed(2)); };

/* ===== —Å—Ç–∞—Ä—Ç ===== */
fit(); need();
updateStatus('–ì–æ—Ç–æ–≤–æ: –õ–∏–Ω–∏—è ‚Üí –¢–æ—á–∫–∞1 ‚Üí –¢–æ—á–∫–∞2. –ú–∞–≥–Ω–∏—Ç –∫ —Å—Ç—ã–∫–∞–º. –î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –ø–æ —Å—Ç—ã–∫—É ‚Äî –ø—Ä–∞–≤–∫–∞ –ø–æ –æ—Å–∏.');
})();
</script>
</body>
</html>