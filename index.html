<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Трассировка труб — улучшенный зум</title>
<style>
  :root{--ui:#6c4dfc;--txt:#fff}
  html,body{height:100%;margin:0;background:#0f1116;color:#e9e9f0;font-family:system-ui,-apple-system,Inter,Roboto,Arial}
  .toolbar{position:fixed;left:12px;right:12px;top:10px;display:flex;gap:10px;justify-content:center;z-index:5;flex-wrap:wrap}
  .btn{background:var(--ui);color:var(--txt);border:0;border-radius:14px;padding:8px 14px;font-weight:600;box-shadow:0 6px 18px rgba(108,77,252,.25)}
  .ghost{background:#2b2f3a}
  .wrap{position:fixed;inset:64px 10px 10px 10px;display:grid;place-items:center}
  .stage{width:95vw;height:calc(95vh - 64px);border:1px solid rgba(255,255,255,.15);border-radius:10px;position:relative;background:#0f1116;overflow:hidden;touch-action:none}
  canvas{position:absolute;inset:0;width:100%;height:100%}
  .toast{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.6);color:#cfe9cd;padding:8px 12px;border-radius:10px;font-size:14px}
  dialog{border:0;border-radius:14px;background:#1b1e27;color:#fff;width:min(92vw,420px)}
  .dlg-head{padding:14px 16px;font-weight:700}
  .dlg-body{padding:0 16px 16px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:10px 0}
  .dlg-actions{display:flex;gap:10px;justify-content:flex-end;padding:12px 16px 16px}
  input[type="range"]{width:180px}
</style>
</head>
<body>
  <div class="toolbar">
    <button id="lineBtn"   class="btn">Линия</button>
    <button id="undoBtn"   class="btn ghost">Назад</button>
    <button id="centerBtn" class="btn ghost">Центр</button>
    <button id="zoomOutBtn" class="btn ghost">–</button>
    <button id="zoomInBtn"  class="btn ghost">+</button>
    <button id="saveBtn"   class="btn ghost">Сохранить</button>
    <button id="settingsBtn" class="btn ghost">Настройки</button>
  </div>

  <div class="wrap">
    <div id="stage" class="stage">
      <canvas id="cv"></canvas>
    </div>
  </div>

  <div id="toast" class="toast">Режим: ожидание</div>

  <dialog id="dlg">
    <div class="dlg-head">Параметры</div>
    <div class="dlg-body">
      <div class="row"><label>Ø (мм)</label><input id="diam" type="range" min="10" max="300" step="2" value="60"><span id="diamV">60</span></div>
      <div class="row"><label>Сетка</label><input id="grid" type="range" min="24" max="80" step="1" value="40"><span id="gridV">40</span></div>
      <div class="row" style="align-items:flex-start"><label>Фото (фон)</label><input id="bg" type="file" accept="image/*"></div>
    </div>
    <div class="dlg-actions"><button id="dlgClose" class="btn ghost">Закрыть</button></div>
  </dialog>

<script>
(()=>{
// ---------- DOM ----------
const stage = document.getElementById('stage');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const toast = document.getElementById('toast');

const lineBtn = document.getElementById('lineBtn');
const undoBtn = document.getElementById('undoBtn');
const centerBtn = document.getElementById('centerBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const zoomInBtn  = document.getElementById('zoomInBtn');
const saveBtn = document.getElementById('saveBtn');
const settingsBtn = document.getElementById('settingsBtn');

const dlg = document.getElementById('dlg');
const diam = document.getElementById('diam'); const diamV = document.getElementById('diamV');
const grid = document.getElementById('grid'); const gridV = document.getElementById('gridV');
const bg = document.getElementById('bg'); const dlgClose = document.getElementById('dlgClose');

// ---------- Сцена ----------
let scale = 1, minScale=0.05, maxScale=6;    // << зум сильно дальше
let offX = 0, offY = 0;
let gridStep = 40;
let pipeD = 60;

const pipes = []; // {a:{x,y},b:{x,y},d}
let mode = 'idle'; // idle|pickA|pickB
let tempA = null;

let dpr = window.devicePixelRatio || 1;
let cssW=0, cssH=0;
let bgImg = null;

function fit(){
  const r = cv.getBoundingClientRect();
  cssW = Math.max(1, Math.round(r.width));
  cssH = Math.max(1, Math.round(r.height));
  dpr = window.devicePixelRatio || 1;
  cv.width  = Math.round(cssW * dpr);
  cv.height = Math.round(cssH * dpr);
  center();
}
function center(){
  offX = 0; offY = 0; scale = 1;
  redraw();
  setToast('Центр');
}

// --- координаты (работаем в CSS px) ---
function worldToScreen(wx, wy){
  return {x:(wx - offX) * scale + cssW/2, y:(wy - offY) * scale + cssH/2};
}
function screenToWorld(sx, sy){
  return {x:(sx - cssW/2)/scale + offX, y:(sy - cssH/2)/scale + offY};
}

function setToast(t){ toast.textContent = t; }

// --- рендер ---
function redraw(){
  ctx.setTransform(scale*dpr, 0, 0, scale*dpr, (cssW/2 - offX*scale)*dpr, (cssH/2 - offY*scale)*dpr);
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cv.width,cv.height); ctx.restore();

  if(bgImg){
    const w = bgImg.naturalWidth, h = bgImg.naturalHeight;
    ctx.drawImage(bgImg, -w/2, -h/2);
  }
  drawGrid();
  for(const s of pipes) drawPipe(s);

  if(mode==='pickB' && tempA){
    ctx.save(); ctx.fillStyle='#7cf';
    const r = 4/scale; ctx.beginPath(); ctx.arc(tempA.x,tempA.y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
}

function drawGrid(){
  const step = gridStep, extent = 3000;
  ctx.save(); ctx.lineWidth = 1/scale;
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.beginPath();
  for(let x=-extent;x<=extent;x+=step){ ctx.moveTo(x,-extent); ctx.lineTo(x,extent); }
  for(let y=-extent;y<=extent;y+=step){ ctx.moveTo(-extent,y); ctx.lineTo(extent,y); }
  ctx.stroke();
  ctx.strokeStyle='rgba(255,120,120,.35)'; ctx.beginPath(); ctx.moveTo(-extent,0); ctx.lineTo(extent,0); ctx.stroke();
  ctx.strokeStyle='rgba(120,170,255,.35)'; ctx.beginPath(); ctx.moveTo(0,-extent); ctx.lineTo(0,extent); ctx.stroke();
  ctx.restore();
}

function drawPipe(s){
  const w = Math.max(2, s.d/4);
  ctx.save(); ctx.lineWidth=w/scale; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#4da1ff';
  ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
  const r=(w/2)/scale; ctx.fillStyle='#4da1ff';
  for(const p of [s.a,s.b]){ ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); }
  ctx.restore();
}

// ---------- Кнопки ----------
document.getElementById('centerBtn').onclick = center;
document.getElementById('lineBtn').onclick = ()=>{ mode='pickA'; tempA=null; setToast('Линия: поставь точку 1'); };
document.getElementById('undoBtn').onclick = ()=>{ pipes.pop(); redraw(); setToast('Отменено'); };
document.getElementById('saveBtn').onclick = ()=>{ const a=document.createElement('a'); a.href=cv.toDataURL('image/png'); a.download='pipes.png'; a.click(); };
document.getElementById('settingsBtn').onclick = ()=> dlg.showModal();
document.getElementById('dlgClose').onclick = ()=> dlg.close();

diam.oninput = ()=>{ pipeD=+diam.value; diamV.textContent=pipeD; redraw(); };
grid.oninput = ()=>{ gridStep=+grid.value; gridV.textContent=gridStep; redraw(); };
bg.onchange = e=>{ const f=e.target.files?.[0]; if(!f) return; const img=new Image(); img.onload=()=>{ bgImg=img; redraw(); }; img.src=URL.createObjectURL(f); };

// --- авто-удержание на –/+ ---
let holdTimer=null, holdRAF=null;
function startHold(fn){ stopHold(); fn(); holdTimer=setTimeout(function loop(){ fn(); holdRAF=requestAnimationFrame(loop); }, 140); }
function stopHold(){ clearTimeout(holdTimer); cancelAnimationFrame(holdRAF); holdTimer=null; holdRAF=null; }

zoomOutBtn.addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomButton(-1));},{passive:false});
zoomOutBtn.addEventListener('mousedown',   ()=>startHold(()=>zoomButton(-1)));
zoomInBtn .addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomButton(+1));},{passive:false});
zoomInBtn .addEventListener('mousedown',   ()=>startHold(()=>zoomButton(+1)));
['mouseleave','mouseup','touchend','touchcancel'].forEach(ev=>{
  zoomOutBtn.addEventListener(ev, stopHold); zoomInBtn.addEventListener(ev, stopHold);
});
function zoomButton(dir){
  const rect=cv.getBoundingClientRect();
  const cx=rect.width/2, cy=rect.height/2;
  zoomAt(cx,cy, dir>0 ? 1.15 : 0.85); // << шаг поярче
  redraw();
}

// ---------- Жесты ----------
let lastTouches=[];
stage.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===1){
    onTap(ev.touches[0]);
  }else if(ev.touches.length===2){
    lastTouches = copyTouches(ev.touches);
  }
},{passive:false});

stage.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===2) pinchPan(ev.touches);
},{passive:false});

stage.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length<2) lastTouches=[];
},{passive:false});

// Мышь
let dragging=false, prev={x:0,y:0};
stage.addEventListener('mousedown', e=>{
  if(mode==='pickA'||mode==='pickB'){ onTap(e); return; }
  dragging=true; prev={x:e.clientX,y:e.clientY};
});
stage.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx=e.clientX-prev.x, dy=e.clientY-prev.y;
  offX -= dx/scale; offY -= dy/scale;
  prev={x:e.clientX,y:e.clientY}; redraw();
});
stage.addEventListener('mouseup', ()=> dragging=false);
stage.addEventListener('wheel', e=>{
  const rect=cv.getBoundingClientRect();
  const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  zoomAt(cx, cy, e.deltaY>0? 0.85:1.15); // << сильнее
  e.preventDefault();
},{passive:false});

// Тап — ставим точки только в режиме Линия
function onTap(p){
  const rect = cv.getBoundingClientRect();
  const sx = ('clientX' in p ? p.clientX : p.x) - rect.left;
  const sy = ('clientY' in p ? p.clientY : p.y) - rect.top;
  const wpos = screenToWorld(sx, sy);

  if(mode==='pickA'){
    tempA = wpos; mode='pickB'; setToast('Поставь точку 2');
  }else if(mode==='pickB' && tempA){
    pipes.push({a:{...tempA}, b:wpos, d:pipeD});
    tempA=null; mode='idle'; setToast('Линия готова. Для новой — «Линия».'); redraw();
  }else{
    setToast('Нажми «Линия», затем поставь 2 точки.');
  }
}

// пинч+пан двумя пальцами
function copyTouches(ts){ return [...ts].map(t=>({x:t.clientX,y:t.clientY})); }
function pinchPan(ts){
  const now = copyTouches(ts); if(now.length<2||lastTouches.length<2) return;
  const prevD = Math.hypot(lastTouches[0].x-lastTouches[1].x, lastTouches[0].y-lastTouches[1].y);
  const currD = Math.hypot(now[0].x-now[1].x, now[0].y-now[1].y);
  const rect = cv.getBoundingClientRect();
  const pcx=(lastTouches[0].x+lastTouches[1].x)/2 - rect.left;
  const pcy=(lastTouches[0].y+lastTouches[1].y)/2 - rect.top;
  const ncx=(now[0].x+now[1].x)/2 - rect.left;
  const ncy=(now[0].y+now[1].y)/2 - rect.top;

  zoomAt(ncx, ncy, Math.pow(currD/prevD, 1)); // без ослабления
  offX -= (ncx-pcx)/scale;
  offY -= (ncy-pcy)/scale;

  lastTouches = now; redraw();
}
function zoomAt(sx,sy,zoom){
  const before = screenToWorld(sx,sy);
  scale = Math.min(maxScale, Math.max(minScale, scale*zoom));
  const after = screenToWorld(sx,sy);
  offX += before.x - after.x;
  offY += before.y - after.y;
}

// ---------- init ----------
new ResizeObserver(()=>{ fit(); }).observe(stage);
fit();
setToast('Режим: ожидание');
})();
</script>
</body>
</html>
