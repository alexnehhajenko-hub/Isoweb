<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî –ú–∞—Å–∫–∞ (–ø–µ—Ä–µ–¥–Ω–∏–π –ø–ª–∞–Ω) + —Ñ—É–ª–ª—Å–∫—Ä–∏–Ω-—Ñ–∏–∫—Å</title>
<style>
  :root{--violet:#8000ff; --violet2:#7618ff}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}

  /* –ü–æ–ª–Ω—ã–π HUD: 2 —Ä—è–¥–∞ / 6 –∫–æ–ª–æ–Ω–æ–∫ */
  .hud{position:fixed;top:8px;left:8px;right:8px;z-index:1000;display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px;transition:.2s ease opacity}
  .hud.hidden{opacity:0;pointer-events:none}
  .hud button{height:40px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .hud .wide{grid-column:span 2}

  /* –ú–∏–Ω–∏-HUD (–∫–æ–≥–¥–∞ –ø–æ–ª–Ω—ã–π —Å–∫—Ä—ã—Ç) */
  .mini{position:fixed;top:8px;right:8px;z-index:1001;display:flex;gap:8px}
  .mini.hidden{display:none}
  .mini button{height:40px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800;padding:0 14px}

  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:8px 10px;border-radius:10px;opacity:0;transition:.25s;z-index:1100}
  .toast.show{opacity:1}

  /* –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
  .panel-wrap{position:fixed;inset:0;z-index:1050;display:none}
  .panel-wrap.open{display:block}
  .panel-backdrop{position:absolute;inset:0;background:transparent}
  .panel{position:absolute;top:96px;right:8px;background:#fff;border:1px solid #e7e3f7;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.08);padding:12px;width:min(92vw,360px)}
  .panel h4{margin:0 0 8px 0;font-size:15px}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  .row label{min-width:150px;font-size:13px;color:#555}
  .row input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#eee}
  .row input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--violet)}
  .switch{display:flex;align-items:center;gap:8px}
  .close{position:absolute;top:6px;right:8px;line-height:1;border:none;background:transparent;font-size:20px;color:#666}

  /* –ú–æ–¥–∞–ª–∫–∞ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ (–∑–∞–º–µ–Ω–∞ prompt) */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1200}
  .modal.show{display:flex}
  .modal .bg{position:absolute;inset:0;background:rgba(0,0,0,.25)}
  .modal .card{position:relative;min-width:280px;max-width:90vw;background:#fff;border:1px solid #e7e3f7;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:14px}
  .modal h4{margin:0 0 10px 0}
  .modal input{width:100%;padding:10px;border:1px solid #d8c9ff;border-radius:10px;margin-bottom:10px;font-size:16px}
  .modal .actions{display:flex;gap:8px;justify-content:flex-end}
  .modal .actions button{height:38px;border:0;border-radius:10px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:700;padding:0 14px}
  .modal .actions .ghost{background:#fff;color:#5c30b5;border:1px solid #d8c9ff}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <!-- –ü–û–õ–ù–´–ô HUD -->
  <div id="hud" class="hud">
    <!-- —Ä—è–¥ 1 -->
    <button id="btnCamera">üì∑ –ö–∞–º–µ—Ä–∞</button>
    <button id="btnGallery">üìÇ –ì–∞–ª–µ—Ä–µ—è</button>
    <button id="btnLine">–õ–∏–Ω–∏—è</button>
    <button id="btnText">–¢–µ–∫—Å—Ç</button>
    <button id="btnEraser">–õ–∞—Å—Ç–∏–∫ (—á–∞—Å—Ç—å)</button>
    <button id="btnMask">–ú–∞—Å–∫–∞ (–ø–µ—Ä–µ–¥–Ω–∏–π –ø–ª–∞–Ω)</button>
    <!-- —Ä—è–¥ 2 -->
    <button id="btnUndo" class="wide">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnClear" class="wide">üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
    <button id="btnExport" class="wide">‚§ì PNG</button>
    <button id="btnSnap" class="wide">üß≤ –ú–∞–≥–Ω–∏—Ç: –í–∫–ª</button>
    <button id="btnSettings" class="wide">‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
  </div>

  <!-- –ú–ò–ù–ò-HUD, –∫–æ–≥–¥–∞ –±–æ–ª—å—à–æ–π —Å–∫—Ä—ã—Ç (–º–∏–Ω–∏–º—É–º, –∫–∞–∫ –ø—Ä–æ—Å–∏–ª) -->
  <div id="mini" class="mini hidden">
    <button id="miniLine">–õ–∏–Ω–∏—è</button>
    <button id="miniEraser">–õ–∞—Å—Ç–∏–∫</button>
  </div>

  <!-- –∏–Ω–ø—É—Ç—ã —Ñ–æ—Ç–æ -->
  <input id="fileCamera"  type="file" accept="image/*" capture="environment" hidden />
  <input id="fileGallery" type="file" accept="image/*" hidden />

  <div id="toast" class="toast"></div>

  <!-- –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
  <div id="panelWrap" class="panel-wrap" aria-hidden="true">
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <div id="panel" class="panel" role="dialog" aria-modal="true">
      <button id="panelClose" class="close" aria-label="–ó–∞–∫—Ä—ã—Ç—å">√ó</button>

      <h4>–õ–∏–Ω–∏–∏</h4>
      <div class="row">
        <label>–¢–æ–ª—â–∏–Ω–∞ (px)</label>
        <input id="lineWidth" type="range" min="2" max="24" value="6">
        <span id="lineWidthVal" style="width:36px;text-align:right;font-size:12px;color:#666">6</span>
      </div>

      <h4 style="margin-top:12px">–°–µ—Ç–∫–∞</h4>
      <div class="row">
        <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</label>
        <input id="gridAlpha" type="range" min="0" max="100" value="22">
        <span id="gridAlphaVal" style="width:36px;text-align:right;font-size:12px;color:#666">22%</span>
      </div>
      <div class="row">
        <label>–®–∞–≥ (px)</label>
        <input id="gridStep" type="range" min="80" max="480" value="200">
        <span id="gridStepVal" style="width:36px;text-align:right;font-size:12px;color:#666">200</span>
      </div>
      <div class="row">
        <label>–£–≥–æ–ª (¬∞)</label>
        <input id="gridAngle" type="range" min="-90" max="90" value="30">
        <span id="gridAngleVal" style="width:36px;text-align:right;font-size:12px;color:#666">30</span>
      </div>

      <h4 style="margin-top:12px">–ú–∞–≥–Ω–∏—Ç</h4>
      <div class="row switch">
        <input id="snapOn" type="checkbox" checked>
        <label for="snapOn">–ì–ª–∞–≤–Ω—ã–π –º–∞–≥–Ω–∏—Ç</label>
      </div>
      <div class="row">
        <label>–†–∞–¥–∏—É—Å —É–∑–ª–∞ (px)</label>
        <input id="snapRadius" type="range" min="10" max="60" value="22">
        <span id="snapRadiusVal" style="width:36px;text-align:right;font-size:12px;color:#666">22</span>
      </div>

      <div class="row switch">
        <input id="isoSnapOn" type="checkbox" checked>
        <label for="isoSnapOn">–ê–≤—Ç–æ–≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ –∏–∑–æ–º–µ—Ç—Ä–∏–∏</label>
      </div>
      <div class="row">
        <label>–ü–æ—Ä–æ–≥ —É–≥–ª–∞ (¬±¬∞)</label>
        <input id="isoTol" type="range" min="4" max="20" value="10">
        <span id="isoTolVal" style="width:36px;text-align:right;font-size:12px;color:#666">10</span>
      </div>

      <h4 style="margin-top:12px">–ú–∞—Å–∫–∞</h4>
      <div class="row">
        <label>–ö–∏—Å—Ç—å –º–∞—Å–∫–∏ (px)</label>
        <input id="maskSize" type="range" min="8" max="60" value="26">
        <span id="maskSizeVal" style="width:36px;text-align:right;font-size:12px;color:#666">26</span>
      </div>
    </div>
  </div>

  <!-- –ú–æ–¥–∞–ª–∫–∞ –¥–ª—è –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ -->
  <div id="textModal" class="modal" aria-hidden="true">
    <div class="bg"></div>
    <div class="card" role="dialog" aria-modal="true" aria-labelledby="textTitle">
      <h4 id="textTitle">–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å—å</h4>
      <input id="textInput" type="text" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: √ò159, 1200 –º–º" />
      <div class="actions">
        <button id="textCancel" class="ghost">–û—Ç–º–µ–Ω–∞</button>
        <button id="textOk">–û–ö</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ===== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã =====
  const DPR = Math.min(1.5, Math.max(1, (window.devicePixelRatio||1)));
  const MAX_IMG_SIDE = 2000;
  const EDIT_HOLD_MS = 500;
  const TAP_MOVE_TOL = 10;
  const ERASER_HIT = 18;
  const ERASER_GAP = 24;

  // ===== DOM =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha: false });
  const hudEl = document.getElementById('hud');
  const miniEl = document.getElementById('mini');
  const toastEl = document.getElementById('toast');
  const textModal = document.getElementById('textModal');
  const textInput = document.getElementById('textInput');

  const toast = (t,ms=1200)=>{ toastEl.textContent=t; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); };
  const $ = id => document.getElementById(id);

  // ===== –°–æ—Å—Ç–æ—è–Ω–∏–µ =====
  const photo = { img:null, w:0, h:0, cx:0, cy:0, s:1, alpha:0.9 };
  const segs = [];   // {a:{x,y}, b:{x,y}}
  const labels = []; // {x,y,text}
  const mask = { strokes:[], brushPx:26, drawing:false }; // —Å–ø–∏—Å–æ–∫ —à—Ç—Ä–∏—Ö–æ–≤ –º–∞—Å–∫–∏ (–≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
  let mode = 'idle'; // idle | line | textPlace | erase | edit | mask
  let firstPt = null, previewPt = null;

  const grid = { alpha:0.22, step:200, angleDeg:30 };
  const snap = { on:true, radiusPx:22, isoOn:true, isoTolDeg:10 };
  let lineWidthPx = 6;

  // –∂–µ—Å—Ç—ã
  const pointers = new Map();
  let last1 = null;
  let holdTimer = null;
  let downInfo = null;
  let lastTapTime = 0;

  // –ø—Ä–∞–≤–∫–∞
  let editing = null; // {type:'seg', segIndex, end:'a'|'b'} | {type:'label', labelIndex}

  // offscreen –¥–ª—è –ª–∏–Ω–∏–π (–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ —Ñ–æ—Ç–æ)
  let linesCv = document.createElement('canvas');
  let linesCtx = linesCv.getContext('2d', { alpha:true });

  // ===== –≠–∫—Ä–∞–Ω <-> –ú–∏—Ä =====
  const screenToWorld = (sx,sy)=>({ x:(sx - photo.cx)/photo.s, y:(sy - photo.cy)/photo.s });
  const worldToScreen = (x,y)=>({ x: photo.cx + x*photo.s, y: photo.cy + y*photo.s });

  // ===== –°–µ—Ä–≤–∏—Å–Ω—ã–µ =====
  function fit(){
    cv.width=Math.floor(innerWidth*DPR); cv.height=Math.floor(innerHeight*DPR);
    if(linesCv.width!==cv.width || linesCv.height!==cv.height){
      linesCv.width=cv.width; linesCv.height=cv.height;
    }
    draw();
  }
  addEventListener('resize', ()=>{ closePanel(); fit(); });

  function downscaleImage(img){
    const maxSide=Math.max(img.width,img.height);
    if(maxSide<=MAX_IMG_SIDE) return img;
    const scale=MAX_IMG_SIDE/maxSide, w=Math.round(img.width*scale), h=Math.round(img.height*scale);
    const off=document.createElement('canvas'); off.width=w; off.height=h;
    const octx=off.getContext('2d'); octx.imageSmoothingEnabled=true; octx.imageSmoothingQuality='high';
    octx.drawImage(img,0,0,w,h);
    const scaled=new Image(); scaled.src=off.toDataURL('image/jpeg',0.9); return scaled;
  }
  function loadFromFile(file){
    if(!file){ toast('–§–æ—Ç–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ'); return; }
    const url=URL.createObjectURL(file); const img=new Image();
    img.onload=()=>{
      URL.revokeObjectURL(url);
      const scaled=downscaleImage(img);
      if(scaled===img) applyImage(img); else scaled.onload=()=>applyImage(scaled);
    };
    img.src=url;
  }
  function applyImage(img){
    photo.img=img; photo.w=img.width; photo.h=img.height;
    const sx=(cv.width/DPR)/photo.w*0.9, sy=(cv.height/DPR)/photo.h*0.9;
    photo.s=Math.max(0.02,Math.min(sx,sy))*DPR; photo.cx=cv.width/2; photo.cy=cv.height/2;
    draw(); toast('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ');
  }

  // ===== –†–∏—Å–æ–≤–∞–Ω–∏–µ =====
  function draw(){
    // —Ñ–æ–Ω
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,cv.width,cv.height);

    // —Ñ–æ—Ç–æ
    if(photo.img){
      ctx.save();
      ctx.globalAlpha=photo.alpha;
      ctx.translate(photo.cx,photo.cy); ctx.scale(photo.s,photo.s);
      ctx.imageSmoothingEnabled=true;
      ctx.drawImage(photo.img,-photo.w/2,-photo.h/2,photo.w,photo.h);
      ctx.restore();
    }

    // —Å–µ—Ç–∫–∞
    drawIsoGrid();

    // ------- –ª–∏–Ω–∏–∏ –Ω–∞ offscreen-—Å–ª–æ–µ -------
    linesCtx.clearRect(0,0,linesCv.width,linesCv.height);
    linesCtx.lineCap='round'; linesCtx.lineJoin='round';
    for(const s of segs){
      const A=worldToScreen(s.a.x,s.a.y);
      const B=worldToScreen(s.b.x,s.b.y);
      // —Ç–µ–Ω—å
      linesCtx.strokeStyle='#5b00bf'; linesCtx.lineWidth=(lineWidthPx+2); linesCtx.globalAlpha=.7;
      linesCtx.beginPath(); linesCtx.moveTo(A.x,A.y); linesCtx.lineTo(B.x,B.y); linesCtx.stroke();
      // —Ç–µ–ª–æ
      linesCtx.strokeStyle='#8000ff'; linesCtx.lineWidth=lineWidthPx; linesCtx.globalAlpha=1;
      linesCtx.beginPath(); linesCtx.moveTo(A.x,A.y); linesCtx.lineTo(B.x,B.y); linesCtx.stroke();
    }

    // –ø—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å–∫—É: ¬´–≤—ã—Ä–µ–∑–∞–µ–º¬ª –ª–∏–Ω–∏–∏ –≤ –º–µ—Å—Ç–∞—Ö –º–∞–∑–∫–æ–≤ –º–∞—Å–∫–∏
    if(mask.strokes.length){
      linesCtx.save();
      linesCtx.globalCompositeOperation='destination-out';
      linesCtx.lineCap='round'; linesCtx.lineJoin='round';
      linesCtx.strokeStyle='rgba(0,0,0,1)';
      linesCtx.lineWidth=mask.brushPx*DPR;
      for(const st of mask.strokes){
        if(st.length<2) continue;
        linesCtx.beginPath();
        const p0=worldToScreen(st[0].x,st[0].y); linesCtx.moveTo(p0.x,p0.y);
        for(let i=1;i<st.length;i++){
          const p=worldToScreen(st[i].x,st[i].y);
          linesCtx.lineTo(p.x,p.y);
        }
        linesCtx.stroke();
      }
      linesCtx.restore();
    }

    // –ø–µ—Ä–µ–Ω–æ—Å–∏–º —Å–ª–æ–π –ª–∏–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —Ö–æ–ª—Å—Ç
    ctx.drawImage(linesCv,0,0);

    // –ø–æ–¥–ø–∏—Å–∏ –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
    for(let i=0;i<labels.length;i++) drawLabel(labels[i], i);

    // –º–∞—Ä–∫–µ—Ä—ã/–ø—Ä–µ–≤—å—é
    if(firstPt && mode==='line') drawMarker(firstPt,'#00a86b');
    if(previewPt && mode==='line') drawPreview(firstPt,previewPt);

    // –≤–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ –∫–∏—Å—Ç–∏ –º–∞—Å–∫–∏ (–∫—Ä—É–∂–æ–∫ –ø–æ–¥ –ø–∞–ª—å—Ü–µ–º ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    // (—É–ø—Ä–æ—â—ë–Ω–Ω–æ: –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ–º —Å–µ–π—á–∞—Å –≤–æ –∏–∑–±–µ–∂–∞–Ω–∏–µ ¬´–ª–∏–ø–∫–æ–π¬ª —Ç–æ—á–∫–∏)
  }

  function drawIsoGrid(){
    const a=grid.alpha; if(a<=0) return;
    const base=[grid.angleDeg,90,180-grid.angleDeg];
    const margin=2000;
    ctx.save();
    for(const ang of base){
      const r=ang*Math.PI/180, vx=Math.cos(r), vy=Math.sin(r), px=-vy, py=vx;
      const need=Math.ceil((Math.max(cv.width,cv.height)+margin*2)/(grid.step*photo.s))+2;
      for(let k=-need;k<=need;k++){
        const bx=px*k*grid.step, by=py*k*grid.step;
        const A=worldToScreen(bx-vx*100000, by-vy*100000);
        const B=worldToScreen(bx+vx*100000, by+vy*100000);
        const major=(k%3===0);
        ctx.globalAlpha=(major?a*1.3:a);
        ctx.strokeStyle= major? '#b7bcc8' : '#cfd3dc';
        ctx.lineWidth= major? 1.6 : 1.0;
        ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      }
    }
    ctx.restore(); ctx.globalAlpha=1;
  }

  function drawMarker(pt,color){
    const S=worldToScreen(pt.x,pt.y);
    ctx.fillStyle=color; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(S.x,S.y,8,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }
  function drawHandle(pt){
    const S=worldToScreen(pt.x,pt.y);
    ctx.fillStyle='#15a34a'; ctx.strokeStyle='#0f5132'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(S.x,S.y,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }
  function drawPreview(a,b){
    const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
    ctx.save();
    ctx.setLineDash([8,8]); ctx.strokeStyle='#16a34a'; ctx.lineWidth=Math.max(3,lineWidthPx-2);
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    ctx.setLineDash([]); drawMarker(b,'#16a34a'); ctx.restore();
  }

  // ===== –ú–µ—Ç–∫–∏ (—Ç–µ–∫—Å—Ç) =====
  function drawLabel(lbl, idx){
    const s=worldToScreen(lbl.x,lbl.y);
    const padH=8, padV=6, r=8;
    ctx.font='600 16px system-ui,-apple-system,Segoe UI,Roboto';
    const w=ctx.measureText(lbl.text).width + padH*2;
    const h=24 + (padV-6);
    ctx.fillStyle='rgba(255,255,255,.96)';
    ctx.strokeStyle='#8000ff'; ctx.lineWidth=1;
    roundRectPath(ctx, s.x-w/2, s.y-h/2, w, h, r); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#8000ff'; ctx.textBaseline='middle';
    ctx.fillText(lbl.text, s.x - (w/2) + padH, s.y);
    if(editing && editing.type==='label' && editing.labelIndex===idx){
      ctx.strokeStyle='#16a34a'; ctx.lineWidth=2;
      roundRectPath(ctx, s.x-w/2-2, s.y-h/2-2, w+4, h+4, r+2); ctx.stroke();
    }
  }
  function roundRectPath(c,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    c.beginPath();
    c.moveTo(x+rr,y);
    c.arcTo(x+w,y,x+w,y+h,rr);
    c.arcTo(x+w,y+h,x,y+h,rr);
    c.arcTo(x,y+h,x,y,rr);
    c.arcTo(x,y,x+w,y,rr);
    c.closePath();
  }
  function hitLabelAt(sx,sy){
    ctx.font='600 16px system-ui,-apple-system,Segoe UI,Roboto';
    for(let i=labels.length-1;i>=0;i--){
      const lbl=labels[i], p=worldToScreen(lbl.x,lbl.y);
      const w=ctx.measureText(lbl.text).width + 16, h=24;
      const x=p.x - w/2, y=p.y - h/2;
      if(sx>=x-6 && sx<=x+w+6 && sy>=y-6 && sy<=y+h+6) return i;
    }
    return -1;
  }

  // ===== –ü–æ–∏—Å–∫ –∫–æ–Ω—Ü–∞ –ª–∏–Ω–∏–∏ –¥–ª—è –ø—Ä–∞–≤–∫–∏ =====
  function findEndpointNear(sx,sy, radiusPx=18){
    const R=radiusPx*DPR;
    let best=null, bestDist=Infinity;
    for(let i=0;i<segs.length;i++){
      const s=segs[i];
      const A=worldToScreen(s.a.x,s.a.y);
      const B=worldToScreen(s.b.x,s.b.y);
      const dA=Math.hypot(A.x-sx,A.y-sy);
      const dB=Math.hypot(B.x-sx,B.y-sy);
      if(dA<bestDist && dA<=R){ best={segIndex:i,end:'a'}; bestDist=dA; }
      if(dB<bestDist && dB<=R){ best={segIndex:i,end:'b'}; bestDist=dB; }
    }
    return best;
  }

  // ===== –ß–∞—Å—Ç–∏—á–Ω—ã–π –ª–∞—Å—Ç–∏–∫ (—Ä–µ–∑–∫–∞) =====
  function distanceToSegmentScreen(sx,sy, A,B){
    const vx=B.x-A.x, vy=B.y-A.y;
    const wx=sx-A.x, wy=sy-A.y;
    const c1=vx*wx+vy*wy;
    if(c1<=0) return Math.hypot(sx-A.x, sy-A.y);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(sx-B.x, sy-B.y);
    const t=c1/c2;
    const px=A.x+t*vx, py=A.y+t*vy;
    return Math.hypot(sx-px, sy-py);
  }
  function splitSegmentAtScreen(i, sx, sy){
    const s = segs[i];
    const A = worldToScreen(s.a.x,s.a.y), B = worldToScreen(s.b.x,s.b.y);
    const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy;
    if(len2===0) return false;
    const t = Math.max(0, Math.min(1, ((sx-A.x)*vx+(sy-A.y)*vy)/len2 ));
    const lenWorld = Math.hypot(s.b.x-s.a.x, s.b.y-s.a.y);
    const gapT = Math.min(0.45, (ERASER_GAP/DPR)/ (photo.s*lenWorld) );
    const t0 = Math.max(0, t - gapT), t1 = Math.min(1, t + gapT);
    const P0 = { x: s.a.x + (s.b.x - s.a.x)*t0, y: s.a.y + (s.b.y - s.a.y)*t0 };
    const P1 = { x: s.a.x + (s.b.x - s.a.x)*t1, y: s.a.y + (s.b.y - s.a.y)*t1 };
    const left  = (t0>0.02) ? {a:{...s.a}, b:P0} : null;
    const right = (t1<0.98) ? {a:P1, b:{...s.b}} : null;
    segs.splice(i,1, ...[left,right].filter(Boolean));
    return true;
  }
  function eraseAtScreenPointPartial(sx,sy){
    const lbl = hitLabelAt(sx,sy);
    if(lbl!==-1){ labels.splice(lbl,1); draw(); return true; }
    let bestI=-1, bestD=Infinity;
    for(let i=0;i<segs.length;i++){
      const s=segs[i];
      const A=worldToScreen(s.a.x,s.a.y), B=worldToScreen(s.b.x,s.b.y);
      const d=distanceToSegmentScreen(sx,sy,A,B);
      if(d<bestD){ bestD=d; bestI=i; }
    }
    if(bestI!==-1 && bestD<=ERASER_HIT*DPR){
      const ok = splitSegmentAtScreen(bestI, sx, sy);
      if(ok){ draw(); return true; }
    }
    return false;
  }

  // ===== –°–Ω–∞–ø—ã =====
  function allNodes(){ const arr=[]; for(const s of segs){ arr.push(s.a,s.b); } return arr; }
  function snapToNodes(raw, radiusPx=snap.radiusPx){
    if(!snap.on) return raw;
    const sx=photo.cx+raw.x*photo.s, sy=photo.cy+raw.y*photo.s;
    let best=null, bestDist=Infinity;
    for(const n of allNodes()){
      const ns=worldToScreen(n.x,n.y);
      const d=Math.hypot(ns.x-sx,ns.y-sy);
      if(d<bestDist){ bestDist=d; best=n; }
    }
    const R=radiusPx*DPR;
    if(best && bestDist<=R) return {x:best.x,y:best.y};
    return raw;
  }
  const normDeg=a=>((a%360)+360)%360;
  const angDiff=(a,b)=>{ let d=Math.abs(a-b)%360; return d>180?360-d:d; };
  function snapToIso(raw, startPoint, tolDeg=snap.isoTolDeg){
    if(!(snap.on && snap.isoOn && startPoint)) return raw;
    const v={x:raw.x-startPoint.x,y:raw.y-startPoint.y};
    const L=Math.hypot(v.x,v.y); if(L===0) return raw;
    const base=[grid.angleDeg,90,180-grid.angleDeg];
    const targets=[...base, base[0]+180, base[1]+180, base[2]+180];
    const ang=normDeg(Math.atan2(v.y,v.x)*180/Math.PI);
    let bestA=null, bestD=181;
    for(const t of targets){ const d=angDiff(ang,normDeg(t)); if(d<bestD){ bestD=d; bestA=t; } }
    if(bestD<=tolDeg){
      const a=bestA*Math.PI/180;
      return { x:startPoint.x+Math.cos(a)*L, y:startPoint.y+Math.sin(a)*L };
    }
    return raw;
  }
  function snapPoint(raw, startPoint){
    if(!snap.on) return raw;
    let p=snapToNodes(raw);
    p=snapToIso(p,startPoint);
    return p;
  }
  function autoCorrectPoint(startPoint, rawEnd){
    if(!snap.on) return rawEnd;
    let p=snapToNodes(rawEnd, Math.max(snap.radiusPx, 28));
    p=snapToIso(p,startPoint, Math.max(snap.isoTolDeg, 12));
    return p;
  }

  // ===== –ñ–µ—Å—Ç—ã =====
  cv.addEventListener('pointerdown', e=>{
    closePanel();
    cv.setPointerCapture?.(e.pointerId);
    const p={x:e.clientX*DPR,y:e.clientY*DPR};
    pointers.set(e.pointerId,p);
    if(pointers.size===1) last1=p;

    downInfo = {id:e.pointerId, sx:p.x, sy:p.y, moved:false, multi:false};

    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      if(downInfo && !downInfo.moved && !downInfo.multi){
        // –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞ –ª–∏–Ω–∏–∏
        const hitEnd = findEndpointNear(p.x,p.y, 18);
        if(hitEnd){
          mode='edit';
          editing={type:'seg', ...hitEnd};
          toast('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–æ—Ç—è–Ω–∏. –ü–æ—á—Ç–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ ‚Äî —Å—Ç—Ä–æ–≥–æ –ø–æ –≤—ã—Å–æ—Ç–µ.');
          draw(); return;
        }
        // –ø—Ä–∞–≤–∫–∞ –ø–æ–¥–ø–∏—Å–∏
        const lblIndex = hitLabelAt(p.x,p.y);
        if(lblIndex!==-1){
          mode='edit';
          editing={type:'label', labelIndex:lblIndex};
          toast('–ü–µ—Ä–µ—Ç–∞—â–∏ –ø–æ–¥–ø–∏—Å—å –∏ –æ—Ç–ø—É—Å—Ç–∏');
          draw(); return;
        }
      }
    }, EDIT_HOLD_MS);

    // –Ω–∞—á–∞–ª–æ —à—Ç—Ä–∏—Ö–∞ –º–∞—Å–∫–∏
    if(mode==='mask'){
      const w=screenToWorld(p.x,p.y);
      mask.drawing=true;
      mask.strokes.push([w]);
      draw();
    }

    if(mode==='line' && firstPt){
      let w=screenToWorld(p.x,p.y);
      previewPt=snapPoint(w, firstPt); draw();
    }
  }, {passive:true});

  cv.addEventListener('pointermove', e=>{
    if(!pointers.has(e.pointerId)) return;
    const cur={x:e.clientX*DPR,y:e.clientY*DPR};
    const prev=pointers.get(e.pointerId); pointers.set(e.pointerId,cur);

    if(downInfo && e.pointerId===downInfo.id){
      const dist=Math.hypot(cur.x-downInfo.sx, cur.y-downInfo.sy)/DPR;
      if(dist>TAP_MOVE_TOL) downInfo.moved=true;
    }

    if(pointers.size>=2){
      if(downInfo) downInfo.multi=true;
      const ids=[...pointers.keys()];
      const a=pointers.get(ids[0]), b=pointers.get(ids[1]);
      const ap=(ids[0]===e.pointerId?prev:a), bp=(ids[1]===e.pointerId?prev:b);
      const dPrev=Math.hypot(ap.x-bp.x,ap.y-bp.y), dCur=Math.hypot(a.x-b.x,a.y-b.y);
      const cCur={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
      if(dPrev>0){
        const f=dCur/dPrev, dx=cCur.x-photo.cx, dy=cCur.y-photo.cy;
        photo.cx += dx-dx*f; photo.cy += dy-dy*f;
        photo.s = Math.max(0.02*DPR, Math.min(photo.s*f, 50*DPR));
      }
      draw(); last1=null; return;
    }

    // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ —Ä–∏—Å—É–µ–º/–Ω–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º/–Ω–µ –º–∞—Å–∫–∞
    if(last1 && photo.img && mode!=='line' && mode!=='mask' && !(editing && (editing.type==='seg'||editing.type==='label'))){
      photo.cx += cur.x-last1.x; photo.cy += cur.y-last1.y; last1=cur; draw();
    }

    // —Ä–∏—Å—É–µ–º –º–∞—Å–∫—É
    if(mode==='mask' && mask.drawing){
      const st = mask.strokes[mask.strokes.length-1];
      const w=screenToWorld(cur.x,cur.y);
      const last=st[st.length-1];
      if(Math.hypot(w.x-last.x, w.y-last.y) > 1/photo.s){ st.push(w); draw(); }
    }

    // –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞ –ª–∏–Ω–∏–∏
    if(mode==='edit' && editing && editing.type==='seg'){
      const s=segs[editing.segIndex];
      const start = (editing.end==='a')? s.b : s.a;
      const startScr = worldToScreen(start.x,start.y);
      const dxs = cur.x - startScr.x, dys = cur.y - startScr.y;
      let w = screenToWorld(cur.x,cur.y);
      const almostVertical = Math.abs(dxs) < Math.abs(dys)*0.6;
      if(almostVertical){
        const rawY = screenToWorld(cur.x,cur.y).y;
        w = { x:start.x, y:rawY };
        w = snapToNodes(w);
      }else{
        w = snapPoint(w, start);
      }
      if(editing.end==='a') s.a=w; else s.b=w;
      draw();
    }

    // –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∏
    if(mode==='edit' && editing && editing.type==='label'){
      const w=screenToWorld(cur.x,cur.y);
      const lbl=labels[editing.labelIndex];
      lbl.x=w.x; lbl.y=w.y;
      draw();
    }

    if(mode==='line' && firstPt){
      let w=screenToWorld(cur.x,cur.y);
      previewPt=snapPoint(w, firstPt); draw();
    }
  }, {passive:true});

  function endPointers(e){
    pointers.delete(e.pointerId);
    last1=(pointers.size===1)?[...pointers.values()][0]:null;
  }

  cv.addEventListener('pointerup', e=>{
    const now = performance.now();
    const isDoubleTap = (now - lastTapTime) < 300;
    lastTapTime = now;

    endPointers(e);
    clearTimeout(holdTimer);

    const sx=e.clientX*DPR, sy=e.clientY*DPR;
    const wasTap = downInfo && e.pointerId===downInfo.id && !downInfo.moved && !downInfo.multi;
    const raw = screenToWorld(sx,sy);

    // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –º–∞—Å–∫–∏
    if(mode==='mask' && mask.drawing){
      mask.drawing=false; draw(); // —É–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–æ
      downInfo=null; return;
    }

    // –¥–∞–±–ª-—Ç–∞–ø: —Å–∫—Ä—ã—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å HUD –∏ –º–∏–Ω–∏-–±–∞—Ä
    if(wasTap && isDoubleTap){
      const hide = !hudEl.classList.contains('hidden');
      hudEl.classList.toggle('hidden', hide);
      miniEl.classList.toggle('hidden', !hide);
      downInfo=null; return;
    }

    // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∫–∏ –ª–∏–Ω–∏–∏
    if(mode==='edit' && editing && editing.type==='seg'){
      const s=segs[editing.segIndex];
      const start = (editing.end==='a')? s.b : s.a;
      const endPt = (editing.end==='a')? s.a : s.b;
      const fixed = autoCorrectPoint(start, endPt);
      if(editing.end==='a') s.a=fixed; else s.b=fixed;
      mode='idle'; editing=null; draw();
      downInfo=null; return;
    }

    // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∏
    if(mode==='edit' && editing && editing.type==='label'){
      mode='idle'; editing=null; draw();
      downInfo=null; return;
    }

    // –ª–∞—Å—Ç–∏–∫ ‚Äî —á–∞—Å—Ç–∏—á–Ω–æ
    if(wasTap && mode==='erase'){
      if(!eraseAtScreenPointPartial(sx,sy)) toast('–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –ø–æ–¥ –ª–∞—Å—Ç–∏–∫–æ–º');
      downInfo=null; return;
    }

    // —Ç–µ–∫—Å—Ç ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–∞–ª–∫—É –≤–≤–æ–¥–∞ (–≤–º–µ—Å—Ç–æ prompt, –Ω–µ –ª–æ–º–∞–µ—Ç —Ñ—É–ª–ª—Å–∫—Ä–∏–Ω)
    if(wasTap && mode==='textPlace'){
      openTextModal(raw.x, raw.y);
      downInfo=null; return;
    }

    // –ª–∏–Ω–∏—è ‚Äî –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—á–µ–∫
    if(wasTap && mode==='line'){
      if(!firstPt){ firstPt = snap.on ? snapToNodes(raw) : raw; previewPt=null; toast('–ü–æ—Å—Ç–∞–≤—å 2-—é —Ç–æ—á–∫—É'); draw(); }
      else{ const corrected = autoCorrectPoint(firstPt, raw); segs.push({a:firstPt,b:corrected}); firstPt=null; previewPt=null; mode='idle'; draw(); }
    }

    downInfo=null;
  }, {passive:true});
  cv.addEventListener('pointercancel', e=>{ endPointers(e); clearTimeout(holdTimer); downInfo=null; }, {passive:true});

  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    if(!photo.img) return;
    const sx=e.clientX*DPR, sy=e.clientY*DPR, f=e.deltaY<0?1.12:0.9;
    const dx=sx-photo.cx, dy=sy-photo.cy;
    photo.cx += dx-dx*f; photo.cy += dy-dy*f;
    photo.s = Math.max(0.02*DPR, Math.min(photo.s*f, 50*DPR));
    draw();
  }, {passive:false});

  // ===== –ö–Ω–æ–ø–∫–∏ (–ø–æ–ª–Ω—ã–π HUD) =====
  $('btnCamera').onclick=()=>$('fileCamera').click();
  $('btnGallery').onclick=()=>$('fileGallery').click();
  $('fileCamera').onchange = e=> loadFromFile(e.target.files?.[0]);
  $('fileGallery').onchange= e=> loadFromFile(e.target.files?.[0]);

  $('btnLine').onclick = ()=>{ closePanel(); mode='line'; firstPt=null; previewPt=null; toast('–õ–∏–Ω–∏—è: 1-–π —Ç–∞–ø ‚Üí 2-–π —Ç–∞–ø'); };
  $('btnText').onclick = ()=>{ closePanel(); mode='textPlace'; toast('–¢–∞–ø–Ω–∏ –Ω–∞ —Ö–æ–ª—Å—Ç ‚Äî –ø–æ—è–≤–∏—Ç—Å—è –æ–∫–Ω–æ –≤–≤–æ–¥–∞'); };
  $('btnEraser').onclick = ()=>{ closePanel(); mode='erase'; firstPt=null; previewPt=null; toast('–õ–∞—Å—Ç–∏–∫: —Ç–∞–ø –ø–æ –ª–∏–Ω–∏–∏ ‚Äî –≤—ã—Ä–µ–∑–∞–µ—Ç —á–∞—Å—Ç—å'); };
  $('btnMask').onclick   = ()=>{ closePanel(); mode='mask'; toast('–ú–∞—Å–∫–∞: –ø—Ä–æ–≤–µ–¥–∏ –ø–æ –æ–±—ä–µ–∫—Ç–∞–º –Ω–∞ —Ñ–æ—Ç–æ ‚Äî –ª–∏–Ω–∏–∏ –±—É–¥—É—Ç –∑–∞ –Ω–∏–º–∏'); };

  $('btnUndo').onclick = ()=>{ closePanel();
    if(firstPt && mode==='line'){ firstPt=null; previewPt=null; mode='idle'; }
    else if(mask.strokes.length && mode==='mask'){ mask.strokes.pop(); }
    else if(segs.length){ segs.pop(); }
    else if(labels.length){ labels.pop(); }
    draw();
  };
  $('btnClear').onclick= ()=>{ closePanel(); segs.length=0; labels.length=0; mask.strokes.length=0; firstPt=null; previewPt=null; mode='idle'; draw(); };
  $('btnExport').onclick= ()=>{ closePanel(); const url=cv.toDataURL('image/png',0.95); const a=document.createElement('a'); a.href=url; a.download='IsoPipe.png'; a.click(); };

  // –ú–∞—Å—Ç–µ—Ä-—Ç—É–º–±–ª–µ—Ä ¬´–ú–∞–≥–Ω–∏—Ç¬ª
  const btnSnap=$('btnSnap');
  function refreshSnapButton(){ btnSnap.textContent = snap.on ? 'üß≤ –ú–∞–≥–Ω–∏—Ç: –í–∫–ª' : 'üß≤ –ú–∞–≥–Ω–∏—Ç: –í—ã–∫–ª'; }
  btnSnap.onclick=()=>{ snap.on=!snap.on; refreshSnapButton(); };
  refreshSnapButton();

  // –ú–∏–Ω–∏-HUD
  $('miniLine').onclick = ()=>{ mode='line'; firstPt=null; previewPt=null; toast('–õ–∏–Ω–∏—è'); };
  $('miniEraser').onclick = ()=>{ mode='erase'; firstPt=null; previewPt=null; toast('–õ–∞—Å—Ç–∏–∫ (—á–∞—Å—Ç—å)'); };

  // –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫
  const wrap=$('panelWrap'), backdrop=$('panelBackdrop');
  $('btnSettings').onclick=()=>{ wrap.classList.toggle('open'); wrap.setAttribute('aria-hidden', wrap.classList.contains('open')?'false':'true'); };
  $('panelClose').onclick=()=>closePanel();
  backdrop.onclick=()=>closePanel();
  addEventListener('keydown',e=>{ if(e.key==='Escape') closePanel(); });
  function closePanel(){ wrap.classList.remove('open'); wrap.setAttribute('aria-hidden','true'); }

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
  $('lineWidth').oninput=e=>{ lineWidthPx=+e.value|0; $('lineWidthVal').textContent=e.value; draw(); };
  $('gridAlpha').oninput=e=>{ grid.alpha=+e.value/100; $('gridAlphaVal').textContent=e.value+'%'; draw(); };
  $('gridStep').oninput =e=>{ grid.step =+e.value|0; $('gridStepVal').textContent=e.value; draw(); };
  $('gridAngle').oninput=e=>{ grid.angleDeg=(+e.value|0); $('gridAngleVal').textContent=e.value; draw(); };
  $('snapOn').onchange =e=>{ snap.on = e.target.checked; refreshSnapButton(); };
  $('snapRadius').oninput=e=>{ snap.radiusPx=+e.value|0; $('snapRadiusVal').textContent=e.value; };
  $('isoSnapOn').onchange=e=>{ snap.isoOn = e.target.checked; };
  $('isoTol').oninput =e=>{ snap.isoTolDeg=+e.value|0; $('isoTolVal').textContent=e.value; };

  $('maskSize').oninput = e=>{ mask.brushPx=+e.value|0; $('maskSizeVal').textContent=e.value; if(mode==='mask') draw(); };

  // ===== –ú–æ–¥–∞–ª–∫–∞ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ (–±–µ–∑ prompt) =====
  let pendingTextPos=null;
  function openTextModal(x,y){
    pendingTextPos={x,y};
    textInput.value='';
    textModal.classList.add('show');
    textModal.setAttribute('aria-hidden','false');
    setTimeout(()=>textInput.focus(), 0);
  }
  function closeTextModal(){
    textModal.classList.remove('show');
    textModal.setAttribute('aria-hidden','true');
    pendingTextPos=null;
  }
  $('textCancel').onclick = ()=> closeTextModal();
  $('textOk').onclick = ()=>{
    const val=textInput.value.trim();
    if(val && pendingTextPos){ labels.push({x:pendingTextPos.x,y:pendingTextPos.y,text:val}); draw(); }
    closeTextModal();
    mode='idle';
  };
  textModal.querySelector('.bg').onclick = ()=> closeTextModal();

  // ===== –°—Ç–∞—Ä—Ç =====
  fit();
  toast('–î–∞–±–ª-—Ç–∞–ø: —Å–∫—Ä—ã—Ç—å HUD ‚Üí –æ—Å—Ç–∞—é—Ç—Å—è –õ–∏–Ω–∏—è/–õ–∞—Å—Ç–∏–∫. ¬´–ú–∞—Å–∫–∞¬ª –ø—Ä—è—á–µ—Ç –ª–∏–Ω–∏–∏ –∑–∞ –æ–±—ä–µ–∫—Ç–∞–º–∏. –¢–µ–∫—Å—Ç ‚Äî —á–µ—Ä–µ–∑ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ –æ–∫–Ω–æ.');
})();
</script>
</body>
</html>