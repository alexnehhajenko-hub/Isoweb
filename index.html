<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Трассировка труб — мобильный холст</title>
<style>
  :root{
    --brand:#7c3aed;          /* фиолетовые кнопки */
    --brand-press:#6d28d9;
    --fg:#111;
    --bg:#f4f5f8;
    --panel:#fff;
    --accent:#3b82f6;         /* цвет труб */
    --grid:#cbd5e133;
    --frame:#e5e7eb;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:500 16px/1.2 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Arial;}
  /* фиксированная верхняя панель */
  .toolbar{
    position:fixed; left:0; right:0; top:0; z-index:10;
    display:flex; gap:10px; justify-content:center; align-items:center;
    padding:10px 8px; background:var(--bg);
  }
  .btn{
    appearance:none; border:0; border-radius:10px; padding:10px 14px;
    background:var(--brand); color:#fff; font-weight:700; letter-spacing:.2px;
    box-shadow:0 2px 8px #00000014; white-space:nowrap;
  }
  .btn:active{ background:var(--brand-press); transform:translateY(1px); }
  .btn.secondary{ background:#e5e7eb; color:#1f2937; }
  .btn.small{ padding:8px 10px; font-weight:600; }
  /* холст-рамка 95% экрана */
  .stage-wrap{
    position:fixed; inset:0; top:56px; /* под панель */
    display:grid; place-items:center;
  }
  .stage-frame{
    width:95vw; height: calc(95vh - 56px);
    max-width:95vw; max-height:calc(95vh - 56px);
    background:#fff; border:1px solid var(--frame); border-radius:8px;
    overflow:hidden; touch-action:none; /* блокируем браузерный жест, управляем сами */
  }
  /* слой содержимого, который мы масштабируем/двигаем */
  .content{
    width:100%; height:100%; position:relative;
    transform-origin:0 0; /* важен якорь для матрицы */
    background:#fff;
  }
  canvas{ position:absolute; inset:0; width:100%; height:100%; }
  /* компактная шторка настроек */
  .sheet{
    position:fixed; right:12px; top:56px; z-index:20;
    background:var(--panel); border:1px solid var(--frame); border-radius:12px;
    padding:12px; width:min(86vw,340px); box-shadow:0 10px 30px #00000022; display:none;
  }
  .sheet h3{ margin:0 0 8px; font-size:16px; }
  .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0; }
  .row label{ font-size:14px; color:#374151; }
  .row input[type=range]{ width:56%; }
  .status{ position:fixed; left:10px; bottom:10px; background:#111; color:#fff; padding:8px 10px; border-radius:10px; font-size:13px; opacity:.9;}
</style>
</head>
<body>
  <div class="toolbar">
    <button class="btn" id="lineBtn">Линия</button>
    <button class="btn secondary" id="undoBtn">Назад</button>
    <button class="btn secondary" id="centerBtn">Центр</button>
    <button class="btn secondary" id="saveBtn">Сохранить</button>
    <button class="btn" id="settingsBtn">Настройки</button>
  </div>

  <div class="stage-wrap">
    <div class="stage-frame" id="frame">
      <div class="content" id="content">
        <canvas id="grid"></canvas>
        <canvas id="photo"></canvas>
        <canvas id="draw"></canvas>
      </div>
    </div>
  </div>

  <!-- Шторка настроек -->
  <div class="sheet" id="sheet">
    <h3>Параметры</h3>
    <div class="row">
      <label>Фото</label>
      <input type="file" id="file" accept="image/*" />
    </div>
    <div class="row">
      <label>Ø трубы</label>
      <input type="range" id="pipe" min="6" max="120" value="40" />
    </div>
    <div class="row">
      <label>Толщина линии</label>
      <input type="range" id="thick" min="2" max="16" value="8" />
    </div>
    <div class="row">
      <label>Сетка</label>
      <input type="range" id="gridSize" min="12" max="80" value="40" />
    </div>
    <div class="row">
      <label><input type="checkbox" id="snap" checked /> Магнит 0/45/90</label>
      <label><input type="checkbox" id="iso" checked /> Изометрия (2.5D)</label>
    </div>
  </div>

  <div class="status" id="status">Режим: ожидание</div>

<script>
(()=>{

/* ---------- утилиты ---------- */
const $ = id => document.getElementById(id);
const gridCv = $('grid'), photoCv=$('photo'), drawCv=$('draw');
const gridCx = gridCv.getContext('2d'), photoCx=photoCv.getContext('2d'), drawCx=drawCv.getContext('2d');
const frame = $('frame'), content = $('content');
const state = {
  scale:1, tx:0, ty:0,              // матрица трансформации контента
  minScale:0.5, maxScale:4,         // пределы зума
  lineMode:false,
  points:[],                        // мир-координаты труб
  history:[],
  pipe:40, thick:8, grid:40, snap:true, iso:true,
  photo:null, photoW:0, photoH:0,   // сжатое фото
  startPt:null                      // первая точка линии
};

function setStatus(t){ $('status').textContent = t; }

/* размеры всех canvas = размер контента в CSS-пикселях */
function resizeCanvases(){
  const w = frame.clientWidth, h = frame.clientHeight;
  for (const cv of [gridCv, photoCv, drawCv]) {
    cv.width = w; cv.height = h; cv.style.width = '100%'; cv.style.height = '100%';
  }
  render();
}
window.addEventListener('resize', resizeCanvases);

/* применяем трансформацию к слою .content */
function applyTransform(){
  content.style.transform = `translate(${state.tx}px,${state.ty}px) scale(${state.scale})`;
}

/* преобразование экран->мир (учёт матрицы) */
function toWorld(x, y){
  const rect = frame.getBoundingClientRect();
  const sx = (x - rect.left - state.tx) / state.scale;
  const sy = (y - rect.top  - state.ty) / state.scale;
  return {x:sx, y:sy};
}

/* ---------- сетка ---------- */
function drawGrid(){
  const w = gridCv.width, h = gridCv.height;
  gridCx.clearRect(0,0,w,h);
  // рисуем в экранных координатах, но шаг считаем из масштаба
  const step = Math.max(10, state.grid * state.scale);
  gridCx.strokeStyle = '#64748b22';
  gridCx.lineWidth = 1;
  gridCx.beginPath();
  for(let x=(state.tx%step); x<w; x+=step) { gridCx.moveTo(x,0); gridCx.lineTo(x,h); }
  for(let y=(state.ty%step); y<h; y+=step) { gridCx.moveTo(0,y); gridCx.lineTo(w,y); }
  gridCx.stroke();
}

/* ---------- фото ---------- */
function fitPhoto(){
  photoCx.clearRect(0,0,photoCv.width,photoCv.height);
  if(!state.photo) return;
  // рисуем фото в «мире» (0,0)
  const w = state.photoW, h = state.photoH;
  // масштаб в экран переводится трансформацией слоя, поэтому здесь 1:1
  photoCx.drawImage(state.photo, 0, 0, w, h);
}

/* ---------- трубы ---------- */
function drawPipes(){
  const ctx = drawCx, w=drawCv.width, h=drawCv.height;
  ctx.clearRect(0,0,w,h);
  ctx.lineCap='round'; ctx.lineJoin='round';
  for(const seg of state.points){
    ctx.strokeStyle = 'transparent';
    ctx.fillStyle = 'transparent';
    // сама труба
    ctx.beginPath();
    ctx.strokeStyle = getComputedStyle(document.documentElement)
                      .getPropertyValue('--accent').trim();
    ctx.lineWidth = state.thick;
    ctx.moveTo(seg.a.x, seg.a.y);
    ctx.lineTo(seg.b.x, seg.b.y);
    ctx.stroke();
  }
}

/* общий рендер */
function render(){
  applyTransform();  // трансформацию даёт CSS (GPU)
  drawGrid();
  fitPhoto();
  drawPipes();
}

/* ---------- загрузка фото с авто-сжатием ---------- */
$('file').addEventListener('change', async e=>{
  const f = e.target.files?.[0]; if(!f) return;
  const img = new Image(); img.onload = ()=>{
    const MAX = 2000; // ограничиваем длинную сторону
    const iw = img.naturalWidth, ih = img.naturalHeight;
    let ow=iw, oh=ih;
    if(Math.max(iw,ih)>MAX){
      const k = MAX/Math.max(iw,ih); ow=Math.round(iw*k); oh=Math.round(ih*k);
    }
    // offscreen сжатие
    const off = document.createElement('canvas'); off.width=ow; off.height=oh;
    off.getContext('2d').drawImage(img,0,0,ow,oh);
    const comp = new Image();
    comp.onload = ()=>{
      state.photo = comp; state.photoW=ow; state.photoH=oh;
      setStatus('Фото загружено');
      render();
    };
    comp.src = off.toDataURL('image/jpeg',0.9);
  };
  img.src = URL.createObjectURL(f);
});

/* ---------- пан/зум (двумя пальцами) ---------- */
let pinchDist=0, lastCenter=null, panning=false, lastPan=null, lastTap=0;

function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
function mid(a,b){ return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 }; }

frame.addEventListener('touchstart', (e)=>{
  if(e.touches.length===2){
    pinchDist = dist(e.touches[0], e.touches[1]);
    lastCenter = mid(e.touches[0], e.touches[1]);
  }else if(e.touches.length===1 && !state.lineMode){
    panning=true; lastPan={x:e.touches[0].clientX, y:e.touches[0].clientY};
  }
}, {passive:false});

frame.addEventListener('touchmove', (e)=>{
  if(e.touches.length===2){
    e.preventDefault();
    const d = dist(e.touches[0], e.touches[1]);
    const c = mid(e.touches[0], e.touches[1]);
    const factor = d/pinchDist;
    const newScale = Math.min(state.maxScale, Math.max(state.minScale, state.scale*factor));
    // масштаб относительно центра щипка
    const rect = frame.getBoundingClientRect();
    const cx = c.x - rect.left, cy = c.y - rect.top;
    state.tx = cx - (cx - state.tx)* (newScale/state.scale);
    state.ty = cy - (cy - state.ty)* (newScale/state.scale);
    state.scale = newScale;
    pinchDist = d; lastCenter = c;
    render();
  }else if(panning && e.touches.length===1){
    e.preventDefault();
    const t = e.touches[0];
    state.tx += (t.clientX - lastPan.x);
    state.ty += (t.clientY - lastPan.y);
    lastPan = {x:t.clientX, y:t.clientY};
    render();
  }
},{passive:false});

frame.addEventListener('touchend', ()=>{
  pinchDist=0; panning=false; lastPan=null;
}, {passive:true});

/* двойной тап — отключаем браузерное приближение */
frame.addEventListener('click', (e)=>{
  const now = performance.now();
  if(now-lastTap<250){ e.preventDefault(); } // игнор
  lastTap=now;
}, {passive:false});

/* ---------- рисование в 3 шага ---------- */
$('lineBtn').addEventListener('click', ()=>{
  state.lineMode = true; state.startPt=null;
  setStatus('Режим: линия. Ткни первую точку.');
});

frame.addEventListener('pointerdown', (e)=>{
  if(!state.lineMode) return;
  const w = toWorld(e.clientX, e.clientY);
  if(state.snap){ // магнит к 0/45/90 при продолжении
    // если уже есть старт — подправим угол
    if(state.startPt){
      const dx=w.x-state.startPt.x, dy=w.y-state.startPt.y, ang=Math.atan2(dy,dx);
      const snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI, -Math.PI/4,-Math.PI/2,-3*Math.PI/4];
      let best=ang, dmin=1e9;
      for(const s of snaps){ const d=Math.abs(ang-s); if(d<dmin){dmin=d; best=s;} }
      const len = Math.hypot(dx,dy);
      w.x = state.startPt.x + Math.cos(best)*len;
      w.y = state.startPt.y + Math.sin(best)*len;
    }
  }
  if(!state.startPt){
    state.startPt = w;
    setStatus('Точка 1 поставлена. Ткни точку 2.');
  }else{
    // добавляем сегмент
    state.points.push({a:{...state.startPt}, b:{...w}});
    state.history.push('add');
    state.startPt = null; state.lineMode=false; // завершаем, как просил
    setStatus('Линия готова. Для новой — «Линия».');
    render();
  }
});

$('undoBtn').addEventListener('click', ()=>{
  if(state.points.length){ state.points.pop(); render(); }
});

$('centerBtn').addEventListener('click', ()=>{
  state.scale=1; state.tx=10; state.ty=10; render();
  setStatus('Холст по центру');
});

$('saveBtn').addEventListener('click', ()=>{
  // собираем итог в временный canvas с текущим масштабом 1:1
  const w=drawCv.width, h=drawCv.height;
  const out=document.createElement('canvas'); out.width=w; out.height=h;
  const ctx=out.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
  // всё нарисовано уже в «мир»-координатах 1:1
  if(state.photo) ctx.drawImage(photoCv,0,0);
  ctx.drawImage(drawCv,0,0);
  const url=out.toDataURL('image/png');
  const a=document.createElement('a'); a.href=url; a.download='pipes.png'; a.click();
});

$('settingsBtn').addEventListener('click', ()=>{
  const sh = $('sheet'); sh.style.display = (sh.style.display==='block'?'none':'block');
});

$('pipe').addEventListener('input', e=>{ state.pipe = +e.target.value; });
$('thick').addEventListener('input', e=>{ state.thick = +e.target.value; render(); });
$('gridSize').addEventListener('input', e=>{ state.grid = +e.target.value; render(); });
$('snap').addEventListener('change', e=>{ state.snap = e.target.checked; });
$('iso').addEventListener('change', e=>{ state.iso = e.target.checked; /* зарезервировано */ });

/* запуск */
resizeCanvases();
state.tx=10; state.ty=10; render();
setStatus('Режим: ожидание');
})();
</script>
</body>
</html>