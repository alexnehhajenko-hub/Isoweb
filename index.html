<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Трассировка труб — линии + правка + арматура</title>
<style>
  :root{--ui:#6c4dfc;--txt:#fff}
  html,body{height:100%;margin:0;background:#0f1116;color:#e9e9f0;font-family:system-ui,-apple-system,Inter,Roboto,Arial}
  .toolbar{position:fixed;left:12px;right:12px;top:10px;display:flex;gap:10px;justify-content:center;z-index:5;flex-wrap:wrap}
  .btn{background:#2b2f3a;color:var(--txt);border:0;border-radius:14px;padding:8px 14px;font-weight:600}
  .btn.active{background:var(--ui);box-shadow:0 6px 18px rgba(108,77,252,.25)}
  .wrap{position:fixed;inset:64px 10px 10px 10px;display:grid;place-items:center}
  .stage{width:95vw;height:calc(95vh - 64px);border:1px solid rgba(255,255,255,.15);border-radius:10px;position:relative;background:#0f1116;overflow:hidden;touch-action:none}
  canvas{position:absolute;inset:0;width:100%;height:100%}
  .toast{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.6);color:#cfe9cd;padding:8px 12px;border-radius:10px;font-size:14px}
  dialog{border:0;border-radius:14px;background:#1b1e27;color:#fff;width:min(92vw,420px)}
  .dlg-head{padding:14px 16px;font-weight:700}
  .dlg-body{padding:0 16px 16px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:10px 0}
  .dlg-actions{display:flex;gap:10px;justify-content:flex-end;padding:12px 16px 16px}
  input[type="range"]{width:180px}
  label.switch{display:flex;align-items:center;gap:12px}
  .editbar{
    position:fixed; left:50%; top:56px; transform:translateX(-50%);
    display:none; gap:8px; z-index:6;
    background:#1b1e27; padding:6px; border-radius:12px; border:1px solid rgba(255,255,255,.15);
  }
  .editbar .mini{padding:8px 10px; border-radius:10px; background:#2b2f3a; color:#fff; border:0; font-weight:700}
  .editbar .mini:active{transform:translateY(1px)}
  .toolbar,.btn{touch-action:manipulation;-webkit-tap-highlight-color:transparent}
</style>
</head>
<body>
  <div class="toolbar">
    <button id="lineBtn" class="btn">Линия</button>
    <button id="valveBtn" class="btn">Кран</button>
    <button id="checkBtn" class="btn">Клапан</button>
    <button id="pumpBtn"  class="btn">Насос</button>
    <button id="undoBtn" class="btn">Назад</button>
    <button id="panBtn"  class="btn active">Перемещение</button>
    <button id="centerBtn" class="btn">Центр</button>
    <button id="zoomOutBtn" class="btn">–</button>
    <button id="zoomInBtn"  class="btn">+</button>
    <button id="saveBtn"   class="btn">Сохранить</button>
    <button id="settingsBtn" class="btn">Настройки</button>
  </div>

  <div id="editBar" class="editbar">
    <button id="alignH" class="mini">H</button>
    <button id="alignV" class="mini">V</button>
    <button id="editDone" class="mini">Готово</button>
  </div>

  <div class="wrap">
    <div id="stage" class="stage"><canvas id="cv"></canvas></div>
  </div>

  <div id="toast" class="toast">Режим: перемещение</div>

  <dialog id="dlg">
    <div class="dlg-head">Параметры</div>
    <div class="dlg-body">
      <div class="row"><label>Ø (мм)</label><input id="diam" type="range" min="10" max="300" step="2" value="60"><span id="diamV">60</span></div>
      <div class="row"><label>Сетка</label><input id="grid" type="range" min="24" max="80" step="1" value="40"><span id="gridV">40</span></div>
      <div class="row"><label class="switch"><input id="magnet" type="checkbox" checked> Магнит (привязка к концам линии)</label></div>
      <div class="row"><label>Масштаб толщины</label><input id="thickAlpha" type="range" min="0" max="100" value="65"><span id="thickAlphaV">65%</span></div>
      <div class="row" style="align-items:flex-start"><label>Фото (фон)</label><input id="bg" type="file" accept="image/*"></div>
    </div>
    <div class="dlg-actions"><button id="dlgClose" class="btn">Закрыть</button></div>
  </dialog>

<script>
(()=>{
// ---------- DOM ----------
const stage = document.getElementById('stage');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const toast = document.getElementById('toast');

const lineBtn = document.getElementById('lineBtn');
const valveBtn= document.getElementById('valveBtn');
const checkBtn= document.getElementById('checkBtn');
const pumpBtn = document.getElementById('pumpBtn');
const panBtn  = document.getElementById('panBtn');
const undoBtn = document.getElementById('undoBtn');
const centerBtn = document.getElementById('centerBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const zoomInBtn  = document.getElementById('zoomInBtn');
const saveBtn = document.getElementById('saveBtn');
const settingsBtn = document.getElementById('settingsBtn');

const dlg = document.getElementById('dlg');
const diam = document.getElementById('diam'); const diamV = document.getElementById('diamV');
const grid = document.getElementById('grid'); const gridV = document.getElementById('gridV');
const magnet = document.getElementById('magnet');
const thickAlpha = document.getElementById('thickAlpha'); const thickAlphaV = document.getElementById('thickAlphaV');
const bg = document.getElementById('bg'); const dlgClose = document.getElementById('dlgClose');

const editBar = document.getElementById('editBar');
const alignH = document.getElementById('alignH');
const alignV = document.getElementById('alignV');
const editDone = document.getElementById('editDone');

// ---------- Сцена ----------
let scale = 1, minScale=0.05, maxScale=6;
let offX = 0, offY = 0;
let gridStep = 40;
let pipeD = 60;
// «умный» коэффициент масштабирования толщины (0..1)
let thicknessAlpha = 0.65; // 0 = старая модель, 1 = полностью как фото

const pipes = [];
const parts = [];

let mode = 'pan';
let placeKind = null;
let tempA = null;
let hoverW = null;
let snapTarget = null;

let editing = null;
let longPressTimer = null;
let movedForLong = false;

let dpr = window.devicePixelRatio || 1;
let cssW=0, cssH=0;
let bgImg = null;

function fit(){
  const r = cv.getBoundingClientRect();
  cssW = Math.max(1, Math.round(r.width));
  cssH = Math.max(1, Math.round(r.height));
  dpr = window.devicePixelRatio || 1;
  cv.width  = Math.round(cssW * dpr);
  cv.height = Math.round(cssH * dpr);
  redraw();
}
new ResizeObserver(()=>fit()).observe(stage);

function center(){
  offX = 0; offY = 0; scale = 1;
  redraw();
  setToast(mode==='pan'?'Режим: перемещение':mode==='edit'?'Правка конца':'Режим: линия');
}

function worldToScreen(wx, wy){ return {x:(wx - offX) * scale + cssW/2, y:(wy - offY) * scale + cssH/2}; }
function screenToWorld(sx, sy){ return {x:(sx - cssW/2)/scale + offX, y:(sy - cssH/2)/scale + offY}; }

function setToast(t){ toast.textContent = t; }
function showEditBar(show){ editBar.style.display = show ? 'flex' : 'none'; }

function setMode(newMode){
  mode = newMode;
  lineBtn.classList.toggle('active', mode==='pickA' || mode==='pickB');
  panBtn.classList.toggle('active',  mode==='pan');
  valveBtn.classList.toggle('active', mode==='place' && placeKind==='valve');
  checkBtn.classList.toggle('active', mode==='place' && placeKind==='check');
  pumpBtn.classList.toggle('active',  mode==='place' && placeKind==='pump');
  showEditBar(mode==='edit');
  setToast(
    mode==='pan' ? 'Режим: перемещение'
    : mode==='edit'? 'Правка конца (двигай пальцем, либо H/V)'
    : mode==='pickA'? 'Линия: поставь точку 1'
    : mode==='pickB'? 'Линия: поставь точку 2'
    : 'Поставь арматуру на трубу'
  );
}

// ---------- Рендер ----------
function redraw(){
  ctx.setTransform(scale*dpr, 0, 0, scale*dpr, (cssW/2 - offX*scale)*dpr, (cssH/2 - offY*scale)*dpr);
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cv.width,cv.height); ctx.restore();

  if(bgImg){ const w=bgImg.naturalWidth,h=bgImg.naturalHeight; ctx.drawImage(bgImg,-w/2,-h/2); }
  drawGrid();

  for(const s of pipes) drawPipe(s);
  for(const p of parts) drawPart(p);

  if(mode==='pickB' && tempA){
    ctx.save();
    const r1 = 7/scale, r2 = 12/scale;
    ctx.fillStyle = '#00d8ff';
    ctx.beginPath(); ctx.arc(tempA.x,tempA.y,r1,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,216,255,.6)'; ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(tempA.x,tempA.y,r2,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  if(mode==='pickB' && tempA && hoverW){
    ctx.save();
    ctx.setLineDash([10/scale, 10/scale]);
    const wpx = Math.max(2, pipeD/4);
    const k   = Math.pow(scale, thicknessAlpha);     // << ключ
    ctx.lineWidth = (wpx/scale)*k;
    ctx.strokeStyle = '#7cf';
    ctx.beginPath(); ctx.moveTo(tempA.x,tempA.y); ctx.lineTo(hoverW.x,hoverW.y); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
  if(snapTarget){
    const r = 10/scale;
    ctx.save();
    ctx.strokeStyle = '#ffd166';
    ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(snapTarget.x, snapTarget.y, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  if(mode==='edit' && editing){
    const seg = pipes[editing.i];
    const p = editing.end==='a' ? seg.a : seg.b;
    const r = 12/scale;
    ctx.save();
    ctx.strokeStyle = '#ffe08a';
    ctx.lineWidth = 3/scale;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}
function drawGrid(){
  const step = gridStep, extent = 3000;
  ctx.save(); ctx.lineWidth = 1/scale;
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.beginPath();
  for(let x=-extent;x<=extent;x+=step){ ctx.moveTo(x,-extent); ctx.lineTo(x,extent); }
  for(let y=-extent;y<=extent;y+=step){ ctx.moveTo(-extent,y); ctx.lineTo(extent,y); }
  ctx.stroke();
  ctx.strokeStyle='rgba(255,120,120,.35)'; ctx.beginPath(); ctx.moveTo(-extent,0); ctx.lineTo(extent,0); ctx.stroke();
  ctx.strokeStyle='rgba(120,170,255,.35)'; ctx.beginPath(); ctx.moveTo(0,-extent); ctx.lineTo(0,extent); ctx.stroke();
  ctx.restore();
}

/* ===== КЛЮЧЕВАЯ ПРАВКА ТОЛЩИНЫ ТРУБЫ =====
   lineWidth на экране = (база/scale) * scale^alpha
   alpha∈[0..1]: 0 — «почти фиксированная на экране»,
                 1 — полностью как фото */
function drawPipe(s){
  const base = Math.max(2, s.d/4);         // «диаметр-как-раньше» в px
  const k    = Math.pow(scale, thicknessAlpha);
  const wScr = (base/scale) * k;            // итоговая толщина на экране
  const rCap = (wScr/2);                    // радиус заглушек тоже по новой модели

  ctx.save();
  ctx.lineWidth=wScr; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#2f8cff';
  ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();

  ctx.fillStyle='#2f8cff';
  const drawCap=(p)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,rCap/scale,0,Math.PI*2); ctx.fill(); };
  drawCap(s.a); drawCap(s.b);
  ctx.restore();
}

// ---------- Арматура ----------
function drawPart(p){
  ctx.save();
  ctx.translate(p.x,p.y); ctx.rotate(p.ang||0);
  ctx.lineWidth=2/scale; ctx.strokeStyle='#16181f'; ctx.fillStyle='#6a4cf2';

  if(p.kind==='valve'){
    poly([[-20,-28],[20,-10],[20,10],[-20,28]]);
    rect(-10,-38,20,10); rect(-10, 28,20,10);
    ctx.fillStyle='#eee'; circle(0,0,10); ctx.fillStyle='#6a4cf2';
    rect(-34,-3,24,6); label('BALL',16,0);
  } else if(p.kind==='check'){
    rect(-8,-26,16,12); rect(-8,14,16,12);
    circle(0,0,22);
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.moveTo(-6,-4); ctx.lineTo(8,0); ctx.lineTo(-6,4); ctx.closePath(); ctx.fill();
    label('CHECK',18,-10);
  } else if(p.kind==='pump'){
    circle(0,0,32); rect(-18,-42,36,18); rect(-12,28,24,14); label('PUMP',22,-8);
  }
  ctx.restore();
  function rect(x,y,w,h){ ctx.beginPath(); ctx.rect(x,y,w,h); ctx.fill(); ctx.stroke(); }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  function poly(pts){ ctx.beginPath(); pts.forEach(([x,y],i)=>i?ctx.lineTo(x,y):ctx.moveTo(x,y)); ctx.closePath(); ctx.fill(); ctx.stroke(); }
  function label(t,dx,dy){
    ctx.save(); ctx.translate(dx||0,dy||0); ctx.rotate(-p.ang);
    const fs=12/scale; ctx.font=`${fs}px system-ui,Arial`; const pad=6/scale;
    const m=ctx.measureText(t), w=m.width+pad*2, h=18/scale;
    ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=1/scale;
    rr(0,-h/2,w,h,8/scale); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#000'; ctx.textBaseline='middle'; ctx.fillText(t,pad,0);
    ctx.restore();
  }
  function rr(x,y,w,h,r){ ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  }
}
function snapToSegment(w){
  if(pipes.length===0) return {p:w, ang:0, found:false};
  let best=null, bestDist=Infinity, bestAng=0;
  for(const s of pipes){
    const ax=s.a.x, ay=s.a.y, bx=s.b.x, by=s.b.y;
    const ABx=bx-ax, ABy=by-ay, APx=w.x-ax, APy=w.y-ay;
    const ab2=ABx*ABx+ABy*ABy || 1e-6;
    let t=(APx*ABx+APy*ABy)/ab2; t=Math.max(0,Math.min(1,t));
    const px=ax+t*ABx, py=ay+t*ABy;
    const d=Math.hypot(w.x-px,w.y-py);
    if(d<bestDist){bestDist=d; best={x:px,y:py}; bestAng=Math.atan2(by-ay,bx-ax);}
  }
  const thr=20/scale;
  return bestDist<=thr ? {p:best, ang:bestAng, found:true} : {p:w, ang:0, found:false};
}

// ---------- Магнит к концам линий ----------
function applySnapToEndpoint(w){
  snapTarget=null;
  if(!magnet.checked) return w;
  const thr = 18/scale;
  let best=null, bestDist=Infinity;
  for(const seg of pipes){
    for(const p of [seg.a, seg.b]){
      const d = Math.hypot(w.x-p.x, w.y-p.y);
      if(d<bestDist && d<=thr){ best=p; bestDist=d; }
    }
  }
  if(best){ snapTarget=best; return {x:best.x,y:best.y}; }
  return w;
}

// ---------- Жесты ----------
let lastTouches=[]; let fingerPanning=false, prevFinger={x:0,y:0};

stage.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===1){
    const t=ev.touches[0];
    const rect = cv.getBoundingClientRect();
    const sx = t.clientX - rect.left;
    const sy = t.clientY - rect.top;
    const w = screenToWorld(sx, sy);

    const hit = hitEndpoint(w);
    movedForLong = false; clearTimeout(longPressTimer);
    if(hit){ longPressTimer = setTimeout(()=>{ editing=hit; setMode('edit'); redraw(); }, 600); }

    if(mode==='pan'){ fingerPanning=true; prevFinger={x:t.clientX,y:t.clientY}; }
    else if(mode==='pickA' || mode==='pickB' || mode==='place'){ onTap(sx,sy); }
  }else if(ev.touches.length===2){
    fingerPanning=false; clearTimeout(longPressTimer);
    lastTouches = copyTouches(ev.touches);
  }
},{passive:false});

stage.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  if(ev.touches.length===1){
    const t=ev.touches[0];
    const rect=cv.getBoundingClientRect();
    const sx=t.clientX-rect.left, sy=t.clientY-rect.top;

    if(!movedForLong) movedForLong = true, clearTimeout(longPressTimer);

    if(mode==='edit' && editing){
      const w = applySnapToEndpoint(screenToWorld(sx,sy));
      const seg = pipes[editing.i];
      if(editing.end==='a'){ seg.a.x=w.x; seg.a.y=w.y; } else { seg.b.x=w.x; seg.b.y=w.y; }
      redraw();
    }else if(mode==='pan' && fingerPanning){
      const dx=t.clientX-prevFinger.x, dy=t.clientY-prevFinger.y;
      offX -= dx/scale; offY -= dy/scale;
      prevFinger={x:t.clientX,y:t.clientY}; redraw();
    }else if(mode==='pickB' && tempA){
      hoverW = applySnapToEndpoint(screenToWorld(sx,sy)); redraw();
    }
  }else if(ev.touches.length===2){
    clearTimeout(longPressTimer);
    pinchPan(ev.touches);
  }
},{passive:false});

stage.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  clearTimeout(longPressTimer);
  if(ev.touches.length===0) { fingerPanning=false; }
  if(ev.touches.length<2) lastTouches=[];
},{passive:false});

// Мышь
let dragging=false, prev={x:0,y:0};
stage.addEventListener('mousedown', e=>{
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
  const w = screenToWorld(sx, sy);
  const hit = hitEndpoint(w);
  if(hit){ editing = hit; setMode('edit'); redraw(); return; }
  if(mode!=='pan'){ onTap(sx,sy); return; }
  dragging=true; prev={x:e.clientX,y:e.clientY};
});
stage.addEventListener('mousemove', e=>{
  if(mode==='edit' && editing){
    const rect=cv.getBoundingClientRect();
    const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    const w=applySnapToEndpoint(screenToWorld(sx,sy));
    const seg=pipes[editing.i];
    if(editing.end==='a'){ seg.a.x=w.x; seg.a.y=w.y; } else { seg.b.x=w.x; seg.b.y=w.y; }
    redraw(); return;
  }
  if(mode==='pickB' && tempA){ const rect=cv.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; hoverW=applySnapToEndpoint(screenToWorld(sx,sy)); redraw(); return; }
  if(!dragging) return;
  const dx=e.clientX-prev.x, dy=e.clientY-prev.y;
  offX -= dx/scale; offY -= dy/scale;
  prev={x:e.clientX,y:e.clientY}; redraw();
});
stage.addEventListener('mouseup', ()=> dragging=false);
stage.addEventListener('mouseleave', ()=> dragging=false);

stage.addEventListener('wheel', e=>{
  const rect=cv.getBoundingClientRect();
  const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  zoomAt(cx, cy, e.deltaY>0? 0.85:1.15);
  e.preventDefault();
},{passive:false});

// Тап (линия/арматура)
function onTap(sx,sy){
  const wRaw = screenToWorld(sx, sy);
  if(mode==='place'){
    const snap = snapToSegment(wRaw);
    parts.push({kind:placeKind, x:snap.p.x, y:snap.p.y, ang:snap.ang});
    placeKind=null; setMode('pan'); redraw(); return;
  }
  const w = applySnapToEndpoint(wRaw);
  if(mode==='pickA'){ tempA=w; hoverW=null; setMode('pickB'); redraw(); }
  else if(mode==='pickB' && tempA){
    pipes.push({a:{...tempA}, b:w, d:pipeD});
    tempA=null; hoverW=null; snapTarget=null;
    setMode('pan');
    setToast('Линия готова. Чтобы нарисовать новую, нажми «Линия».');
    redraw();
  }
}

function hitEndpoint(w){
  const thr = 14/scale;
  for(let i=0;i<pipes.length;i++){
    const s=pipes[i];
    if(Math.hypot(w.x-s.a.x, w.y-s.a.y)<=thr) return {i, end:'a'};
    if(Math.hypot(w.x-s.b.x, w.y-s.b.y)<=thr) return {i, end:'b'};
  }
  return null;
}

alignH.onclick = ()=>{
  if(!(mode==='edit' && editing)) return;
  const seg = pipes[editing.i];
  const fixed = editing.end==='a'? seg.b : seg.a;
  const mov   = editing.end==='a'? seg.a : seg.b;
  mov.y = fixed.y; snapTarget=null; redraw();
};
alignV.onclick = ()=>{
  if(!(mode==='edit' && editing)) return;
  const seg = pipes[editing.i];
  const fixed = editing.end==='a'? seg.b : seg.a;
  const mov   = editing.end==='a'? seg.a : seg.b;
  mov.x = fixed.x; snapTarget=null; redraw();
};
editDone.onclick = ()=>{ editing=null; setMode('pan'); redraw(); };

// пинч-зум/перемещение
function copyTouches(ts){ return [...ts].map(t=>({x:t.clientX,y:t.clientY})); }
function pinchPan(ts){
  const now = copyTouches(ts); if(now.length<2||lastTouches.length<2) return;
  const pd = Math.hypot(lastTouches[0].x-lastTouches[1].x, lastTouches[0].y-lastTouches[1].y);
  const cd = Math.hypot(now[0].x-now[1].x, now[0].y-now[1].y);
  const rect=cv.getBoundingClientRect();
  const pcx=(lastTouches[0].x+lastTouches[1].x)/2 - rect.left;
  const pcy=(lastTouches[0].y+lastTouches[1].y)/2 - rect.top;
  const ncx=(now[0].x+now[1].x)/2 - rect.left;
  const ncy=(now[0].y+now[1].y)/2 - rect.top;

  zoomAt(ncx, ncy, Math.pow(cd/pd, 1));
  offX -= (ncx-pcx)/scale;
  offY -= (ncy-pcy)/scale;

  lastTouches = now; redraw();
}
function zoomAt(sx,sy,zoom){
  const before = screenToWorld(sx,sy);
  scale = Math.min(maxScale, Math.max(minScale, scale*zoom));
  const after = screenToWorld(sx,sy);
  offX += before.x - after.x;
  offY += before.y - after.y;
  showEditBar(mode==='edit');
}

// Кнопки
lineBtn.onclick = ()=>{ placeKind=null; tempA=null; hoverW=null; editing=null; setMode('pickA'); };
valveBtn.onclick= ()=>{ placeKind='valve'; setMode('place'); };
checkBtn.onclick= ()=>{ placeKind='check'; setMode('place'); };
pumpBtn.onclick = ()=>{ placeKind='pump';  setMode('place'); };
panBtn.onclick  = ()=>{ tempA=null; hoverW=null; editing=null; setMode('pan'); };
undoBtn.onclick = ()=>{ if(parts.length) parts.pop(); else if(pipes.length) pipes.pop(); redraw(); };
centerBtn.onclick = center;
saveBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=cv.toDataURL('image/png'); a.download='pipes.png'; a.click(); };
settingsBtn.onclick = ()=> dlg.showModal();
dlgClose.onclick = ()=> dlg.close();

diam.oninput = ()=>{ pipeD=+diam.value; diamV.textContent=pipeD; redraw(); };
grid.oninput = ()=>{ gridStep=+grid.value; gridV.textContent=gridStep; redraw(); };
thickAlpha.oninput = ()=>{ thicknessAlpha = (+thickAlpha.value)/100; thickAlphaV.textContent = thickAlpha.value+'%'; redraw(); };
bg.onchange = e=>{ const f=e.target.files?.[0]; if(!f) return; const img=new Image(); img.onload=()=>{ bgImg=img; redraw(); }; img.src=URL.createObjectURL(f); };

// –/+ удержание
let holdTimer=null, holdRAF=null;
function startHold(fn){ stopHold(); fn(); holdTimer=setTimeout(function loop(){ fn(); holdRAF=requestAnimationFrame(loop); }, 140); }
function stopHold(){ clearTimeout(holdTimer); cancelAnimationFrame(holdRAF); holdTimer=null; holdRAF=null; }
zoomOutBtn.addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomBtn(-1));},{passive:false});
zoomOutBtn.addEventListener('mousedown',   ()=>startHold(()=>zoomBtn(-1)));
zoomInBtn .addEventListener('touchstart', e=>{e.preventDefault(); startHold(()=>zoomBtn(+1));},{passive:false});
zoomInBtn .addEventListener('mousedown',   ()=>startHold(()=>zoomBtn(+1)));
['mouseleave','mouseup','touchend','touchcancel'].forEach(ev=>{
  zoomOutBtn.addEventListener(ev, stopHold); zoomInBtn.addEventListener(ev, stopHold);
});
function zoomBtn(dir){ const r=cv.getBoundingClientRect(); zoomAt(r.width/2, r.height/2, dir>0?1.15:0.85); redraw(); }

// блок двойного тапа по панели
const toolbar=document.querySelector('.toolbar'); let lastTouchEnd=0;
toolbar.addEventListener('touchend',(e)=>{const now=Date.now(); if(now-lastTouchEnd<=300) e.preventDefault(); lastTouchEnd=now;},{passive:false});
toolbar.addEventListener('dblclick',e=>e.preventDefault(),{passive:false});

// init
fit(); center();
})();
</script>
</body>
</html>