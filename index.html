<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>IsoPipe — SafeBoot</title>
<style>
  :root{--violet:#7b2cff;--violet2:#6523ff}
  html,body{margin:0;height:100%;background:#f5f6fb;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{display:block;width:100vw;height:100vh;background:#fff;touch-action:none}
  .bar{position:fixed;left:8px;right:8px;top:8px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .bar button{height:40px;border:0;border-radius:12px;padding:0 12px;color:#fff;font-weight:700;background:linear-gradient(180deg,var(--violet2),var(--violet))}
  .bar button.ghost{background:#fff;color:#5b30c2;border:1px solid #d8c9ff}
  .pill{background:#fff;border:1px solid #e7e3f7;border-radius:12px;height:40px;display:flex;align-items:center;gap:8px;padding:0 10px}
  .pill input[type="checkbox"]{width:18px;height:18px}
  .toast{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:8px 12px;border-radius:10px;opacity:0;transition:.2s;z-index:20}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <div class="bar">
    <button data-act="line">Линия</button>
    <button data-act="valve">Вентиль</button>
    <button data-act="undo">Назад</button>
    <button data-act="clear">Очистить</button>
    <button data-act="fit">Fit</button>
    <button class="ghost" data-act="grid">Сетка</button>
    <label class="pill"><input id="snap" type="checkbox" checked> Snap</label>
  </div>
  <canvas id="cv"></canvas>
  <div id="toast" class="toast"></div>

<script>
(function(){
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d',{alpha:false});
  const DPR=Math.max(1, Math.min(window.devicePixelRatio||1, 2));
  const toastEl=document.getElementById('toast');
  const show=(t,ms=900)=>{toastEl.textContent=t;toastEl.classList.add('show');setTimeout(()=>toastEl.classList.remove('show'),ms);};

  const st={
    mode:'idle', first:null, preview:null,
    segs:[], valves:[],
    s:1*DPR, targetS:1*DPR, cx:0, cy:0, anim:false,
    grid:true, snap:true
  };

  function resize(){
    cv.width=Math.round(innerWidth*DPR);
    cv.height=Math.round(innerHeight*DPR);
    if(st.cx===0 && st.cy===0){ st.cx=cv.width/2; st.cy=cv.height/2; }
    draw();
  }
  addEventListener('resize', resize, {passive:true}); resize();

  const w2s=p=>({x:st.cx+p.x*st.s,y:st.cy+p.y*st.s});
  const s2w=(sx,sy)=>({x:(sx-st.cx)/st.s,y:(sy-st.cy)/st.s});

  function drawGrid(){
    if(!st.grid) return;
    const step=200, angles=[30,90,150];
    ctx.save();
    for(const ang of angles){
      const r=ang*Math.PI/180, vx=Math.cos(r), vy=Math.sin(r), px=-vy, py=vx;
      const stepScr=step*st.s, need=Math.ceil(Math.max(cv.width,cv.height)/stepScr)+2;
      for(let k=-need;k<=need;k++){
        const bx=px*k*step, by=py*k*step;
        const A=w2s({x:bx-vx*9999,y:by-vy*9999}), B=w2s({x:bx+vx*9999,y:by+vy*9999});
        const major=k%3===0;
        ctx.strokeStyle=major?'#b7bcc8':'#dcdfe6';
        ctx.lineWidth=major?1.4:1.0;
        ctx.globalAlpha=major?.9:.7;
        ctx.beginPath();ctx.moveTo(A.x,A.y);ctx.lineTo(B.x,B.y);ctx.stroke();
      }
    }
    ctx.restore(); ctx.globalAlpha=1;
  }

  // snap
  const ANGLES=[0,30,60,90,120,150];
  const norm=a=>((a%360)+360)%360;
  const ad=(a,b)=>{let d=Math.abs(a-b)%360; return d>180?360-d:d;};
  const nodes=()=>{const out=[]; st.segs.forEach(s=>out.push(s.a,s.b)); st.valves.forEach(v=>out.push(v.a,v.b)); return out;};
  function snapNode(p){
    if(!st.snap) return p;
    const sx=st.cx+p.x*st.s, sy=st.cy+p.y*st.s, R=20*DPR;
    let best=null, bestD=Infinity;
    for(const n of nodes()){
      const ns=w2s(n), d=Math.hypot(ns.x-sx, ns.y-sy);
      if(d<bestD && d<=R){ best=n; bestD=d; }
    }
    return best? {x:best.x,y:best.y} : p;
  }
  function snapAngle(a,b,tol=10){
    if(!st.snap||!a) return b;
    const v={x:b.x-a.x, y:b.y-a.y}, L=Math.hypot(v.x,v.y); if(L===0) return b;
    const ang=norm(Math.atan2(v.y,v.x)*180/Math.PI);
    let best=ang, bd=181;
    for(const t of ANGLES.concat(ANGLES.map(x=>x+180))){
      const d=ad(ang, norm(t)); if(d<bd){bd=d; best=t;}
    }
    if(bd>tol) return b;
    const r=best*Math.PI/180; return {x:a.x+Math.cos(r)*L, y:a.y+Math.sin(r)*L};
  }
  const snapPoint=(start, raw)=> snapAngle(start, snapNode(raw));

  function drawValveScreen(Aw,Bw){
    const A=w2s(Aw), B=w2s(Bw);
    ctx.save();
    // труба (экранная толщина — стабильная)
    ctx.lineCap='round'; ctx.strokeStyle='#7b2cff'; ctx.lineWidth=6*DPR;
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

    const ang=Math.atan2(B.y-A.y,B.x-A.x);
    const mid={x:(A.x+B.x)/2,y:(A.y+B.y)/2};
    ctx.translate(mid.x,mid.y); ctx.rotate(ang);

    // «бабочка»
    const w=16*DPR, h=11*DPR;
    ctx.fillStyle='#7b2cff'; ctx.strokeStyle='#4a21a8'; ctx.lineWidth=1.6*DPR;
    ctx.beginPath();
    ctx.moveTo(-w*0.5,0); ctx.lineTo(0,-h*0.68); ctx.lineTo(w*0.5,0); ctx.lineTo(0,h*0.68);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    // внутр. белая окантовка
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1*DPR;
    ctx.beginPath(); ctx.moveTo(-w*0.44,0); ctx.lineTo(0,-h*0.58); ctx.lineTo(w*0.44,0); ctx.lineTo(0,h*0.58); ctx.closePath(); ctx.stroke();
    // ручка
    ctx.strokeStyle='#111'; ctx.lineWidth=2*DPR;
    ctx.beginPath(); ctx.moveTo(0,-h*0.95); ctx.lineTo(0,-h*1.9); ctx.stroke();

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);
    drawGrid();

    // трубы (в мировых, толщина масштабируется)
    ctx.save(); ctx.translate(st.cx,st.cy); ctx.scale(st.s,st.s);
    for(const s of st.segs){
      ctx.lineCap='round'; ctx.strokeStyle='#7b2cff'; ctx.lineWidth=(6*DPR)/st.s;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
      ctx.strokeStyle='rgba(75,32,168,.35)'; ctx.lineWidth=(1.2*DPR)/st.s;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    }
    ctx.restore();

    // вентили (в экранных — толщина стабильная)
    for(const v of st.valves){ drawValveScreen(v.a,v.b); }

    // предпросмотр
    if(st.first){
      const A=w2s(st.first);
      ctx.fillStyle='#16a34a'; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(A.x,A.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
      if(st.preview){
        const B=w2s(st.preview);
        ctx.setLineDash([8,8]); ctx.strokeStyle='#16a34a'; ctx.lineWidth=3;
        ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(B.x,B.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
      }
    }
  }

  // плавный зум к целевому масштабу
  function animTick(){
    const k=0.22;
    const ds=st.targetS - st.s;
    if(Math.abs(ds)>1e-3){ st.s += ds*k; draw(); requestAnimationFrame(animTick); }
    else { st.s=st.targetS; st.anim=false; draw(); }
  }
  function requestAnim(){ if(st.anim) return; st.anim=true; requestAnimationFrame(animTick); }

  // колесо (мелкие шаги)
  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = (e.deltaY<0)? 1.08 : 0.93;
    const sx=e.clientX*DPR, sy=e.clientY*DPR;
    const before=s2w(sx,sy);
    st.targetS = Math.max(0.35*DPR, Math.min(6*DPR, st.s*factor));
    const after={x: sx - before.x*st.targetS, y: sy - before.y*st.targetS};
    st.cx=after.x; st.cy=after.y; requestAnim();
  }, {passive:false});

  // указатели
  const pointers=new Map(); let pinch=null, lastPan=null;
  cv.addEventListener('pointerdown', e=>{
    cv.setPointerCapture?.(e.pointerId);
    const p={x:e.clientX*DPR,y:e.clientY*DPR}; pointers.set(e.pointerId,p);

    if(pointers.size===1){
      const w=s2w(p.x,p.y);
      if(st.mode==='line'){
        if(!st.first){ st.first = st.snap? snapNode(w) : w; st.preview=null; show('2-я точка'); draw(); }
        else{
          const end = st.snap? snapPoint(st.first, w) : w;
          st.segs.push({a:st.first,b:end});
          st.first=null; st.preview=null; st.mode='idle'; draw();
        }
      }else if(st.mode==='valve'){
        if(!st.first){ st.first = st.snap? snapNode(w) : w; st.preview=null; show('Ориентация'); draw(); }
        else{
          // фиксированная экранная длина 64 px (по 32 в обе стороны от центра)
          const dir = st.snap? snapPoint(st.first, w) : w;
          const vx=dir.x-st.first.x, vy=dir.y-st.first.y, L=Math.hypot(vx,vy)||1;
          const ux=vx/L, uy=vy/L, halfWorld=(32*DPR)/st.s;
          const A={x: st.first.x-ux*halfWorld, y: st.first.y-uy*halfWorld};
          const B={x: st.first.x+ux*halfWorld, y: st.first.y+uy*halfWorld};
          st.valves.push({a:A,b:B});
          st.first=null; st.preview=null; st.mode='idle'; draw();
        }
      }else{
        lastPan=p;
      }
    }
    if(pointers.size===2){
      const ids=[...pointers.keys()];
      const a=pointers.get(ids[0]), b=pointers.get(ids[1]);
      pinch={d0:Math.hypot(a.x-b.x,a.y-b.y), c:{x:(a.x+b.x)/2,y:(a.y+b.y)/2}};
    }
  }, {passive:true});

  cv.addEventListener('pointermove', e=>{
    if(!pointers.has(e.pointerId)) return;
    const cur={x:e.clientX*DPR,y:e.clientY*DPR};
    const prev=pointers.get(e.pointerId); pointers.set(e.pointerId,cur);

    if(pointers.size===1){
      if(st.mode==='line' && st.first){
        const w=s2w(cur.x,cur.y); st.preview = st.snap? snapPoint(st.first, w) : w; draw();
      }else if(st.mode==='valve' && st.first){
        const w=s2w(cur.x,cur.y); st.preview = st.snap? snapPoint(st.first, w) : w; draw();
      }else if(lastPan){
        st.cx += cur.x - lastPan.x; st.cy += cur.y - lastPan.y; lastPan=cur; draw();
      }
    }
    if(pointers.size===2 && pinch){
      const ids=[...pointers.keys()];
      const a=pointers.get(ids[0]), b=pointers.get(ids[1]);
      const d=Math.hypot(a.x-b.x,a.y-b.y); if(d>0){
        const factor=d/pinch.d0;
        const sx=pinch.c.x, sy=pinch.c.y, before=s2w(sx,sy);
        st.targetS = Math.max(0.35*DPR, Math.min(6*DPR, st.s*factor));
        const after={x: sx - before.x*st.targetS, y: sy - before.y*st.targetS};
        st.cx=after.x; st.cy=after.y; requestAnim();
      }
    }
  }, {passive:true});

  function endPtr(e){
    pointers.delete(e.pointerId);
    if(pointers.size!==1) lastPan=null;
    if(pointers.size<2) pinch=null;
  }
  cv.addEventListener('pointerup', endPtr, {passive:true});
  cv.addEventListener('pointercancel', endPtr, {passive:true});
  cv.addEventListener('pointerleave', endPtr, {passive:true});

  // тулбар
  document.querySelector('.bar').addEventListener('click', e=>{
    const act=e.target?.dataset?.act; if(!act) return;
    if(act==='line'){  st.mode='line';  st.first=null; st.preview=null; show('Линия: 2 тапа'); }
    if(act==='valve'){ st.mode='valve'; st.first=null; st.preview=null; show('Вентиль: центр → ориентация'); }
    if(act==='undo'){  (st.valves.length?st.valves.pop():st.segs.pop()); draw(); }
    if(act==='clear'){ st.segs.length=0; st.valves.length=0; st.first=null; st.preview=null; draw(); }
    if(act==='fit'){   st.s=st.targetS=1*DPR; st.cx=cv.width/2; st.cy=cv.height/2; draw(); }
    if(act==='grid'){  st.grid=!st.grid; draw(); }
  });

  document.getElementById('snap').onchange=e=>{ st.snap=!!e.target.checked; };
})();
</script>
</body>
</html>