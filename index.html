<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî 3D grid + draw + edit + snaps + comps + save/load + measure</title>
<style>
  :root{--violet:#6b1dff; --violet2:#7c5bff}
  html,body{margin:0;height:100%;background:#1a1a1a;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv3d{position:fixed;inset:0;display:block;width:100vw;height:100vh;background:#1a1a1a;touch-action:none;-webkit-user-select:none;user-select:none}
  .bar{position:fixed;left:8px;top:8px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .btn{height:40px;padding:0 12px;border:0;border-radius:10px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:#2c2c2c;color:#ddd;border:1px solid #3a3a3a}
  .btn.tog.on{outline:3px solid #ffd54d}
  .status{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.70);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;z-index:11;max-width:92vw}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  select, input[type=range]{height:40px;border-radius:10px;border:1px solid #3a3a3a;background:#2b2b2b;color:#eee}
  .range{display:flex;align-items:center;gap:8px;background:#2b2b2b;border:1px solid #3a3a3a;border-radius:10px;padding:0 8px}
  .range span{min-width:38px;text-align:center;color:#ddd}
  .badge{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.5);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;pointer-events:none;display:none}
</style>
</head>
<body>
  <canvas id="cv3d"></canvas>

  <div class="bar">
    <div class="row">
      <button id="btnLine" class="btn">üìê –õ–∏–Ω–∏—è</button>
      <button id="btnUndo" class="btn ghost">‚Ü©</button>
      <button id="btnRuler" class="btn ghost">üìè –õ–∏–Ω–µ–π–∫–∞</button>
      <button id="btnAxisY" class="btn ghost tog">Y‚Üï</button>
    </div>

    <div class="row">
      <button id="btnSnapEnds" class="btn ghost tog on">–°—Ç—ã–∫</button>
      <button id="btnSnapMid"  class="btn ghost tog">–°–µ—Ä–µ–¥–∏–Ω–∞</button>
      <button id="btnSnapGrid" class="btn ghost tog on">–°–µ—Ç–∫–∞</button>
    </div>

    <div class="row">
      <div class="range">
        <label style="color:#bbb">√ò</label>
        <input id="rPipe" type="range" min="0.015" max="0.12" step="0.005" value="0.035" style="width:140px">
        <span id="rPipeVal">35</span>
      </div>
      <select id="matSel">
        <option value="metal" selected>–ú–µ—Ç–∞–ª–ª</option>
        <option value="plastic">–ü–ª–∞—Å—Ç–∏–∫</option>
        <option value="matte">–ú–∞—Ç–æ–≤—ã–π</option>
      </select>
    </div>

    <div class="row">
      <select id="compSel">
        <option value="valve">–ö—Ä–∞–Ω</option>
        <option value="check">–ö–ª–∞–ø–∞–Ω</option>
        <option value="pump">–ù–∞—Å–æ—Å</option>
      </select>
      <button id="btnPlaceComp" class="btn ghost">–ü–æ—Å—Ç–∞–≤–∏—Ç—å</button>
    </div>

    <div class="row">
      <button id="btnSave" class="btn ghost">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      <label class="btn ghost" style="position:relative;overflow:hidden">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å
        <input id="fileLoad" type="file" accept="application/json" style="position:absolute;inset:0;opacity:0">
      </label>
    </div>
  </div>

  <div id="status" class="status">–°—Ç–∞—Ç—É—Å: –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
  <div id="badge" class="badge"></div>

<script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.1/examples/js/controls/OrbitControls.js"></script>
<script>
(()=>{"use strict";

/* ===== —Å—Ç–∞—Ç—É—Å/—É—Ç–∏–ª–∏—Ç—ã ===== */
const statusEl=document.getElementById('status');
const badgeEl=document.getElementById('badge');
const DPR=Math.min(2, Math.max(1, window.devicePixelRatio||1));
const $=id=>document.getElementById(id);
function say(s){ statusEl.textContent=s; }
function mm(v){ return Math.round(v*1000); }          // –º–µ—Ç—Ä—ã ‚Üí –º–º
function fmtLen(m){ return (m>=1)? (m.toFixed(3)+' –º') : (mm(m)+' –º–º'); }

/* ===== THREE ===== */
const cv=$('cv3d');
let renderer, scene, camera, controls, raycaster, mouseNDC;
let ground, grid;

const GRID_STEP=0.2;
const LONG_MS=700;
let wantY=false;
let snapEnds=true, snapMid=false, snapGrid=true;
let pipeRadius=0.035;
let matKind='metal';

const materialByKind=()=>{
  if(matKind==='metal') return new THREE.MeshStandardMaterial({color:0x6b1dff, metalness:0.75, roughness:0.25});
  if(matKind==='plastic') return new THREE.MeshStandardMaterial({color:0x7fc5ff, metalness:0.05, roughness:0.35});
  return new THREE.MeshStandardMaterial({color:0x6b7b8f, metalness:0.0, roughness:0.9});
};

function init(){
  renderer=new THREE.WebGLRenderer({canvas:cv, antialias:true});
  renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
  renderer.setSize(innerWidth, innerHeight, false);

  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x1a1a1a);

  camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 300);
  camera.position.set(3,2.4,3);

  controls=new THREE.OrbitControls(camera, cv);
  controls.enableDamping=true; controls.dampingFactor=0.08;
  controls.target.set(0,0,0);

  scene.add(new THREE.AmbientLight(0xffffff, .9));
  const dir=new THREE.DirectionalLight(0xffffff, .7); dir.position.set(2,3,1); scene.add(dir);

  grid=new THREE.GridHelper(40, 40/GRID_STEP, 0x333333, 0x2f2f2f);
  grid.material.opacity=0.9; grid.material.transparent=true;
  scene.add(grid);

  ground=new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshBasicMaterial({visible:false}));
  ground.rotateX(-Math.PI/2); scene.add(ground);

  raycaster=new THREE.Raycaster();
  mouseNDC=new THREE.Vector2();

  animate();
}
function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }

/* ===== –≥–µ–æ–º–µ—Ç—Ä–∏—è ===== */
const pipes=[]; // {a:V3,b:V3,radius,mesh}
const comps=[]; // {pipeIndex,t,type,group}

/* ===== –º–æ–¥–µ–ª–∏ ===== */
function makePipeMesh(a,b,r,mat){
  const dir=new THREE.Vector3().subVectors(b,a);
  const len=dir.length()||1e-6;
  const geom=new THREE.CylinderGeometry(r,r,len,20);
  const mesh=new THREE.Mesh(geom, mat.clone());
  const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
  mesh.position.copy(mid);
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
  return mesh;
}
function refreshPipe(i){
  const p=pipes[i];
  if(p.mesh){ scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); }
  p.mesh=makePipeMesh(p.a,p.b,p.radius, materialByKind());
  scene.add(p.mesh);
  comps.forEach((c,idx)=>{ if(c.pipeIndex===i) refreshComp(idx); });
}

/* ‚Äî‚Äî‚Äî –∞—Ä–º–∞—Ç—É—Ä–∞ ‚Äî‚Äî‚Äî */
function makeCompModel(type, radius){
  const g=new THREE.Group();
  const col=0x6b1dff, stroke=0x1b1b1b;
  if(type==='valve'){
    const body=new THREE.Mesh(new THREE.CapsuleGeometry(radius*1.6, radius*6.0, 8, 16),
                              new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.3}));
    g.add(body);
    const ball=new THREE.Mesh(new THREE.SphereGeometry(radius*1.3, 16, 12),
                              new THREE.MeshStandardMaterial({color:0xffffff, metalness:.1, roughness:.5}));
    g.add(ball);
    const handle=new THREE.Mesh(new THREE.BoxGeometry(radius*0.6, radius*4.0, radius*0.6),
                                new THREE.MeshStandardMaterial({color:stroke, metalness:.2, roughness:.7}));
    handle.position.y=radius*2.2; handle.rotation.z=Math.PI/2; g.add(handle);
  }else if(type==='check'){
    const body=new THREE.Mesh(new THREE.CapsuleGeometry(radius*1.6, radius*5.0, 8, 16),
                              new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.3}));
    g.add(body);
    const cone=new THREE.Mesh(new THREE.ConeGeometry(radius*1.2, radius*2.0, 16),
                              new THREE.MeshStandardMaterial({color:0xffffff, metalness:.0, roughness:.6}));
    cone.rotation.x=Math.PI/2; g.add(cone);
  }else{ // pump
    const vol=new THREE.Mesh(new THREE.CylinderGeometry(radius*2.2, radius*2.2, radius*1.6, 20),
                             new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.35}));
    vol.rotation.x=Math.PI/2; g.add(vol);
    const motor=new THREE.Mesh(new THREE.BoxGeometry(radius*2.8, radius*1.8, radius*4.2),
                               new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.35}));
    motor.position.y=radius*2.0; g.add(motor);
  }
  return g;
}
function compBasisOnPipe(pipe, t){
  const a=pipe.a, b=pipe.b;
  const pos=new THREE.Vector3().lerpVectors(a,b,t);
  const dir=new THREE.Vector3().subVectors(b,a).normalize();
  const quat=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
  return {pos, quat, dir};
}
function refreshComp(i){
  const c=comps[i], p=pipes[c.pipeIndex]; if(!p) return;
  if(c.group){
    c.group.traverse(o=>{ if(o.geometry) o.geometry.dispose?.(); if(o.material) o.material.dispose?.(); });
    scene.remove(c.group);
  }
  const {pos, quat, dir}=compBasisOnPipe(p, c.t);
  const g=makeCompModel(c.type, p.radius);
  g.position.copy(pos); g.quaternion.copy(quat);
  // –Ω–∞—Å–æ—Å ‚Äî –ø–æ–≤–æ—Ä–æ—Ç –º–æ—Ç–æ—Ä–∞ –≤–≤–µ—Ä—Ö —ç–∫—Ä–∞–Ω–∞: –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –µ—Å—Ç—å (–æ—Å—å —É–∂–µ –ø–æ —Ç—Ä—É–±–µ)
  g.userData={compIndex:i};
  scene.add(g); c.group=g;
}

/* ===== —Å–Ω–∞–ø—ã/–ø–∏–∫–∏–Ω–≥ ===== */
function pickOnGround(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const hit=raycaster.intersectObject(ground,false)[0];
  return hit? hit.point.clone() : null;
}
function snapToGrid(v){
  if(!snapGrid) return v;
  v.x=Math.round(v.x/GRID_STEP)*GRID_STEP;
  v.y=Math.round(v.y/GRID_STEP)*GRID_STEP;
  v.z=Math.round(v.z/GRID_STEP)*GRID_STEP;
  return v;
}
function allPipeEnds(){ const arr=[]; pipes.forEach((p,idx)=>arr.push({idx,end:'a',v:p.a},{idx,end:'b',v:p.b})); return arr; }
function allPipeMids(){ const arr=[]; pipes.forEach((p,idx)=>arr.push({idx,t:0.5,v:new THREE.Vector3().lerpVectors(p.a,p.b,0.5)})); return arr; }
function snapToVertices(v){
  let best=null, bd=1e9;
  if(snapEnds){ for(const it of allPipeEnds()){ const d=it.v.distanceTo(v); if(d<bd){ bd=d; best=it.v; } } }
  if(snapMid){ for(const it of allPipeMids()){ const d=it.v.distanceTo(v); if(d<bd){ bd=d; best=it.v; } } }
  return (best && bd<=Math.max(pipeRadius*3, 0.25)) ? best.clone() : null;
}
function raycastPipes(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const meshes=pipes.map(p=>p.mesh).filter(Boolean);
  const hits=raycaster.intersectObjects(meshes, false);
  if(!hits.length) return null;
  const mesh=hits[0].object;
  const pipeIndex=pipes.findIndex(p=>p.mesh===mesh);
  const p=pipes[pipeIndex]; const a=p.a, b=p.b;
  const hitPoint=hits[0].point.clone();
  const ab=new THREE.Vector3().subVectors(b,a);
  const t=THREE.MathUtils.clamp( a.clone().distanceTo(hitPoint) / ab.length(), 0, 1 );
  return {pipeIndex,t, hitPoint};
}
function raycastComps(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const groups=comps.map(c=>c.group).filter(Boolean);
  const hits=raycaster.intersectObjects(groups, true);
  if(!hits.length) return null;
  const root=hits[0].object;
  let g=root; while(g && !g.userData?.compIndex){ g=g.parent; }
  if(!g || g.userData.compIndex==null) return null;
  return {compIndex:g.userData.compIndex};
}

/* ===== —Ä–µ–∂–∏–º—ã ===== */
let stLine='idle';       // 'idle'|'awaitFirst'|'awaitSecond'
let first=null;          // V3
let preview=null;        // Mesh
let pressTimer=null;
let editEnd=null;        // {pipeIndex,end:'a'|'b',axis:'xz'|'y'}
let placingComp=false;
let draggingComp=null;   // {compIndex}
let rulerMode=false;
let rulerFirst=null;     // V3

/* ===== UI ===== */
$('btnLine').onclick=()=>{
  if(rulerMode) { say('–°–Ω–∞—á–∞–ª–∞ –≤—ã–π–¥–∏ –∏–∑ ¬´–õ–∏–Ω–µ–π–∫–∏¬ª'); return; }
  if(stLine==='idle'){ stLine='awaitFirst'; first=null; if(preview){scene.remove(preview); preview=null;} say('–õ–∏–Ω–∏—è: —Ç–∫–Ω–∏ –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É'); return; }
  if(stLine==='awaitFirst'){ stLine='idle'; say('–û—Ç–º–µ–Ω–∞'); return; }
  if(stLine==='awaitSecond'){ stLine='idle'; first=null; if(preview){scene.remove(preview); preview=null;} say('–û—Ç–º–µ–Ω–∞'); return; }
};
$('btnUndo').onclick=()=>{
  if(preview){ scene.remove(preview); preview=null; }
  const last=pipes.pop();
  if(last){ scene.remove(last.mesh); last.mesh.geometry.dispose(); last.mesh.material.dispose(); }
  say('–û—Ç–º–µ–Ω–µ–Ω–æ');
};
$('btnRuler').onclick=()=>{
  rulerMode=!rulerMode;
  $('btnRuler').classList.toggle('tog',true);
  $('btnRuler').classList.toggle('on',rulerMode);
  stLine='idle'; first=null; if(preview){scene.remove(preview); preview=null;}
  badge('');
  say(rulerMode?'–õ–∏–Ω–µ–π–∫–∞: —Ç–∫–Ω–∏ 2 —Ç–æ—á–∫–∏':'–õ–∏–Ω–µ–π–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω–∞');
};
$('btnAxisY').onclick = ()=>{ wantY=!wantY; $('btnAxisY').classList.toggle('on', wantY); say(wantY?'–î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ Y':'–î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ XZ'); };

$('btnSnapEnds').onclick=()=>{ snapEnds=!snapEnds; $('btnSnapEnds').classList.toggle('on', snapEnds); say('–ú–∞–≥–Ω–∏—Ç –∫ —Å—Ç—ã–∫–∞–º: '+(snapEnds?'–≤–∫–ª':'–≤—ã–∫–ª')); };
$('btnSnapMid').onclick =()=>{ snapMid=!snapMid;  $('btnSnapMid').classList.toggle('on',  snapMid);  say('–ú–∞–≥–Ω–∏—Ç –∫ —Å–µ—Ä–µ–¥–∏–Ω–∞–º: '+(snapMid?'–≤–∫–ª':'–≤—ã–∫–ª')); };
$('btnSnapGrid').onclick=()=>{ snapGrid=!snapGrid; $('btnSnapGrid').classList.toggle('on', snapGrid); say('–ú–∞–≥–Ω–∏—Ç –∫ —Å–µ—Ç–∫–µ: '+(snapGrid?'–≤–∫–ª':'–≤—ã–∫–ª')); };

$('rPipe').oninput = (e)=>{ pipeRadius=parseFloat(e.target.value||'0.035'); $('rPipeVal').textContent=Math.round(pipeRadius*1000); say('–¢–æ–ª—â–∏–Ω–∞ —Ç—Ä—É–±—ã: √ò'+Math.round(pipeRadius*1000)+' –º–º'); };
$('matSel').onchange = (e)=>{ matKind=e.target.value; pipes.forEach((_,i)=>refreshPipe(i)); say('–ú–∞—Ç–µ—Ä–∏–∞–ª: '+matKind); };

$('btnPlaceComp').onclick=()=>{ placingComp=!placingComp; $('btnPlaceComp').classList.toggle('on', placingComp); say(placingComp?'–†–µ–∂–∏–º –∞—Ä–º–∞—Ç—É—Ä—ã: —Ç–∫–Ω–∏ –ø–æ —Ç—Ä—É–±–µ (–º–æ–∂–Ω–æ –¥–æ–ª–≥–∏–º —Ç–∞–ø–æ–º –ø–æ –∞—Ä–º–∞—Ç—É—Ä–µ ‚Äî —Ç—è–Ω—É—Ç—å –≤–¥–æ–ª—å —Ç—Ä—É–±—ã)':'–†–µ–∂–∏–º –∞—Ä–º–∞—Ç—É—Ä—ã –≤—ã–∫–ª—é—á–µ–Ω'); };

$('btnSave').onclick=()=>saveProject();
$('fileLoad').onchange=e=>{ const f=e.target.files?.[0]; if(f) loadProjectFile(f); };

/* ===== badge ===== */
function badge(txt){ if(!txt){ badgeEl.style.display='none'; return; } badgeEl.textContent=txt; badgeEl.style.display='block'; }

/* ===== —Å–æ–±—ã—Ç–∏—è ===== */
cv.addEventListener('pointerdown', e=>{
  clearTimeout(pressTimer);

  // 1) –¥–ª–∏–Ω–Ω—ã–π —Ç–∞–ø –ø–æ –∞—Ä–º–∞—Ç—É—Ä–µ ‚Üí –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –≤–¥–æ–ª—å —Ç—Ä—É–±—ã
  const hitComp=raycastComps(e);
  if(hitComp){
    pressTimer=setTimeout(()=>{ draggingComp={compIndex:hitComp.compIndex}; say('–¢—è–Ω–∏ –∞—Ä–º–∞—Ç—É—Ä—É –≤–¥–æ–ª—å —Ç—Ä—É–±—ã'); }, LONG_MS);
  }

  // 2) –¥–ª–∏–Ω–Ω—ã–π —Ç–∞–ø –ø–æ –∫–æ–Ω—Ü—É —Ç—Ä—É–±—ã ‚Üí –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞
  const p=pickOnGround(e);
  if(p){
    const ends=allPipeEnds().sort((A,B)=>A.v.distanceTo(p)-B.v.distanceTo(p));
    if(ends.length && ends[0].v.distanceTo(p) <= Math.max(pipeRadius*3,0.25)){
      pressTimer=setTimeout(()=>{
        editEnd={pipeIndex:ends[0].idx, end:ends[0].end, axis:(wantY?'y':'xz')};
        say('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –¥–≤–∏–≥–∞–π. –ö–Ω–æ–ø–∫–∞ Y‚Üï ‚Äî –≤—ã—Å–æ—Ç–∞.');
      }, LONG_MS);
    }
  }

  // 3) —Ä–µ–∂–∏–º –∞—Ä–º–∞—Ç—É—Ä—ã ‚Äî —Ä–∞–∑–æ–≤–∞—è –≤—Å—Ç–∞–≤–∫–∞ –ø–æ —Ç–∞–ø—É –Ω–∞ —Ç—Ä—É–±—É
  if(placingComp){
    const hit=raycastPipes(e);
    if(hit){
      const type=$('compSel').value;
      comps.push({pipeIndex:hit.pipeIndex,t:hit.t,type,group:null});
      refreshComp(comps.length-1);
      placingComp=false; $('btnPlaceComp').classList.remove('on');
      say('–ê—Ä–º–∞—Ç—É—Ä–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞');
    }else{
      say('–¢–∫–Ω–∏ –ø–æ —Ç—Ä—É–±–µ');
    }
    return;
  }

  // 4) –õ–∏–Ω–µ–π–∫–∞: –¥–≤–µ —Ç–æ—á–∫–∏
  if(rulerMode){
    let v = p ? p.clone() : null; if(!v) return;
    v = snapToGrid(v); const j=snapToVertices(v); if(j) v=j;
    if(!rulerFirst){ rulerFirst=v.clone(); badge('0 –º–º'); say('–õ–∏–Ω–µ–π–∫–∞: –≤—ã–±–µ—Ä–∏ –≤—Ç–æ—Ä—É—é —Ç–æ—á–∫—É'); }
    else{
      const d=rulerFirst.distanceTo(v);
      badge(fmtLen(d));
      say('–î–ª–∏–Ω–∞: '+fmtLen(d));
      // –∑–∞—Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø–∞—Ä—É –∫–∞–∫ –ø–æ–¥—Å–∫–∞–∑–∫—É –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥
      setTimeout(()=>badge(''), 2000);
      rulerFirst=null;
    }
    return;
  }

  // 5) –†–∏—Å–æ–≤–∞–Ω–∏–µ –ª–∏–Ω–∏–∏
  if(stLine==='awaitFirst'){
    let v = p ? p.clone() : null; if(!v) return;
    v = snapToGrid(v); const j=snapToVertices(v); if(j) v=j;
    first=v.clone(); stLine='awaitSecond'; say('–ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞. –ü–æ—Å—Ç–∞–≤—å –≤—Ç–æ—Ä—É—é.');
    return;
  }
  if(stLine==='awaitSecond' && first){
    let v = p ? p.clone() : null; if(!v) return;
    v = snapToGrid(v); const j=snapToVertices(v); if(j) v=j;

    const i=pipes.push({a:first.clone(), b:v.clone(), radius:pipeRadius, mesh:null})-1;
    refreshPipe(i);

    first=null; if(preview){ scene.remove(preview); preview=null; }
    stLine='idle'; badge(''); say('–¢—Ä—É–±–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π.');
    return;
  }
});

cv.addEventListener('pointermove', e=>{
  // –æ—Ç–º–µ–Ω–∞ –¥–æ–ª–≥–æ–≥–æ —Ç–∞–ø–∞ –ø—Ä–∏ —Å–¥–≤–∏–≥–µ
  if(pressTimer && Math.hypot(e.movementX, e.movementY) > 6){ clearTimeout(pressTimer); pressTimer=null; }

  // –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∞—Ä–º–∞—Ç—É—Ä—ã
  if(draggingComp){
    const {compIndex}=draggingComp; const c=comps[compIndex]; const p=pipes[c.pipeIndex];
    const hit=raycastPipes(e);
    if(hit && hit.pipeIndex===c.pipeIndex){
      c.t=THREE.MathUtils.clamp(hit.t, 0, 1);
      refreshComp(compIndex);
      say('–ê—Ä–º–∞—Ç—É—Ä–∞: t='+c.t.toFixed(2));
    }
    return;
  }

  // –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞
  if(editEnd){
    const p=pickOnGround(e); if(!p) return;
    const pipe=pipes[editEnd.pipeIndex]; const other = (editEnd.end==='a')?pipe.b:pipe.a;
    let v=snapToGrid(p.clone()); const j=snapToVertices(v); if(j) v=j;
    if(editEnd.axis==='xz') v.y=other.y;
    if(editEnd.end==='a') pipe.a.copy(v); else pipe.b.copy(v);
    refreshPipe(editEnd.pipeIndex);
    return;
  }

  // –ø—Ä–µ–≤—å—é –¥–ª–∏–Ω—ã –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏
  if(stLine==='awaitSecond' && first){
    const p=pickOnGround(e); if(!p) return;
    let v=snapToGrid(p.clone()); const j=snapToVertices(v); if(j) v=j;
    if(preview){ scene.remove(preview); preview=null; }
    const matPrev=new THREE.MeshStandardMaterial({color:0x7c5bff, metalness:.2, roughness:.5});
    preview=makePipeMesh(first, v, Math.max(0.8*pipeRadius, 0.01), matPrev); scene.add(preview);
    badge(fmtLen(first.distanceTo(v)));
  }
});

cv.addEventListener('pointerup', e=>{
  clearTimeout(pressTimer); pressTimer=null;
  if(draggingComp){ draggingComp=null; say('–ì–æ—Ç–æ–≤–æ'); }
  if(editEnd){ editEnd=null; say('–ì–æ—Ç–æ–≤–æ'); }
});

/* ===== —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–∑–∞–≥—Ä—É–∑–∫–∞ ===== */
function serialize(){
  return {
    version:1,
    settings:{pipeRadius, matKind, snapEnds, snapMid, snapGrid, wantY},
    pipes: pipes.map(p=>({a:p.a, b:p.b, radius:p.radius})),
    comps: comps.map(c=>({pipeIndex:c.pipeIndex, t:c.t, type:c.type}))
  };
}
function saveProject(){
  const data=serialize();
  const blob=new Blob([JSON.stringify(data)], {type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='pro-trace.json'; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
  say('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω (JSON)');
}
function loadProjectFile(file){
  const rd=new FileReader();
  rd.onload=()=>{
    try{
      const data=JSON.parse(rd.result);
      loadFromJSON(data);
      say('–ü—Ä–æ–µ–∫—Ç –∑–∞–≥—Ä—É–∂–µ–Ω');
    }catch(err){ alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª: '+err); }
  };
  rd.readAsText(file);
}
function loadFromJSON(data){
  // –æ—á–∏—Å—Ç–∏—Ç—å —Å—Ü–µ–Ω—É
  pipes.splice(0,pipes.length).forEach(p=>{ if(p.mesh){scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose();}});
  comps.splice(0,comps.length).forEach(c=>{
    if(c.group){ c.group.traverse(o=>{o.geometry?.dispose?.(); o.material?.dispose?.();}); scene.remove(c.group); }
  });

  // –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
  if(data.settings){
    pipeRadius = data.settings.pipeRadius ?? pipeRadius;
    matKind    = data.settings.matKind    ?? matKind;
    snapEnds   = !!data.settings.snapEnds;
    snapMid    = !!data.settings.snapMid;
    snapGrid   = !!data.settings.snapGrid;
    wantY      = !!data.settings.wantY;
    $('rPipe').value = String(pipeRadius);
    $('rPipeVal').textContent = Math.round(pipeRadius*1000);
    $('matSel').value = matKind;
    $('btnSnapEnds').classList.toggle('on', snapEnds);
    $('btnSnapMid').classList.toggle('on', snapMid);
    $('btnSnapGrid').classList.toggle('on', snapGrid);
    $('btnAxisY').classList.toggle('on', wantY);
  }

  // —Ç—Ä—É–±—ã
  (data.pipes||[]).forEach(p=>{
    const a=new THREE.Vector3(p.a.x,p.a.y,p.a.z);
    const b=new THREE.Vector3(p.b.x,p.b.y,p.b.z);
    pipes.push({a,b,radius:p.radius||pipeRadius, mesh:null});
  });
  pipes.forEach((_,i)=>refreshPipe(i));

  // –∞—Ä–º–∞—Ç—É—Ä–∞
  (data.comps||[]).forEach(c=>{
    comps.push({pipeIndex:c.pipeIndex, t:c.t, type:c.type, group:null});
  });
  comps.forEach((_,i)=>refreshComp(i));
}

/* ===== –æ–∫–Ω–æ/—Ä–µ—Å–∞–π–∑ ===== */
function onResize(){
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight,false);
}
addEventListener('resize', onResize, {passive:true});

/* ===== —Å—Ç–∞—Ä—Ç ===== */
init();
say('–ì–æ—Ç–æ–≤–æ: 3D —Å–µ—Ç–∫–∞. ¬´–õ–∏–Ω–∏—è¬ª ‚Äî —Ç–∞–ø-—Ç–∞–ø; ¬´–õ–∏–Ω–µ–π–∫–∞¬ª ‚Äî 2 —Ç–æ—á–∫–∏; –∞—Ä–º–∞—Ç—É—Ä—É –º–æ–∂–Ω–æ –¥–æ–ª–≥–∏–º —Ç–∞–ø–æ–º —Ç—è–Ω—É—Ç—å –≤–¥–æ–ª—å —Ç—Ä—É–±—ã; –µ—Å—Ç—å –°–æ—Ö—Ä–∞–Ω–∏—Ç—å/–ó–∞–≥—Ä—É–∑–∏—Ç—å.');
})();
</script>
</body>
</html>