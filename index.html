<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace 3D ‚Äî —Ç—Ä—É–±—ã –ø–æ –¥–≤—É–º —Ç–∞–ø–∞–º</title>
<style>
  html,body{height:100%;margin:0;background:#0f0f0f;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #app{position:fixed;inset:0}
  .bar{position:fixed;left:10px;top:10px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .btn{height:42px;padding:0 14px;border:0;border-radius:12px;background:linear-gradient(180deg,#7c5bff,#6b1dff);color:#fff;font-weight:800}
  .btn.ghost{background:#2a2a2a}
  .status{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.65);padding:6px 8px;border-radius:8px;font-size:12px;z-index:10}
</style>
</head>
<body>
<div id="app"></div>

<div class="bar">
  <button id="btnLine" class="btn">üìê –õ–∏–Ω–∏—è</button>
  <button id="btnUndo" class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
  <button id="btnClear" class="btn ghost">üßπ –û—á–∏—Å—Ç–∏—Ç—å</button>
</div>

<div id="status" class="status">–°—Ç–∞—Ç—É—Å: –ó–∞–≥—Ä—É–∂–∞—é 3D‚Ä¶</div>

<!-- three.js CDN + –ª–æ–∫–∞–ª—å–Ω—ã–π OrbitControls -->
<script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
<script src="lib/OrbitControls.js"></script>

<script>
(()=>{"use strict";
const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
const app=document.getElementById('app');
const statusEl=document.getElementById('status');
const updateStatus=(t)=>statusEl.textContent='–°—Ç–∞—Ç—É—Å: '+t;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(DPR); renderer.setSize(innerWidth,innerHeight);
renderer.setClearColor(0x0f0f0f,1);
app.appendChild(renderer.domElement);

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,1,50000);
camera.position.set(900,700,900);
const controls=new THREE.OrbitControls(camera,renderer.domElement);
controls.enableDamping=true; controls.dampingFactor=.08; controls.target.set(0,0,0);

const hemi=new THREE.HemisphereLight(0xffffff,0x202020,0.9); scene.add(hemi);
const dir =new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(800,1000,600); scene.add(dir);

// –°–µ—Ç–∫–∞ + –æ—Å–∏
const grid=new THREE.GridHelper(6000,120,0x303030,0x202020); grid.material.opacity=.9; grid.material.transparent=true; scene.add(grid);
const axes=new THREE.AxesHelper(600); scene.add(axes);

// –õ—É—á –∏ –ø–ª–æ—Å–∫–æ—Å—Ç—å XY (Y –≤–≤–µ—Ä—Ö). –ë—É–¥–µ–º –∫–ª–∞—Å—Ç—å —Ç–æ—á–∫–∏ –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å Y=0
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();
const plane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
const planeIntersect=(clientX,clientY)=>{
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((clientY-rect.top)/rect.height)*2+1;
  ray.setFromCamera(mouse,camera);
  const p=new THREE.Vector3();
  ray.ray.intersectPlane(plane,p);
  return p;
};

// –ì–µ–æ–º–µ—Ç—Ä–∏—è —É–∑–ª–∞ –∏ —Ç—Ä—É–±—ã
const nodeMat=new THREE.MeshBasicMaterial({color:0x00e0ff});
const nodeGeo=new THREE.SphereGeometry(18,20,12);
const tubeMatMetal=new THREE.MeshStandardMaterial({color:0x8ea3b0,metalness:0.8,roughness:0.35});
const TUBE_R=25; // —Ä–∞–¥–∏—É—Å —Ç—Ä—É–±—ã 50–º–º

// –î–∞–Ω–Ω—ã–µ
const segments=[]; // {a:THREE.Vector3, b:THREE.Vector3, mesh:THREE.Mesh, na:THREE.Mesh, nb:THREE.Mesh}
const stack=[];

// –°–Ω–∞–π–ø –∫ —Å–µ—Ç–∫–µ (–º–∞–≥–Ω–∏—Ç)
const STEP=50; // 50 –º–º
const snap=v=>new THREE.Vector3(
  Math.round(v.x/STEP)*STEP,
  Math.round(v.y/STEP)*STEP,
  Math.round(v.z/STEP)*STEP
);

// –°–æ—Å—Ç–æ—è–Ω–∏—è
let tool='idle';           // 'idle' | 'awaitFirst' | 'awaitSecond' | 'edit'
let first=null;            // THREE.Vector3
let editInfo=null;         // {seg, end:'a'|'b'}
let longPressTimer=null;

// UI
const $=id=>document.getElementById(id);
$('btnLine').onclick=()=>{ tool='awaitFirst'; first=null; editInfo=null; updateStatus('–õ–∏–Ω–∏—è: —Ç–∫–Ω–∏ –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É'); };
$('btnUndo').onclick=()=>{
  if(tool==='awaitSecond'&&first){ first=null; tool='awaitFirst'; updateStatus('–ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞ —Å–Ω—è—Ç–∞'); return; }
  const last=stack.pop();
  if(!last){ updateStatus('–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å'); return; }
  if(last.type==='seg'){ scene.remove(last.seg.mesh,last.seg.na,last.seg.nb); const i=segments.indexOf(last.seg); if(i>=0) segments.splice(i,1); }
  updateStatus('–û—Ç–º–µ–Ω–µ–Ω–æ');
};
$('btnClear').onclick=()=>{
  for(const s of segments){ scene.remove(s.mesh,s.na,s.nb); }
  segments.length=0; stack.length=0; first=null; tool='idle'; updateStatus('–û—á–∏—â–µ–Ω–æ');
};

// –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ü–∏–ª–∏–Ω–¥—Ä–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
function makeTubeMesh(A,B){
  const dir=new THREE.Vector3().subVectors(B,A);
  const len=dir.length()||1;
  const geo=new THREE.CylinderGeometry(TUBE_R,TUBE_R,len,24,1,true);
  const mesh=new THREE.Mesh(geo,tubeMatMetal);
  // –ü–æ–≤–µ—Ä–Ω—ë–º —Ü–∏–ª–∏–Ω–¥—Ä –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
  const axis=new THREE.Vector3(0,1,0);
  const q=new THREE.Quaternion().setFromUnitVectors(axis,dir.clone().normalize());
  mesh.quaternion.copy(q);
  mesh.position.copy(A.clone().add(B).multiplyScalar(0.5));
  return mesh;
}
function addSegment(A,B){
  const mesh=makeTubeMesh(A,B);
  const na=new THREE.Mesh(nodeGeo,nodeMat); na.position.copy(A);
  const nb=new THREE.Mesh(nodeGeo,nodeMat); nb.position.copy(B);
  scene.add(mesh,na,nb);
  const seg={a:A.clone(), b:B.clone(), mesh, na, nb};
  segments.push(seg); stack.push({type:'seg',seg});
}

// –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–≥–æ —É–∑–ª–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
function pickNode(clientX,clientY, maxDistPx=28){
  const rect=renderer.domElement.getBoundingClientRect();
  let best=null,bd=1e9;
  for(const seg of segments){
    for(const end of ['na','nb']){
      const p=seg[end].position.clone().project(camera);
      const sx=(p.x*0.5+0.5)*rect.width, sy=(-p.y*0.5+0.5)*rect.height;
      const d=Math.hypot(clientX-rect.left - sx, clientY-rect.top - sy);
      if(d<bd && d<=maxDistPx){ bd=d; best={seg,end:end==='na'?'a':'b'}; }
    }
  }
  return best;
}

// –í–≤–æ–¥
let dragging=false;
renderer.domElement.addEventListener('pointerdown',e=>{
  const p=snap(planeIntersect(e.clientX,e.clientY));
  if(tool==='awaitFirst'){
    first=p; tool='awaitSecond';
    showTempNode(p);
    updateStatus('–ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞ –µ—Å—Ç—å ‚Äî —Ç–∫–Ω–∏ –≤—Ç–æ—Ä—É—é');
  }else if(tool==='awaitSecond'){
    hideTempNode(); addSegment(first,p); first=null; tool='idle';
    updateStatus('–°–µ–≥–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –ß—Ç–æ–±—ã –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –µ—â—ë ‚Äî –Ω–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª.');
  }else{
    // –ø—Ä–æ–≤–µ—Ä–∏–º –¥–æ–ª–≥–∏–π —Ç–∞–ø –ø–æ —É–∑–ª—É ‚Äî –≤–æ–π–¥—ë–º –≤ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    const pick=pickNode(e.clientX,e.clientY);
    if(pick){
      longPressTimer=setTimeout(()=>{
        tool='edit'; editInfo=pick; dragging=true; controls.enabled=false;
        updateStatus('–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ü–∞ —Ç—Ä—É–±—ã ‚Äî –ø–æ—Ç—è–Ω–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏');
      },600);
    }
  }
},{passive:true});

renderer.domElement.addEventListener('pointermove',e=>{
  if(tool==='awaitSecond' && first){
    const p=snap(planeIntersect(e.clientX,e.clientY));
    moveTempNode(p); showTempPreview(first,p);
  }
  if(tool==='edit' && dragging && editInfo){
    const p=snap(planeIntersect(e.clientX,e.clientY));
    const seg=editInfo.seg;
    if(editInfo.end==='a'){ seg.a.copy(p); seg.na.position.copy(p); }
    else { seg.b.copy(p); seg.nb.position.copy(p); }
    // –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏—Ç—å —Ç—Ä—É–±—É
    scene.remove(seg.mesh); seg.mesh=makeTubeMesh(seg.a,seg.b); scene.add(seg.mesh);
  }
},{passive:true});

renderer.domElement.addEventListener('pointerup',()=>{
  clearTimeout(longPressTimer); longPressTimer=null;
  if(tool==='edit'){ dragging=false; tool='idle'; controls.enabled=true; updateStatus('–ì–æ—Ç–æ–≤–æ'); }
},{passive:true});

renderer.domElement.addEventListener('pointercancel',()=>{
  clearTimeout(longPressTimer); longPressTimer=null;
  if(tool==='edit'){ dragging=false; tool='idle'; controls.enabled=true; updateStatus('–û—Ç–º–µ–Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è'); }
},{passive:true});

// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ + –ø—Ä–µ–≤—å—é —Ç—Ä—É–±—ã
let tempNode=null, tempPreview=null;
function showTempNode(pos){
  if(!tempNode){ tempNode=new THREE.Mesh(nodeGeo,new THREE.MeshBasicMaterial({color:0xffcc00})); scene.add(tempNode); }
  tempNode.visible=true; tempNode.position.copy(pos);
}
function moveTempNode(pos){ if(tempNode) tempNode.position.copy(pos); }
function hideTempNode(){ if(tempNode) tempNode.visible=false; if(tempPreview){ scene.remove(tempPreview); tempPreview=null; } }
function showTempPreview(A,B){
  if(tempPreview) scene.remove(tempPreview);
  tempPreview=makeTubeMesh(A,B);
  tempPreview.material=tempPreview.material.clone();
  tempPreview.material.transparent=true; tempPreview.material.opacity=0.5;
  scene.add(tempPreview);
}

// –†–µ—Å–∞–π–∑
addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
});

// –¶–∏–∫–ª
function tick(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(tick); }
tick();
updateStatus('–ì–æ—Ç–æ–≤–æ: ¬´–õ–∏–Ω–∏—è¬ª ‚Üí 1-–π —Ç–∞–ø ‚Üí 2-–π —Ç–∞–ø. –î–æ–ª–≥–∏–π —Ç–∞–ø –ø–æ —É–∑–ª—É ‚Äî —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.');
})();
</script>
</body>
</html>
