<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä –∫–æ–Ω—Ü–æ–≤ + 3D —Å–µ—Ç–∫–∞ (v760)</title>
<style>
  :root{--violet:#8000ff; --violet2:#6b1dff; --border:#e7e3f7}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}

  /* –ú–∏–Ω–∏–º—É–º –Ω–∞ —Ö–æ–ª—Å—Ç–µ */
  .bar{position:fixed;left:8px;right:8px;top:8px;z-index:1000;display:flex;gap:8px}
  .btn{height:44px;padding:0 16px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:linear-gradient(180deg,#8c8c8c,#6a6a6a)}
  .hint{position:fixed;right:10px;top:58px;color:#666;font-size:12px;z-index:1000;opacity:.9}

  /* –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
  .panel{position:fixed;right:8px;top:64px;z-index:1100;background:#fff;border:1px solid var(--border);
         border-radius:14px;box-shadow:0 14px 32px rgba(0,0,0,.14);padding:12px;width:min(92vw,360px);display:none}
  .panel.show{display:block}
  .panel h4{margin:6px 0 10px 0}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{min-width:150px;font-size:13px;color:#444}
  .row input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#eee}
  .row input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--violet)}
  .row .val{width:56px;text-align:right;font-size:12px;color:#666}
  .sw{display:flex;align-items:center;gap:8px}
  .hr{height:1px;background:#eee;margin:10px 0}
  .panel .btn{height:38px}

  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{border:1px solid #ddd;border-radius:999px;padding:4px 8px;font-size:12px;color:#555}

  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:10px 12px;border-radius:12px;opacity:0;transition:.25s;z-index:1200;pointer-events:none}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <!-- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä -->
  <div class="bar">
    <button id="btnLine" class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnUndo" class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnHand" class="btn ghost" title="–î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ ‚Äî –ù–∞—Å—Ç—Ä–æ–π–∫–∏">üñê –†—É–∫–∞</button>
  </div>
  <div class="hint">–î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ ¬´–†—É–∫–∞¬ª ‚Üí –ù–∞—Å—Ç—Ä–æ–π–∫–∏. –î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –ø–æ –∫–æ–Ω—Ü—É –ª–∏–Ω–∏–∏ ‚Üí –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä.</div>

  <!-- –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
  <div id="panel" class="panel" role="dialog" aria-modal="true" aria-label="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">
    <h4>–õ–∏–Ω–∏—è</h4>
    <div class="row">
      <label>–¢–æ–ª—â–∏–Ω–∞ (px)</label>
      <input id="linePx" type="range" min="2" max="48" value="12">
      <span id="linePxVal" class="val">12</span>
    </div>
    <div class="row">
      <label>–¶–≤–µ—Ç</label>
      <div class="chips" style="flex:1">
        <button class="chip" data-col="#8000ff" style="border-color:#8000ff;color:#8000ff">–§–∏–æ–ª–µ—Ç–æ–≤—ã–π</button>
        <button class="chip" data-col="#ff2d55" style="border-color:#ff2d55;color:#ff2d55">–†–æ–∑–æ–≤—ã–π</button>
        <button class="chip" data-col="#00b894" style="border-color:#00b894;color:#00b894">–ó–µ–ª—ë–Ω—ã–π</button>
        <button class="chip" data-col="#1e90ff" style="border-color:#1e90ff;color:#1e90ff">–°–∏–Ω–∏–π</button>
        <button class="chip" data-col="#111111" style="border-color:#333;color:#111">–ß—ë—Ä–Ω—ã–π</button>
      </div>
      <input id="lineColor" type="color" value="#8000ff" style="width:42px;height:32px;padding:0;border:1px solid #ccc;border-radius:8px">
    </div>

    <div class="hr"></div>
    <h4>–°–µ—Ç–∫–∞ 3D</h4>
    <div class="row">
      <div class="sw">
        <input id="gridOn" type="checkbox" checked>
        <label for="gridOn">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–µ—Ç–∫—É</label>
      </div>
    </div>
    <div class="row">
      <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</label>
      <input id="gridAlpha" type="range" min="0" max="100" value="25">
      <span id="gridAlphaVal" class="val">25%</span>
    </div>
    <div class="row">
      <label>–®–∞–≥ (px)</label>
      <input id="gridStep" type="range" min="80" max="480" value="200">
      <span id="gridStepVal" class="val">200</span>
    </div>
    <div class="row">
      <label>–£–≥–æ–ª (¬∞)</label>
      <input id="gridAngle" type="range" min="-90" max="90" value="30">
      <span id="gridAngleVal" class="val">30</span>
    </div>

    <div class="hr"></div>
    <h4>–ú–∞–≥–Ω–∏—Ç</h4>
    <div class="row">
      <div class="sw">
        <input id="snapOn" type="checkbox" checked>
        <label for="snapOn">–ü—Ä–∏—Ç—è–≥–∏–≤–∞—Ç—å –∫ –∫–æ–Ω—Ü–∞–º –ª–∏–Ω–∏–π</label>
      </div>
    </div>
    <div class="row">
      <label>–†–∞–¥–∏—É—Å —É–∑–ª–∞ (px)</label>
      <input id="snapRadius" type="range" min="8" max="60" value="22">
      <span id="snapRadiusVal" class="val">22</span>
    </div>

    <div class="hr"></div>
    <h4>–§–æ—Ç–æ</h4>
    <div class="row" style="gap:8px">
      <label style="min-width:auto">–ò—Å—Ç–æ—á–Ω–∏–∫</label>
      <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üì∑ –ö–∞–º–µ—Ä–∞
        <input id="fileCam" type="file" accept="image/*" capture="environment" style="position:absolute;inset:0;opacity:0">
      </label>
      <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üìÇ –ì–∞–ª–µ—Ä–µ—è
        <input id="fileGal" type="file" accept="image/*" style="position:absolute;inset:0;opacity:0">
      </label>
    </div>

    <div class="hr"></div>
    <div class="row" style="justify-content:flex-end">
      <button id="btnExport" class="btn ghost">‚§ì PNG</button>
      <button id="btnClosePanel" class="btn">–ì–æ—Ç–æ–≤–æ</button>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(()=>{
  // ===== –£—Ç–∏–ª–∏—Ç—ã =====
  const DPR = Math.max(1, window.devicePixelRatio||1);
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d',{alpha:false});
  const toast=(t,ms=1400)=>{const el=document.getElementById('toast');el.textContent=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),ms);};

  function getCanvasPointXY(clientX, clientY){
    const r=cv.getBoundingClientRect();
    return { sx:(clientX-r.left)*(cv.width/r.width), sy:(clientY-r.top)*(cv.height/r.height) };
  }

  // ===== –°—Ü–µ–Ω–∞ / —Å–æ—Å—Ç–æ—è–Ω–∏–µ =====
  const view={scale:1,tx:0,ty:0};
  let bg=null,bw=0,bh=0;

  const segs=[]; 
  let mode='hand'; // hand | line | edit
  let first=null, preview=null;

  // –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä: {segIndex, end:'a'|'b'}
  let editing=null;

  const params={
    linePx:12,
    lineColor:'#8000ff',
    grid:{ on:true, alpha:0.25, step:200, angleDeg:30 },
    snap:{ on:true, radiusPx:22 }
  };

  // ===== –†–∞–∑–º–µ—Ä—ã =====
  function fit(){
    cv.width=Math.round(innerWidth*DPR);
    cv.height=Math.round(innerHeight*DPR);
    if(bg && view.scale===1 && view.tx===0 && view.ty===0){
      const k=Math.min(cv.width/bw, cv.height/bh);
      view.scale=k; view.tx=(cv.width-bw*k)/2; view.ty=(cv.height-bh*k)/2;
    }
    need();
  }
  addEventListener('resize',fit);

  // ===== –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è =====
  const s2w=(sx,sy)=>({x:(sx-view.tx)/view.scale, y:(sy-view.ty)/view.scale});
  const w2s=(x,y)=>({x:x*view.scale+view.tx, y:y*view.scale+view.ty});

  // ===== –†–µ–Ω–¥–µ—Ä =====
  function darker(hex, k=0.45){
    const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return '#333';
    let [r,g,b]=[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)];
    r=Math.max(0,Math.floor(r*(1-k))); g=Math.max(0,Math.floor(g*(1-k))); b=Math.max(0,Math.floor(b*(1-k)));
    return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  function drawGrid(){
    const g=params.grid; if(!g.on || g.alpha<=0) return;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha=g.alpha;

    const W=cv.width, H=cv.height, step=g.step;
    const angles=[0,90,g.angleDeg,180-g.angleDeg];

    angles.forEach(deg=>{
      const rad=deg*Math.PI/180, vx=Math.cos(rad), vy=Math.sin(rad);
      const px=-vy, py=vx;
      const N=Math.ceil((Math.max(W,H)+2000)/step);
      for(let k=-N;k<=N;k++){
        const ox=W/2 + px*k*step, oy=H/2 + py*k*step;
        const A={x:ox - vx*20000, y:oy - vy*20000};
        const B={x:ox + vx*20000, y:oy + vy*20000};
        const major=(k%3===0);
        ctx.strokeStyle=major?'#b7bcc8':'#cfd3dc';
        ctx.lineWidth=major?1.6:1.0;
        ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      }
    });

    ctx.restore(); ctx.globalAlpha=1;
  }

  function drawHandle(pt){
    const p=w2s(pt.x,pt.y);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#16a34a'; ctx.strokeStyle='#0f5132'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);
    if(bg){ ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.drawImage(bg,0,0,bw,bh); }

    drawGrid();

    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);

    const col=params.lineColor, sh=darker(col,0.45);
    for(const s of segs){
      ctx.strokeStyle=sh; ctx.globalAlpha=.75; ctx.lineWidth=(params.linePx+2)/view.scale;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();

      ctx.strokeStyle=col; ctx.globalAlpha=1; ctx.lineWidth=(params.linePx)/view.scale;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    }

    // –º–∞—Ä–∫–µ—Ä—ã line
    if(first){
      const p=w2s(first.x,first.y); ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle='#ff3b30'; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    }
    if(first && preview){
      ctx.setLineDash([12/view.scale,8/view.scale]);
      ctx.strokeStyle=col; ctx.lineWidth=Math.max(3,params.linePx-2)/view.scale;
      ctx.beginPath(); ctx.moveTo(first.x,first.y); ctx.lineTo(preview.x,preview.y); ctx.stroke();
      ctx.setLineDash([]);
      const p=w2s(preview.x,preview.y); ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle=col; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
    }

    // —Ä—É—á–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä–∞
    if(mode==='edit' && editing){
      const s=segs[editing.segIndex];
      drawHandle(editing.end==='a'?s.a:s.b);
    }
  }
  let raf=0,dirty=false; const need=()=>{dirty=true;if(!raf){raf=requestAnimationFrame(()=>{raf=0;if(dirty){dirty=false;draw();}})}};

  // ===== –ú–∞–≥–Ω–∏—Ç (–∫ —É–∑–ª–∞–º) =====
  function allNodes(){
    const arr=[]; for(const s of segs){ arr.push(s.a, s.b); } return arr;
  }
  function snapToNodes(raw){
    if(!params.snap.on) return raw;
    const R=params.snap.radiusPx / view.scale; // —Ä–∞–¥–∏—É—Å –≤ –º–∏—Ä–æ–≤—ã—Ö
    let best=null, bestD=Infinity;
    for(const n of allNodes()){
      const d=Math.hypot(n.x-raw.x, n.y-raw.y);
      if(d<bestD){ bestD=d; best=n; }
    }
    if(best && bestD<=R) return {x:best.x,y:best.y};
    return raw;
  }

  // ===== –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–≥–æ –∫–æ–Ω—Ü–∞ –ª–∏–Ω–∏–∏ (–¥–ª—è –¥–æ–ª–≥–æ–≥–æ —Ç–∞–ø–∞) =====
  function findEndpointNear(sx,sy, rPx=20){
    const R=rPx; // —É–∂–µ –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö px
    let best=null, bestD=Infinity;
    for(let i=0;i<segs.length;i++){
      const s=segs[i];
      const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y);
      const dA=Math.hypot(A.x-sx,A.y-sy), dB=Math.hypot(B.x-sx,B.y-sy);
      if(dA<bestD && dA<=R){ best={segIndex:i,end:'a'}; bestD=dA; }
      if(dB<bestD && dB<=R){ best={segIndex:i,end:'b'}; bestD=dB; }
    }
    return best;
  }

  // ===== –ñ–µ—Å—Ç—ã (—Ç–∞—á: pinch + tap-—Ç–∞–ø + –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä) =====
  let touches=new Map(), prevCenter=null, prevDist=null;
  const TAP_MAX_TIME=300, TAP_MAX_MOVE=14*DPR; const downs=new Map();
  const HOLD_MS=500; let holdTimer=null, holdStartId=null;

  const touchCount=()=>touches.size;
  const centroid=()=>{ const a=[...touches.values()]; if(!a.length) return null; let sx=0,sy=0; for(const t of a){ sx+=t.sx; sy+=t.sy;} return {sx:sx/a.length, sy:sy/a.length}; };
  const distance2=(a,b)=>Math.hypot(a.sx-b.sx, a.sy-b.sy);

  cv.addEventListener('touchstart', e=>{
    e.preventDefault();
    const now=performance.now();
    for(const t of e.changedTouches){
      const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY);
      touches.set(t.identifier,{sx,sy});
      downs.set(t.identifier,{t0:now,sx,sy});
    }
    if(touchCount()===2){
      const arr=[...touches.values()];
      prevCenter=centroid(); prevDist=distance2(arr[0],arr[1]);
      // –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–π —Ö–æ–ª–¥ (–∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä), –µ—Å–ª–∏ –Ω–∞—á–∞–ª—Å—è pinch
      clearTimeout(holdTimer); holdTimer=null; holdStartId=null;
    }
    // –∑–∞–ø—É—Å–∫ —Ö–æ–ª–¥–∞ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä–∞, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–¥–∏–Ω –ø–∞–ª–µ—Ü –∏ –Ω–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –≤—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∏
    if(touchCount()===1 && !first){
      const id=[...touches.keys()][0];
      holdStartId=id;
      const pt=touches.get(id);
      holdTimer=setTimeout(()=>{
        // –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –ø–∞–ª–µ—Ü –ø–æ—á—Ç–∏ –Ω–µ –¥–≤–∏–Ω—É–ª—Å—è
        const d=downs.get(id);
        if(!d) return;
        const move=Math.hypot(pt.sx-d.sx, pt.sy-d.sy);
        if(move<=TAP_MAX_MOVE){
          // –ø—Ä–æ–≤–µ—Ä–∫–∞ ¬´—É–¥–∞—Ä–∏–ª–∏ –ª–∏¬ª –ø–æ –∫–∞–∫–æ–º—É-—Ç–æ –∫–æ–Ω—Ü—É
          const hit=findEndpointNear(pt.sx,pt.sy, 24*DPR);
          if(hit){
            mode='edit'; editing=hit; need();
            toast('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–µ—Ä–µ—Ç–∞—â–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏');
          }
        }
      }, HOLD_MS);
    }
  }, {passive:false});

  cv.addEventListener('touchmove', e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(!touches.has(t.identifier)) continue;
      const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY);
      touches.set(t.identifier,{sx,sy});
    }
    if(touchCount()===2){
      // pinch
      const arr=[...touches.values()];
      const nowCenter=centroid(), nowDist=distance2(arr[0],arr[1]);
      if(prevCenter && prevDist){
        const k = nowDist>0 && prevDist>0 ? (nowDist/prevDist) : 1;
        view.tx = prevCenter.sx - k*(prevCenter.sx - view.tx);
        view.ty = prevCenter.sy - k*(prevCenter.sy - view.ty);
        view.scale = Math.max(0.2, Math.min(8, view.scale*k));
        view.tx += (nowCenter.sx - prevCenter.sx);
        view.ty += (nowCenter.sy - prevCenter.sy);
        need();
      }
      prevCenter=nowCenter; prevDist=nowDist;
      // –æ—Ç–º–µ–Ω—è–µ–º —Ö–æ–ª–¥
      clearTimeout(holdTimer); holdTimer=null; holdStartId=null;
      return;
    }
    if(touchCount()===1){
      const only=[...touches.values()][0];

      // –µ—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ edit ‚Äî –¥–≤–∏–≥–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∫–æ–Ω–µ—Ü
      if(mode==='edit' && editing){
        const s=segs[editing.segIndex];
        const raw = s2w(only.sx, only.sy);
        const snapped = snapToNodes(raw);
        if(editing.end==='a') s.a=snapped; else s.b=snapped;
        need();
        return;
      }

      // –ø—Ä–µ–≤—å—é –≤—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∏ –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏
      if(mode==='line' && first){
        preview = s2w(only.sx, only.sy);
        need();
      }
    }
  }, {passive:false});

  cv.addEventListener('touchend', e=>{
    e.preventDefault();
    const now=performance.now();

    for(const t of e.changedTouches){
      const down=downs.get(t.identifier);
      const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY);
      const isTap=!!down && (now-down.t0<=TAP_MAX_TIME) && (Math.hypot(sx-down.sx, sy-down.sy)<=TAP_MAX_MOVE);

      // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
      if(mode==='edit' && editing){
        // —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–Ω–∞–ø
        const s=segs[editing.segIndex];
        const raw = s2w(sx,sy);
        const snapped = snapToNodes(raw);
        if(editing.end==='a') s.a=snapped; else s.b=snapped;
        mode='hand'; editing=null; need();
      }else if(isTap && mode==='line'){
        // –ª–∏–Ω–∏—è tap‚Üítap
        const W=s2w(sx,sy);
        if(!first){ first=W; preview=null; need(); }
        else{ segs.push({a:first,b:W}); first=null; preview=null; mode='hand'; need(); toast('–°–µ–≥–º–µ–Ω—Ç –≥–æ—Ç–æ–≤. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ.'); }
      }

      downs.delete(t.identifier); touches.delete(t.identifier);
    }
    if(touchCount()<2){ prevCenter=null; prevDist=null; }
    // –æ—Ç–º–µ–Ω–∞ —Ö–æ–ª–¥–∞, –µ—Å–ª–∏ –æ—Ç–ø—É—Å—Ç–∏–ª–∏ –ø–∞–ª–µ—Ü
    if(holdStartId!==null) { clearTimeout(holdTimer); holdTimer=null; holdStartId=null; }
  }, {passive:false});

  cv.addEventListener('touchcancel', e=>{
    e.preventDefault();
    for(const t of e.changedTouches){ downs.delete(t.identifier); touches.delete(t.identifier); }
    if(touchCount()<2){ prevCenter=null; prevDist=null; }
    clearTimeout(holdTimer); holdTimer=null; holdStartId=null;
  }, {passive:false});

  // ===== –ú—ã—à—å (desktop) ‚Äî –±–∞–∑–æ–≤–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ =====
  const hasTouch='ontouchstart' in window;
  if(!hasTouch){
    // –∑—É–º –∫–æ–ª–µ—Å–æ–º
    cv.addEventListener('wheel', e=>{
      e.preventDefault();
      const {sx,sy}=getCanvasPointXY(e.clientX,e.clientY);
      const k=e.deltaY<0?1.12:0.9;
      view.tx = sx - k*(sx - view.tx);
      view.ty = sy - k*(sy - view.ty);
      view.scale = Math.max(0.2, Math.min(8, view.scale*k));
      need();
    }, {passive:false});

    // –∫–ª–∏–∫-–∫–ª–∏–∫ –¥–ª—è –ª–∏–Ω–∏–π
    let isDown=false, downPos=null, downTime=0;
    const M_TAP_MOVE=6*DPR, M_TAP_TIME=400;
    cv.addEventListener('mousedown', e=>{
      isDown=true; downTime=performance.now(); downPos=getCanvasPointXY(e.clientX,e.clientY);
      // —Ö–æ–ª–¥ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä–∞ –∫–æ–Ω—Ü–æ–≤ (–ü–ö–ú –∏–ª–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–µ –õ–ö–ú ‚Äî —É–ø—Ä–æ—Å—Ç–∏–º: Shift+–∫–ª–∏–∫ –ø–æ –∫–æ–Ω—Ü—É)
      if(e.shiftKey){
        const {sx,sy}=downPos;
        const hit=findEndpointNear(sx,sy, 16*DPR);
        if(hit){ mode='edit'; editing=hit; need(); toast('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–æ—Ç—è–Ω–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏'); }
      }
    });
    cv.addEventListener('mousemove', e=>{
      if(!isDown) return;
      const {sx,sy}=getCanvasPointXY(e.clientX,e.clientY);
      if(mode==='edit' && editing){
        const s=segs[editing.segIndex]; const raw=s2w(sx,sy); const snap=snapToNodes(raw);
        if(editing.end==='a') s.a=snap; else s.b=snap; need();
      }else if(mode==='line' && first){
        preview=s2w(sx,sy); need();
      }
    });
    addEventListener('mouseup', e=>{
      if(!isDown) return; isDown=false;
      const {sx,sy}=getCanvasPointXY(e.clientX,e.clientY);
      const isTap=(performance.now()-downTime<=M_TAP_TIME)&& (Math.hypot(sx-downPos.sx, sy-downPos.sy)<=M_TAP_MOVE);

      if(mode==='edit' && editing){
        const s=segs[editing.segIndex]; const snap=snapToNodes(s2w(sx,sy));
        if(editing.end==='a') s.a=snap; else s.b=snap; mode='hand'; editing=null; need();
      }else if(isTap && mode==='line'){
        const W=s2w(sx,sy);
        if(!first){ first=W; preview=null; need(); }
        else{ segs.push({a:first,b:W}); first=null; preview=null; mode='hand'; need(); }
      }
    });
  }

  // ===== –ö–Ω–æ–ø–∫–∏ =====
  const $=id=>document.getElementById(id);
  $('btnLine').onclick=()=>{ mode='line'; first=null; preview=null; toast('–†–µ–∂–∏–º: –ª–∏–Ω–∏—è (—Ç–∞–ø-—Ç–∞–ø)'); };
  $('btnUndo').onclick=()=>{ 
    if(mode==='edit' && editing){ mode='hand'; editing=null; need(); return; }
    if(first){ first=null; preview=null; } else segs.pop(); need();
  };
  $('btnHand').onclick=()=>{ mode='hand'; first=null; preview=null; toast('–†—É–∫–∞: –ø–∞–Ω/–∑—É–º ‚Äî 2 –ø–∞–ª—å—Ü–∞'); };

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ (–¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ ¬´–†—É–∫–∞¬ª)
  const panel=document.getElementById('panel');
  let handTimer=null;
  const togglePanel=(state)=>{
    const show=(typeof state==='boolean')? state : !panel.classList.contains('show');
    panel.classList.toggle('show', show);
    if(show) toast('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–∫—Ä—ã—Ç—ã');
  };
  $('btnHand').addEventListener('pointerdown', ()=>{ clearTimeout(handTimer); handTimer=setTimeout(()=>togglePanel(true), 800); }, {passive:true});
  $('btnHand').addEventListener('pointerup',   ()=>{ clearTimeout(handTimer); }, {passive:true});
  $('btnHand').addEventListener('pointerleave',()=>{ clearTimeout(handTimer); }, {passive:true});
  document.getElementById('btnClosePanel').onclick=()=>togglePanel(false);

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏: –ª–∏–Ω–∏—è
  const linePx=document.getElementById('linePx'), linePxVal=document.getElementById('linePxVal');
  const lineColor=document.getElementById('lineColor');
  linePx.oninput=e=>{ params.linePx=+e.target.value; linePxVal.textContent=e.target.value; need(); };
  lineColor.oninput=e=>{ params.lineColor=e.target.value; need(); };
  document.querySelectorAll('.chip').forEach(ch=>{
    ch.addEventListener('click',()=>{ const col=ch.getAttribute('data-col'); params.lineColor=col; lineColor.value=col; need(); });
  });

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏: —Å–µ—Ç–∫–∞
  const gridOn = document.getElementById('gridOn');
  const gridAlpha = document.getElementById('gridAlpha');
  const gridAlphaVal = document.getElementById('gridAlphaVal');
  const gridStep = document.getElementById('gridStep');
  const gridStepVal = document.getElementById('gridStepVal');
  const gridAngle = document.getElementById('gridAngle');
  const gridAngleVal = document.getElementById('gridAngleVal');
  gridOn.onchange = e=>{ params.grid.on=!!e.target.checked; need(); };
  gridAlpha.oninput = e=>{ params.grid.alpha=(+e.target.value)/100; gridAlphaVal.textContent=e.target.value+'%'; need(); };
  gridStep.oninput  = e=>{ params.grid.step=(+e.target.value|0); gridStepVal.textContent=e.target.value; need(); };
  gridAngle.oninput = e=>{ params.grid.angleDeg=(+e.target.value|0); gridAngleVal.textContent=e.target.value; need(); };

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏: –º–∞–≥–Ω–∏—Ç
  const snapOn=document.getElementById('snapOn');
  const snapRadius=document.getElementById('snapRadius');
  const snapRadiusVal=document.getElementById('snapRadiusVal');
  snapOn.onchange=e=>{ params.snap.on=!!e.target.checked; };
  snapRadius.oninput=e=>{ params.snap.radiusPx=+e.target.value|0; snapRadiusVal.textContent=e.target.value; };

  // –§–æ—Ç–æ
  const loadImageFile=f=>{
    if(!f) return;
    const img=new Image(); img.onload=()=>{
      const maxSide=Math.max(img.naturalWidth,img.naturalHeight);
      let w=img.naturalWidth,h=img.naturalHeight;
      if(maxSide>2200){ const sc=2200/maxSide; w=Math.round(w*sc); h=Math.round(h*sc); }
      const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d',{alpha:false}).drawImage(img,0,0,w,h);
      bg=c; bw=w; bh=h;
      const k=Math.min(cv.width/bw, cv.height/bh); view.scale=k; view.tx=(cv.width-bw*k)/2; view.ty=(cv.height-bh*k)/2;
      need(); toast('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ');
    };
    img.src=URL.createObjectURL(f);
  };
  document.getElementById('fileCam').onchange=e=>loadImageFile(e.target.files?.[0]);
  document.getElementById('fileGal').onchange=e=>loadImageFile(e.target.files?.[0]);

  // –≠–∫—Å–ø–æ—Ä—Ç
  document.getElementById('btnExport').onclick=()=>{ const url=cv.toDataURL('image/png',0.95); const a=document.createElement('a'); a.href=url; a.download='ProTrace.png'; a.click(); };

  // –°—Ç–∞—Ä—Ç
  fit();
  toast('–î–æ–ª–≥–∏–π —Ç–∞–ø –ø–æ –∫–æ–Ω—Ü—É –ª–∏–Ω–∏–∏ ‚Üí –∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä. –ü–µ—Ä–µ—Ç—è–Ω–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏. –ó—É–º/–ø–∞–Ω ‚Äî 2 –ø–∞–ª—å—Ü–∞.');
})();
</script>
</body>
</html>