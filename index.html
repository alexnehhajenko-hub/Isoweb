<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Трассировка труб</title>
  <style>
    :root{
      --ui-gap:10px;
      --ui-bg:#111; --ui-fg:#eee; --ui-accent:#7c4dff;
      --stage-bg:#f5f5f7;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;margin:0;background:#0b0b0b;color:var(--ui-fg);font:16px/1.2 -apple-system,system-ui,Segoe UI,Roboto,Arial;}
    /* Панель всегда на месте */
    .toolbar{
      position:fixed; left:0; right:0; top:0;
      display:flex; gap:8px; justify-content:center; padding:10px;
      background:rgba(20,20,22,.85); backdrop-filter:saturate(180%) blur(10px);
      z-index:10;
    }
    .btn{
      padding:8px 12px; border-radius:10px; background:var(--ui-accent); color:white; border:none;
      font-weight:600; letter-spacing:.2px;
    }
    .btn.ghost{background:#2b2b2e;}
    .btn.small{padding:6px 10px;}
    /* Холст: 95% экрана, аккуратная рамка, по центру */
    .stage-wrap{
      position:fixed; inset:0; display:grid; place-items:center; padding-top:64px; /* место под панель */
    }
    .stage{
      width:95vw; height:85vh; background:var(--stage-bg); border:1px solid rgba(255,255,255,.15); border-radius:8px;
      overflow:hidden; touch-action:none; /* важно для жестов */
      position:relative;
    }
    /* Внутри масштабируем общий контейнер с фото и канвасом */
    #viewport{
      position:absolute; left:0; top:0; transform-origin:0 0;
      /* чтобы при сильном уменьшении не было смаза текста на iOS */
      image-rendering:auto;
    }
    #bg{
      position:absolute; left:0; top:0; width:100%; height:100%; object-fit:contain; pointer-events:none;
    }
    canvas#draw{position:absolute; left:0; top:0; pointer-events:none;}
    /* статус */
    .toast{position:fixed; left:12px; bottom:12px; background:rgba(0,0,0,.6); padding:8px 10px; border-radius:10px; font-size:13px}
  </style>
</head>
<body>

  <div class="toolbar">
    <button id="lineBtn" class="btn">Линия</button>
    <button id="undoBtn" class="btn ghost">Назад</button>
    <button id="centerBtn" class="btn ghost">Центр</button>
    <button id="saveBtn" class="btn ghost">Сохранить</button>
    <button id="settingsBtn" class="btn ghost">Настройки</button>
    <button id="zoomOut" class="btn small ghost">–</button>
    <button id="zoomIn" class="btn small ghost">+</button>
  </div>

  <div class="stage-wrap">
    <div id="stage" class="stage">
      <div id="viewport">
        <img id="bg" alt="Фото" />
        <canvas id="draw"></canvas>
      </div>
    </div>
  </div>

  <div id="toast" class="toast">Режим: ожидание</div>

  <script>
  // ====== УТИЛИТЫ ============================================================
  const $ = s => document.querySelector(s);
  const toast = (msg)=>{ const t=$("#toast"); t.textContent = msg; };

  // ====== ИСХОДНЫЕ РАЗМЕРЫ ХОЛСТА (виртуальные пиксели сцены) ================
  const scene = { w: 1200, h: 1600 }; // удобно: портретная сцена
  const stageEl = $("#stage");
  const viewport = $("#viewport");
  const bg = $("#bg");
  const cvs = $("#draw");
  const ctx = cvs.getContext("2d");

  // Вьюпорт трансформы
  let state = {
    scale: 1, minScale: 0.2, maxScale: 6,
    tx: 0, ty: 0,
    // жесты
    pointers: new Map(),
    lastDist: 0,
    lastMid: null,
    drawing: false,
    pendingPt: null, // первая точка для отрезка
    lines: []       // массив отрезков {a:{x,y}, b:{x,y}, d:diam}
  };

  // Инициализация размеров контейнера/канваса
  function fitScene() {
    // вписываем scene в stage (contain), получаем стартовый scale чтобы влезло целиком
    const rect = stageEl.getBoundingClientRect();
    const sx = rect.width / scene.w;
    const sy = rect.height / scene.h;
    state.scale = Math.min(sx, sy);
    // центрируем
    state.tx = (rect.width - scene.w * state.scale) / 2;
    state.ty = (rect.height - scene.h * state.scale) / 2;
    applyTransform();
  }

  // Применение трансформа к #viewport
  function applyTransform() {
    viewport.style.transform = `translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
    viewport.style.width = scene.w + "px";
    viewport.style.height = scene.h + "px";
    // канвас и фон подгоняем к виртуальному размеру сцены
    cvs.width = scene.w; cvs.height = scene.h;
    bg.style.width = scene.w + "px"; bg.style.height = scene.h + "px";
    redraw();
  }

  // Отрисовка труб (минимум — ровные отрезки, закруглённые концы)
  const pipe = { dia: 40, color:"#2e6bff" };

  function redraw(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = pipe.color;
    ctx.lineWidth = pipe.dia;

    for (const L of state.lines){
      ctx.beginPath();
      ctx.moveTo(L.a.x, L.a.y);
      ctx.lineTo(L.b.x, L.b.y);
      ctx.stroke();
    }

    // предпросмотр текущего отрезка
    if (state.pendingPt && _cursor){
      ctx.beginPath();
      ctx.moveTo(state.pendingPt.x, state.pendingPt.y);
      ctx.lineTo(_cursor.x, _cursor.y);
      ctx.stroke();
    }
  }

  // ====== ЗУМ И ПАНОРАМИРОВАНИЕ (плавно, центр в точке жеста) ===============
  function clientToScene(x, y){
    // координаты внутри сцены
    const rect = stageEl.getBoundingClientRect();
    const px = (x - rect.left - state.tx) / state.scale;
    const py = (y - rect.top  - state.ty) / state.scale;
    return {x:px, y:py};
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function zoomAt(clientX, clientY, ds){
    const rect = stageEl.getBoundingClientRect();
    const before = clientToScene(clientX, clientY);

    const newScale = clamp(state.scale * ds, state.minScale, state.maxScale);
    const s = newScale / state.scale;
    state.scale = newScale;

    // фиксируем точку под пальцем/курсором
    state.tx = clientX - rect.left - (before.x * state.scale);
    state.ty = clientY - rect.top  - (before.y * state.scale);
    applyTransform();
  }

  // колесо мыши (на десктопе)
  stageEl.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const ds = (e.deltaY < 0) ? 1.12 : 1/1.12;
    zoomAt(e.clientX, e.clientY, ds);
  }, {passive:false});

  // двойной тап/клик — отключаем системное увеличение и делаем свой зум
  let _lastTap = 0;
  stageEl.addEventListener('click', (e)=>{
    const now = Date.now();
    if (now - _lastTap < 280){
      e.preventDefault();
      zoomAt(e.clientX, e.clientY, 1.4);
    }
    _lastTap = now;
  });

  // Pointer events для пинча и перетаскивания
  stageEl.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    stageEl.setPointerCapture(e.pointerId);
    state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (state.pointers.size === 1 && !state.drawing){
      // начинаем панорамирование
      state.panStart = { x: state.tx, y: state.ty };
      state.dragStart = { x: e.clientX, y: e.clientY };
    }
    if (state.pointers.size === 2){
      const pts=[...state.pointers.values()];
      state.lastDist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      state.lastMid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
    }
  });

  stageEl.addEventListener('pointermove', (e)=>{
    if (!state.pointers.has(e.pointerId)) return;
    state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    // 2 пальца — пинч-зум
    if (state.pointers.size === 2){
      const pts=[...state.pointers.values()];
      const dist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      const mid  = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
      const ds = dist / (state.lastDist || dist);
      if (ds && isFinite(ds) && ds!==1){
        zoomAt(mid.x, mid.y, ds);
      }
      state.lastDist = dist; state.lastMid = mid;
      return;
    }
    // 1 палец — панорамирование, если не рисуем
    if (state.pointers.size === 1 && !state.drawing){
      const dx = e.clientX - state.dragStart.x;
      const dy = e.clientY - state.dragStart.y;
      state.tx = state.panStart.x + dx;
      state.ty = state.panStart.y + dy;
      applyTransform();
    }
  });

  stageEl.addEventListener('pointerup', (e)=>{
    stageEl.releasePointerCapture(e.pointerId);
    state.pointers.delete(e.pointerId);
    state.lastDist = 0; state.lastMid = null;
  });
  stageEl.addEventListener('pointercancel', (e)=>{
    state.pointers.clear(); state.lastDist=0; state.lastMid=null;
  });

  // ====== РИСОВАНИЕ ОДНИМ ТАПОМ: ТОЧКА->ТОЧКА ================================
  let _cursor = null;
  stageEl.addEventListener('pointerdown', (e)=>{
    // если 2 пальца — это жест, а не рисование
    if (state.pointers.size > 1) return;
    // в режиме "Линия" ставим точку
    if (currentTool === 'line'){
      state.drawing = true;
      const p = clientToScene(e.clientX, e.clientY);
      if (!state.pendingPt){
        state.pendingPt = p;
        toast("Поставь вторую точку");
      }else{
        // завершаем отрезок
        state.lines.push({a:state.pendingPt, b:p, d:pipe.dia});
        state.pendingPt = null;
        toast("Линия готова. Нажми «Линия» для новой.");
        state.drawing = false;
        redraw();
      }
    }
  });

  stageEl.addEventListener('pointermove', (e)=>{
    if (currentTool !== 'line') return;
    if (!state.pendingPt) return;
    _cursor = clientToScene(e.clientX, e.clientY);
    redraw();
  });

  // ====== КНОПКИ =============================================================
  let currentTool = null;
  $("#lineBtn").onclick = ()=>{ currentTool = 'line'; toast("Режим: линия"); };
  $("#undoBtn").onclick = ()=>{
    state.lines.pop(); state.pendingPt=null; redraw(); toast("Назад");
  };
  $("#centerBtn").onclick = ()=>{ fitScene(); toast("Холст по центру"); };
  $("#zoomIn").onclick  = (e)=>{ const r=stageEl.getBoundingClientRect(); zoomAt(r.width/2, r.height/2, 1.2); };
  $("#zoomOut").onclick = (e)=>{ const r=stageEl.getBoundingClientRect(); zoomAt(r.width/2, r.height/2, 1/1.2); };
  $("#saveBtn").onclick = ()=>{
    // простое сохранение в PNG
    const tmp = document.createElement('canvas');
    tmp.width = scene.w; tmp.height = scene.h;
    const tctx = tmp.getContext('2d');
    // фон
    if (bg.src){
      // подстраховка: рисуем как изображение
      tctx.drawImage(bg,0,0,scene.w,scene.h);
    } else {
      tctx.fillStyle= "#fff"; tctx.fillRect(0,0,tmp.width,tmp.height);
    }
    // линии
    tctx.lineCap="round"; tctx.lineJoin="round"; tctx.strokeStyle=pipe.color; tctx.lineWidth=pipe.dia;
    for(const L of state.lines){ tctx.beginPath(); tctx.moveTo(L.a.x,L.a.y); tctx.lineTo(L.b.x,L.b.y); tctx.stroke(); }
    const url = tmp.toDataURL("image/png");
    const a = document.createElement('a'); a.href = url; a.download = 'trace.png'; a.click();
  };
  // «Настройки» — просто загрузка фото пока (по просьбе перенесено)
  $("#settingsBtn").onclick = async ()=>{
    const input = document.createElement('input');
    input.type='file'; input.accept='image/*';
    input.onchange = ()=>{
      const file = input.files?.[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      bg.src = url;
      redraw();
    };
    input.click();
  };

  // запрет системного дабл-тап-зума iOS
  document.addEventListener('gesturestart', e=>e.preventDefault());
  document.addEventListener('dblclick', e=>e.preventDefault(), {passive:false});

  // старт
  window.addEventListener('resize', fitScene);
  fitScene();
  </script>
</body>
</html>