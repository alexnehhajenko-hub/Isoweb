<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Isoweb v839</title>
<style>
body,html {margin:0; padding:0; height:100%; overflow:hidden; background:#fff;}
#ui {position:fixed; top:10px; left:10px; display:flex; gap:8px; z-index:10;}
.btn {padding:8px 14px; border-radius:8px; border:none; font-size:15px; cursor:pointer;}
.btn.purple {background:linear-gradient(45deg,#7b2ff7,#f107a3); color:#fff;}
.btn.gray {background:#ccc;}
.btn.yellow {background:#ffd700;}
#settings {position:fixed; top:10px; right:10px;}
#toast {position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.8); color:#fff; padding:6px 12px; border-radius:6px; font-size:14px; display:none;}
</style>
</head>
<body>
<div id="ui">
  <button class="btn purple" id="btnLine">Линия</button>
  <button class="btn gray" id="btnUndo">↩ Назад</button>
  <button class="btn yellow" id="btnHand">✋ Рука</button>
  <button class="btn gray" id="btnArrow">➡ Стрелка</button>
</div>
<div id="settings">
  <button class="btn gray" id="btnSettings">⚙</button>
</div>
<canvas id="canvas"></canvas>
<div id="toast"></div>

<script>
const cvs=document.getElementById("canvas"), ctx=cvs.getContext("2d");
let view={scale:1, tx:0, ty:0}, mode="line", drawing=false;
let first=null, segs=[], comps=[], history=[];

function resize(){cvs.width=innerWidth; cvs.height=innerHeight; draw();}
window.onresize=resize; resize();

function toast(msg,t=1500){
  const el=document.getElementById("toast");
  el.innerText=msg; el.style.display="block";
  setTimeout(()=>el.style.display="none",t);
}

function w2s(x,y){return {x:x*view.scale+view.tx,y:y*view.scale+view.ty};}
function s2w(x,y){return {x:(x-view.tx)/view.scale,y:(y-view.ty)/view.scale};}

function saveHistory(){ history.push({segs:JSON.parse(JSON.stringify(segs)), comps:JSON.parse(JSON.stringify(comps))}); }
function undo(){ if(history.length){let st=history.pop(); segs=st.segs; comps=st.comps; draw();}}

function segGeom(seg){
  var vx=seg.b.x-seg.a.x, vy=seg.b.y-seg.a.y;
  var L=Math.hypot(vx,vy); if(!L) L=1;
  return {vx:vx,vy:vy,L:L,nx:vx/L,ny:vy/L};
}

function drawLine(seg){
  ctx.strokeStyle="blue"; ctx.lineWidth=3;
  ctx.beginPath();
  let A=w2s(seg.a.x,seg.a.y), B=w2s(seg.b.x,seg.b.y);
  ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
}

function drawArrow(seg,t){
  const g=segGeom(seg); const b={x:seg.a.x+g.vx*t,y:seg.a.y+g.vy*t};
  const s=w2s(b.x,b.y); const size=12;
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.moveTo(s.x,s.y);
  ctx.lineTo(s.x-g.nx*size-g.ny*size*0.5,s.y-g.ny*size+g.nx*size*0.5);
  ctx.lineTo(s.x-g.nx*size+g.ny*size*0.5,s.y-g.ny*size-g.nx*size*0.5);
  ctx.closePath(); ctx.fill();
}

function drawValve(seg,t){
  const g=segGeom(seg); const b={x:seg.a.x+g.vx*t,y:seg.a.y+g.vy*t};
  const s=w2s(b.x,b.y); const r=14;
  ctx.fillStyle="#6b1dff"; ctx.strokeStyle="#2b145f"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s.x-r*0.7,s.y-r*0.7); ctx.lineTo(s.x+r*0.7,s.y+r*0.7); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s.x+r*0.7,s.y-r*0.7); ctx.lineTo(s.x-r*0.7,s.y+r*0.7); ctx.stroke();
}

function drawCheckValve(seg,t){
  const g=segGeom(seg); const b={x:seg.a.x+g.vx*t,y:seg.a.y+g.vy*t};
  const s=w2s(b.x,b.y); const size=18;
  ctx.strokeStyle="#ff1493"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(s.x-size,s.y); ctx.lineTo(s.x+size,s.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s.x-size*0.8,s.y+size*0.8);
  ctx.lineTo(s.x,s.y-size*0.8); ctx.lineTo(s.x+size*0.8,s.y+size*0.8);
  ctx.closePath(); ctx.stroke();
}

function drawPump(seg,t){
  const g=segGeom(seg); const b={x:seg.a.x+g.vx*t,y:seg.a.y+g.vy*t};
  const s=w2s(b.x,b.y);
  ctx.fillStyle="#0077ff"; ctx.strokeStyle="#003366"; ctx.lineWidth=2;
  ctx.fillRect(s.x-12,s.y-26,24,26); ctx.strokeRect(s.x-12,s.y-26,24,26);
  ctx.beginPath(); ctx.arc(s.x,s.y+14,14,0,Math.PI*2); ctx.fill(); ctx.stroke();
}

function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  segs.forEach(drawLine);
  comps.forEach(c=>{
    if(c.type==="valve") drawValve(segs[c.segIndex],c.t);
    if(c.type==="check") drawCheckValve(segs[c.segIndex],c.t);
    if(c.type==="pump") drawPump(segs[c.segIndex],c.t);
    if(c.type==="arrow") drawArrow(segs[c.segIndex],c.t);
  });
}

cvs.onmousedown=e=>{
  const p=s2w(e.offsetX,e.offsetY);
  if(mode==="line"){
    if(!first){ first=p; } 
    else { saveHistory(); segs.push({a:first,b:p}); first=null; draw(); }
  }
};
cvs.onmousemove=e=>{ if(first) draw(); };

document.getElementById("btnLine").onclick=()=>{mode="line"; toast("Режим: Линия");};
document.getElementById("btnUndo").onclick=()=>undo();
document.getElementById("btnHand").onclick=()=>{mode="hand"; toast("Режим: Рука");};
document.getElementById("btnArrow").onclick=()=>{mode="arrow"; toast("Режим: Стрелка (ставить на трубе)");};

cvs.addEventListener("dblclick",e=>{
  if(mode==="arrow"){
    const p=s2w(e.offsetX,e.offsetY);
    for(let i=0;i<segs.length;i++){
      const s=segs[i], g=segGeom(s);
      const len=g.L; const ap={x:p.x-s.a.x,y:p.y-s.a.y};
      const t=(ap.x*g.nx+ap.y*g.ny)/len;
      if(t>0&&t<1){ saveHistory(); comps.push({segIndex:i,t:t,type:"arrow"}); draw(); return;}
    }
  }
});

toast("Готово: v839");
</script>
</body>
</html>