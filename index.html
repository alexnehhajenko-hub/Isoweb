<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>IsoWeb ‚Äî –±—ã—Å—Ç—Ä—ã–π —ç—Å–∫–∏–∑ –ø–æ —Ñ–æ—Ç–æ</title>
<style>
  :root{--violet:#7b2cff; --violet2:#5b1fe3}
  html,body{height:100%;margin:0;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}

  .hud{position:fixed;top:8px;left:8px;right:8px;z-index:10;display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px}
  .hud button{height:40px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .hud .wide{grid-column:span 2}

  .panel{position:fixed;left:8px;right:8px;bottom:8px;background:#fff;border:1px solid #e7e3f7;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.08);padding:12px 12px 4px;z-index:11}
  .panel h4{margin:6px 0 8px;font-size:15px}
  .row{display:flex;align-items:center;gap:10px;margin:8px 0}
  .row label{min-width:160px;font-size:13px;color:#555}
  .row input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#eee}
  .row input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--violet)}
  .val{width:48px;text-align:right;font-variant-numeric:tabular-nums;color:#666}
  .closeX{position:absolute;top:6px;right:8px;line-height:1;border:none;background:transparent;font-size:20px;color:#666}
  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:8px 10px;border-radius:10px;opacity:0;transition:.25s;z-index:12}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="hud" id="hud">
    <button id="btnCamera">üì∑ –ö–∞–º–µ—Ä–∞</button>
    <button id="btnGallery">üìÇ –ì–∞–ª–µ—Ä–µ—è</button>
    <button id="btnLine">–õ–∏–Ω–∏—è</button>
    <button id="btnValve">–í–µ–Ω—Ç–∏–ª—å</button>
    <button id="btnUndo">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnClear">üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
  </div>

  <!-- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ -->
  <div class="panel" id="panel">
    <button class="closeX" id="closePanel">√ó</button>
    <h4>–°–µ—Ç–∫–∞</h4>
    <div class="row">
      <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</label>
      <input id="gridAlpha" type="range" min="0" max="100" value="22">
      <span class="val" id="gridAlphaVal">22%</span>
    </div>
    <div class="row">
      <label>–®–∞–≥ (px)</label>
      <input id="gridStep" type="range" min="80" max="480" value="200">
      <span class="val" id="gridStepVal">200</span>
    </div>
    <div class="row">
      <label>–£–≥–æ–ª (¬∞)</label>
      <input id="gridAngle" type="range" min="-90" max="90" value="30">
      <span class="val" id="gridAngleVal">30</span>
    </div>
    <h4>–õ–∏–Ω–∏–∏</h4>
    <div class="row">
      <label>–¢–æ–ª—â–∏–Ω–∞ (px)</label>
      <input id="lineWidth" type="range" min="2" max="24" value="6">
      <span class="val" id="lineWidthVal">6</span>
    </div>
  </div>

  <input id="fileCamera" type="file" accept="image/*" capture="environment" hidden>
  <input id="fileGallery" type="file" accept="image/*" hidden>
  <div class="toast" id="toast"></div>

<script>
(()=>{
  // ---------- –±–∞–∑–æ–≤—ã–µ –≤–µ—â–∏ ----------
  const DPR = Math.min(1.5, Math.max(1, devicePixelRatio || 1));
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });

  const toastEl = document.getElementById('toast');
  const toast = (t,ms=1000)=>{ toastEl.textContent=t; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); };

  const state = {
    mode: 'idle',        // idle | line | valve
    lineWidth: 6,
    gridStep: 200,
    gridAngle: 30,
    gridAlpha: .22,

    lines: [],           // [{a:{x,y}, b:{x,y}}] ‚Äî ¬´–º–∏—Ä–æ–≤—ã–µ¬ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
    valves: [],          // [{a:{x,y}, b:{x,y}}]
    first: null,

    photo: {img:null, w:0, h:0, s:1, cx:0, cy:0, alpha:0.9}
  };

  // offscreen –¥–ª—è —Å–µ—Ç–∫–∏ (–∫—ç—à)
  let gridOff = document.createElement('canvas');
  let gridDirty = true;

  // requestAnimationFrame –∫–æ–∞–ª–µ—Å—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ
  let needsDraw = true;
  function scheduleDraw(){ if(!needsDraw){ needsDraw = true; requestAnimationFrame(draw);} }

  function resize(){
    cv.width  = Math.floor(innerWidth  * DPR);
    cv.height = Math.floor(innerHeight * DPR);
    gridDirty = true;
    scheduleDraw();
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —ç–∫—Ä–∞–Ω/–º–∏—Ä ----------
  const S2W = (sx,sy)=>({ x:(sx - state.photo.cx)/state.photo.s, y:(sy - state.photo.cy)/state.photo.s });
  const W2S = (x,y)=>({ x: state.photo.cx + x*state.photo.s, y: state.photo.cy + y*state.photo.s });

  // ---------- —Å–µ—Ç–∫–∞ (–±—ã—Å—Ç—Ä–æ) ----------
  function renderGridToOffscreen(){
    gridOff.width = cv.width; gridOff.height = cv.height;
    const g = gridOff.getContext('2d');
    g.clearRect(0,0,gridOff.width,gridOff.height);

    const step = state.gridStep;
    const angle = state.gridAngle * Math.PI/180;
    const dirs = [angle, Math.PI/2, Math.PI - angle];

    g.lineCap='butt';
    for(const a of dirs){
      const vx = Math.cos(a), vy = Math.sin(a);
      const px = -vy, py = vx;
      // —Å–∫–æ–ª—å–∫–æ –ª–∏–Ω–∏–π –Ω—É–∂–Ω–æ
      const span = Math.max(cv.width, cv.height) / state.photo.s + step*4;
      const need = Math.ceil(span/step);

      for(let k=-need;k<=need;k++){
        const bx = px*k*step, by = py*k*step; // –≤ ¬´–º–∏—Ä–µ¬ª
        const A = W2S(bx - vx*10000, by - vy*10000);
        const B = W2S(bx + vx*10000, by + vy*10000);
        const major = (k%3===0);
        g.globalAlpha = (major? state.gridAlpha*1.3 : state.gridAlpha);
        g.strokeStyle = major? '#b7bcc8' : '#cfd3dc';
        g.lineWidth = major? 1.6 : 1.0;
        g.beginPath(); g.moveTo(A.x,A.y); g.lineTo(B.x,B.y); g.stroke();
      }
    }
    g.globalAlpha = 1;
    gridDirty = false;
  }

  // ---------- –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ----------
  function draw(){
    if(!needsDraw) return;
    needsDraw = false;

    // —Ñ–æ–Ω
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,cv.width,cv.height);

    // —Ñ–æ—Ç–æ
    if(state.photo.img){
      ctx.save();
      ctx.globalAlpha = state.photo.alpha;
      ctx.translate(state.photo.cx, state.photo.cy);
      ctx.scale(state.photo.s, state.photo.s);
      ctx.drawImage(state.photo.img, -state.photo.w/2, -state.photo.h/2, state.photo.w, state.photo.h);
      ctx.restore();
    }

    // —Å–µ—Ç–∫–∞ (–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
    if(gridDirty) renderGridToOffscreen();
    ctx.drawImage(gridOff, 0, 0);

    // –ª–∏–Ω–∏–∏
    ctx.lineCap='round'; ctx.lineJoin='round';
    for(const seg of state.lines){
      const A=W2S(seg.a.x,seg.a.y), B=W2S(seg.b.x,seg.b.y);
      ctx.strokeStyle='#5b00bf'; ctx.lineWidth=state.lineWidth+2; ctx.globalAlpha=.7;
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      ctx.strokeStyle='#7b2cff'; ctx.lineWidth=state.lineWidth; ctx.globalAlpha=1;
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }

    // –≤–µ–Ω—Ç–∏–ª—å
    for(const v of state.valves) drawValve(ctx, W2S(v.a.x,v.a.y), W2S(v.b.x,v.b.y), DPR);

    // –ø—Ä–µ–≤—å—é –ª–∏–Ω–∏–∏
    if(state.mode==='line' && state.first && preview){ 
      const A=W2S(state.first.x,state.first.y), B=W2S(preview.x,preview.y);
      ctx.setLineDash([8,8]);
      ctx.strokeStyle='#16a34a'; ctx.lineWidth=Math.max(3,state.lineWidth-2);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // ---------- –ø—Ä–æ—Å—Ç–∞—è ¬´–ª–∏–ø–∫–æ—Å—Ç—å¬ª –∫ –∏–∑–æ–º–µ—Ç—Ä–∏–∏ ----------
  function snapIso(p, start){
    if(!start) return p;
    const dirs = [state.gridAngle, 90, 180-state.gridAngle].map(d=>d*Math.PI/180);
    const v = {x:p.x-start.x, y:p.y-start.y};
    const L = Math.hypot(v.x,v.y)||0; if(!L) return p;
    const ang = Math.atan2(v.y,v.x);
    let bestA = ang, bestD = 1e9;
    for(const a of [...dirs, ...dirs.map(a=>a+Math.PI)]){
      const d = Math.abs(Math.atan2(Math.sin(ang-a), Math.cos(ang-a))); // |Œî|
      if(d<bestD){ bestD=d; bestA=a; }
    }
    // –¥–æ–ø—É—Å–∫–∞ 12¬∞
    if(bestD <= 12*Math.PI/180) return {x:start.x+Math.cos(bestA)*L, y:start.y+Math.sin(bestA)*L};
    return p;
  }

  // ---------- –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ ----------
  let pointers = new Map();
  let preview = null;
  let last1 = null;

  cv.addEventListener('pointerdown', e=>{
    cv.setPointerCapture?.(e.pointerId);
    const p = {x:e.clientX*DPR, y:e.clientY*DPR};
    pointers.set(e.pointerId,p);
    if(pointers.size===1) last1=p;

    if(state.mode==='line' && state.first){
      preview = S2W(p.x,p.y);
      preview = snapIso(preview, state.first);
      scheduleDraw();
    }
  }, {passive:true});

  cv.addEventListener('pointermove', e=>{
    if(!pointers.has(e.pointerId)) return;
    const cur={x:e.clientX*DPR,y:e.clientY*DPR};
    const prev=pointers.get(e.pointerId); pointers.set(e.pointerId,cur);

    // –º–∞—Å—à—Ç–∞–±/–ø–∞–Ω–æ—Ä–∞–º–∞ (–¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏)
    if(pointers.size>=2){
      const ids=[...pointers.keys()];
      const a=pointers.get(ids[0]), b=pointers.get(ids[1]);
      const ap=(ids[0]===e.pointerId?prev:a), bp=(ids[1]===e.pointerId?prev:b);
      const dPrev=Math.hypot(ap.x-bp.x, ap.y-bp.y);
      const dCur =Math.hypot(a.x-b.x , a.y-b.y );
      if(dPrev>0){
        const f=dCur/dPrev, c={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
        const dx=c.x-state.photo.cx, dy=c.y-state.photo.cy;
        state.photo.cx += dx-dx*f; state.photo.cy += dy-dy*f;
        state.photo.s  = Math.max(0.02*DPR, Math.min(state.photo.s*f, 50*DPR));
        gridDirty = true;
        scheduleDraw();
      }
      last1 = null;
      return;
    }

    // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º, –∫–æ–≥–¥–∞ –Ω–∏—á–µ–≥–æ –Ω–µ —Ä–∏—Å—É–µ–º
    if(last1 && state.mode!=='line' && state.mode!=='valve'){
      state.photo.cx += cur.x-last1.x; state.photo.cy += cur.y-last1.y;
      last1=cur; gridDirty=true; scheduleDraw(); return;
    }

    if(state.mode==='line' && state.first){
      preview = S2W(cur.x,cur.y);
      preview = snapIso(preview, state.first);
      scheduleDraw();
    }
  }, {passive:true});

  function endPtr(e){ pointers.delete(e.pointerId); last1 = (pointers.size===1)?[...pointers.values()][0]:null; }

  cv.addEventListener('pointerup', e=>{
    endPtr(e);
    const sx=e.clientX*DPR, sy=e.clientY*DPR;
    const w=S2W(sx,sy);

    if(state.mode==='line'){
      if(!state.first){ state.first = w; preview=null; toast('–ü–æ—Å—Ç–∞–≤—å –≤—Ç–æ—Ä—É—é —Ç–æ—á–∫—É'); }
      else{
        const b = snapIso(w, state.first);
        state.lines.push({a:state.first, b});
        state.first=null; preview=null; toast('–õ–∏–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞');
      }
      scheduleDraw(); return;
    }

    if(state.mode==='valve'){
      if(!state.first){ state.first = w; toast('–í—Ç–æ—Ä–∞—è —Ç–æ—á–∫–∞ –≤–µ–Ω—Ç–∏–ª—è'); }
      else{
        const b = snapIso(w, state.first);
        state.valves.push({a:state.first, b});
        state.first=null; toast('–í–µ–Ω—Ç–∏–ª—å –¥–æ–±–∞–≤–ª–µ–Ω');
      }
      scheduleDraw(); return;
    }
  }, {passive:true});
  cv.addEventListener('pointercancel', endPtr, {passive:true});

  // –∫–æ–ª–µ—Å–æ ‚Äî –º–∞—Å—à—Ç–∞–± –∫ –∫—É—Ä—Å–æ—Ä—É (–Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ)
  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    const sx=e.clientX*DPR, sy=e.clientY*DPR;
    const f=e.deltaY<0?1.12:0.9;
    const dx=sx-state.photo.cx, dy=sy-state.photo.cy;
    state.photo.cx += dx-dx*f; state.photo.cy += dy-dy*f;
    state.photo.s  = Math.max(0.02*DPR, Math.min(state.photo.s*f, 50*DPR));
    gridDirty=true; scheduleDraw();
  }, {passive:false});

  // ---------- –∫–Ω–æ–ø–∫–∏ ----------
  const $=id=>document.getElementById(id);
  $('btnLine').onclick = ()=>{ state.mode='line'; state.first=null; toast('–õ–∏–Ω–∏—è: 2 —Ç–∞–ø–∞'); };
  $('btnValve').onclick= ()=>{ state.mode='valve'; state.first=null; toast('–í–µ–Ω—Ç–∏–ª—å: 2 —Ç–∞–ø–∞'); };
  $('btnUndo').onclick = ()=>{
    if(state.first) { state.first=null; preview=null; }
    else if(state.valves.length) state.valves.pop();
    else if(state.lines.length)  state.lines.pop();
    scheduleDraw();
  };
  $('btnClear').onclick= ()=>{
    state.lines.length=0; state.valves.length=0; state.first=null; preview=null; scheduleDraw();
  };

  // –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–≤—Å–µ —á–µ—Ä–µ–∑ –æ–¥–Ω–æ –º–µ—Å—Ç–æ, —Å –∫–æ–∞–ª–µ—Å—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–æ–π)
  function bindRange(id, format, apply){
    const input=$(id), val=$(id+'Val');
    const upd=()=>{
      const v = +input.value;
      val.textContent = format(v);
      apply(v);
      scheduleDraw();
    };
    input.addEventListener('input', upd, {passive:true});
    upd();
  }
  bindRange('gridAlpha', v=>v+'%', v=>{ state.gridAlpha=v/100; gridDirty=true; });
  bindRange('gridStep' , v=>v,     v=>{ state.gridStep=v;     gridDirty=true; });
  bindRange('gridAngle', v=>v,     v=>{ state.gridAngle=v;    gridDirty=true; });
  bindRange('lineWidth', v=>v,     v=>{ state.lineWidth=v; });

  $('closePanel').onclick = ()=>{ document.getElementById('panel').style.display='none'; };
  // –ü–æ –¥–≤–æ–π–Ω–æ–º—É —Ç–∞–ø—É –ø—Ä—è—Ç–∞—Ç—å/–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–∞–Ω–µ–ª—å
  let lastTap=0;
  addEventListener('pointerup', e=>{
    const now=performance.now();
    if(now-lastTap<300){
      const p=document.getElementById('panel');
      p.style.display = (p.style.display==='none'?'':'none');
    }
    lastTap=now;
  }, {passive:true});

  // ---------- —Ñ–æ—Ç–æ (–ø–æ –∂–µ–ª–∞–Ω–∏—é, –¥–ª—è –ø–æ–¥–ª–æ–∂–∫–∏) ----------
  $('btnCamera').onclick = ()=>$('fileCamera').click();
  $('btnGallery').onclick= ()=>$('fileGallery').click();
  $('fileCamera').onchange = e=> loadFromFile(e.target.files?.[0]);
  $('fileGallery').onchange= e=> loadFromFile(e.target.files?.[0]);

  function loadFromFile(file){
    if(!file) return;
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{
      URL.revokeObjectURL(url);
      state.photo.img=img; state.photo.w=img.width; state.photo.h=img.height;
      const sx=(cv.width/DPR)/img.width*0.9, sy=(cv.height/DPR)/img.height*0.9;
      state.photo.s = Math.max(0.02, Math.min(sx,sy))*DPR;
      state.photo.cx=cv.width/2; state.photo.cy=cv.height/2;
      gridDirty=true; scheduleDraw(); toast('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ');
    };
    img.src=url;
  }

  // ---------- —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –≤–µ–Ω—Ç–∏–ª—è (–ø–æ –¥–≤—É–º —ç–∫—Ä–∞–Ω–Ω—ã–º —Ç–æ—á–∫–∞–º) ----------
  function drawValve(ctx, A, B, dpr){
    ctx.save();
    // –∫–æ—Ä–æ—Ç–∫–∏–π –∫—É—Å–æ–∫ —Ç—Ä—É–±—ã
    ctx.lineCap='round';
    ctx.strokeStyle='#7b2cff';
    ctx.lineWidth=Math.max(4, 6*dpr);
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

    // –±–∞–±–æ—á–∫–∞ + —Ä—É—á–∫–∞
    const ang=Math.atan2(B.y-A.y, B.x-A.x);
    const mid={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
    ctx.translate(mid.x, mid.y);
    ctx.rotate(ang);

    const w=12*dpr, h=8*dpr;
    ctx.fillStyle='#7b2cff';
    ctx.strokeStyle='#4a21a8';
    ctx.lineWidth=1.5*dpr;

    ctx.beginPath();
    ctx.moveTo(-w*0.5,0);
    ctx.lineTo(0,-h*0.65);
    ctx.lineTo(w*0.5,0);
    ctx.lineTo(0,h*0.65);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.strokeStyle='#111';
    ctx.lineWidth=2*dpr;
    ctx.beginPath(); ctx.moveTo(0,-h*0.95); ctx.lineTo(0,-h*1.8); ctx.stroke();
    ctx.restore();
  }

  // —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
  scheduleDraw();
})();
</script>
</body>
</html>