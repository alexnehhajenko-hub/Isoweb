<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>IsoPipe ‚Äî —á–µ—Ä—Ç–∏–º –ø–æ —Ñ–æ—Ç–æ</title>
  <style>
    :root{--ui-bg:#1e1e1e;--ui:#2c2c2c;--txt:#eaeaea;--accent:#6aa6ff}
    html,body{margin:0;height:100%;background:#111;color:var(--txt);font:16px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Inter,Arial}
    #app{position:fixed;inset:0;touch-action:none;overscroll-behavior:none}
    #c{position:absolute;inset:0;background:#111}
    /* UI */
    .bar{position:fixed;left:8px;right:8px;top:8px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
    .btn{background:linear-gradient(#5b5bff,#4a68ff);color:#fff;border:0;border-radius:14px;padding:10px 14px;font-weight:600}
    .btn.gray{background:#2a2a2a}
    .pill{background:#2a2a2a;color:#ddd;border-radius:12px;padding:8px 12px}
    .right{margin-left:auto}
    #status{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.55);color:#bff2b5;border-radius:10px;padding:8px 10px;font-size:13px}
    #file{display:none}
    /* –ø–ª–∞–≤–∞—é—â–µ–µ –º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
    #panel{position:fixed;right:8px;top:8px;z-index:11;background:#1b1b1b;border-radius:16px;padding:12px 12px 10px;box-shadow:0 10px 30px rgba(0,0,0,.35);display:none;min-width:220px}
    #panel h4{margin:0 0 8px 0;font-size:14px;opacity:.85}
    #panel label{display:flex;align-items:center;justify-content:space-between;margin:8px 0;font-size:14px}
    input[type=range]{width:130px}
  </style>
</head>
<body>
  <div id="app">
    <canvas id="c"></canvas>

    <div class="bar">
      <button id="modeLine" class="btn">–õ–∏–Ω–∏—è</button>
      <button id="undo" class="pill">–ù–∞–∑–∞–¥</button>
      <label class="pill" style="cursor:pointer;">
        üì∑ –§–æ—Ç–æ
        <input id="file" type="file" accept="image/*">
      </label>
      <button id="center" class="pill">üéØ –¶–µ–Ω—Ç—Ä</button>
      <button id="gear" class="pill right">‚öôÔ∏è</button>
    </div>

    <div id="panel">
      <h4>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h4>
      <label>√ò, –º–º <input id="diam" type="range" min="10" max="120" value="40"></label>
      <label>–°–µ—Ç–∫–∞ <input id="grid" type="range" min="0" max="80" value="40"></label>
      <label>–ú–∞–≥–Ω–∏—Ç 0/45/90¬∞ <input id="snap" type="checkbox" checked></label>
      <label>–¶–≤–µ—Ç —Ç—Ä—É–±—ã <input id="color" type="color" value="#3478ff"></label>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:6px">
        <button id="close" class="btn gray">–ì–æ—Ç–æ–≤–æ</button>
      </div>
    </div>

    <div id="status">–°—Ç–∞—Ç—É—Å: –≥–æ—Ç–æ–≤</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // --- UI ---
  const file = document.getElementById('file');
  const st  = (msg)=>{document.getElementById('status').textContent='–°—Ç–∞—Ç—É—Å: ' + msg};

  const gear = document.getElementById('gear');
  const panel = document.getElementById('panel');
  gear.onclick = ()=> panel.style.display = 'block';
  document.getElementById('close').onclick = ()=> panel.style.display = 'none';

  const diamEl = document.getElementById('diam');
  const gridEl = document.getElementById('grid');
  const snapEl = document.getElementById('snap');
  const colorEl= document.getElementById('color');

  // --- —Å—Ü–µ–Ω–∞ ---
  let W=0,H=0, DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  function resize() {
    const r = canvas.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.round(W*DPR);
    canvas.height= Math.round(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }
  new ResizeObserver(resize).observe(document.getElementById('app'));

  // —Ñ–æ–Ω-—Ñ–æ—Ç–æ
  let img = null;     // Image
  let imgW=0, imgH=0;

  // —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è ¬´–≤—Å–µ–π —Å—Ü–µ–Ω—ã¬ª (—Ñ–æ—Ç–æ+—Ç—Ä—É–±—ã+—Å–µ—Ç–∫–∞)
  const view = {x:0,y:0, scale:1};
  function resetView() {
    view.scale = Math.min(W/imgW || 1, H/imgH || 1);
    view.x = (W - imgW*view.scale)/2;
    view.y = (H - imgH*view.scale)/2;
  }

  // –≥–µ–æ–º–µ—Ç—Ä–∏—è ¬´—Ç—Ä—É–±¬ª ‚Äî –Ω–∞–±–æ—Ä —Å–µ–≥–º–µ–Ω—Ç–æ–≤
  /** —Å–µ–≥–º–µ–Ω—Ç = {pts:[[x,y],[x2,y2],...], color, d} */
  const pipes = [];
  let current = null;
  let modeLine = true;

  // helpers
  const toWorld = (sx,sy)=>[(sx-view.x)/view.scale,(sy-view.y)/view.scale];
  const toScreen= (wx,wy)=>[wx*view.scale+view.x, wy*view.scale+view.y];

  function snapDir(ax,ay,bx,by){
    if(!snapEl.checked) return [bx,by];
    const dx=bx-ax, dy=by-ay;
    const ang = Math.atan2(dy,dx);
    const step = Math.PI/4; // 45¬∞
    const snapAng = Math.round(ang/step)*step;
    const len = Math.hypot(dx,dy);
    return [ax+Math.cos(snapAng)*len, ay+Math.sin(snapAng)*len];
  }

  // —Ä–∏—Å–æ–≤–∞–Ω–∏–µ
  function drawGrid() {
    const g = +gridEl.value;
    if (!g) return;
    ctx.save();
    ctx.beginPath();
    const step = g;
    const w = img ? imgW : W/view.scale;
    const h = img ? imgH : H/view.scale;

    ctx.strokeStyle='rgba(255,255,255,.12)';
    ctx.lineWidth = 1;

    // –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
    for(let x=0;x<=w;x+=step){
      const [sx1,sy1]=toScreen(x,0);
      const [sx2,sy2]=toScreen(x,h);
      ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2);
    }
    // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
    for(let y=0;y<=h;y+=step){
      const [sx1,sy1]=toScreen(0,y);
      const [sx2,sy2]=toScreen(w,y);
      ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawPipes() {
    for (const seg of pipes) {
      paintSegment(seg);
    }
    if (current) paintSegment(current);
  }

  function paintSegment(seg){
    if (seg.pts.length<2) return;
    ctx.save();
    ctx.lineJoin='round';
    ctx.lineCap='round';
    ctx.strokeStyle = seg.color || colorEl.value;
    ctx.lineWidth = (seg.d || (+diamEl.value)) * view.scale / 10; // –≤–∏–∑—É–∞–ª—å–Ω–∞—è —Ç–æ–ª—â–∏–Ω–∞

    // —Ä–∏—Å—É–µ–º –ª–æ–º–∞–Ω—É—é —Å –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è–º–∏ (–∏–º–∏—Ç–∞—Ü–∏—è ¬´–æ—Ç–≤–æ–¥–æ–≤¬ª)
    ctx.beginPath();
    seg.pts.forEach((p,i)=>{
      const [sx,sy]=toScreen(p[0],p[1]);
      if(i===0) ctx.moveTo(sx,sy);
      else ctx.lineTo(sx,sy);
    });
    ctx.stroke();

    // –∫–æ–Ω—Ü–µ–≤—ã–µ ¬´–ø–æ–ª—É–∫—Ä—É–≥–∏¬ª
    const r = ctx.lineWidth/2;
    for (const ends of [seg.pts[0], seg.pts[seg.pts.length-1]]){
      const [sx,sy]=toScreen(ends[0],ends[1]);
      ctx.beginPath();
      ctx.arc(sx,sy,r,0,Math.PI*2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
    }
    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    // —Ñ–æ–Ω
    if (img) {
      ctx.save();
      ctx.setTransform(view.scale*DPR,0,0,view.scale*DPR,(view.x)*DPR,(view.y)*DPR);
      ctx.drawImage(img,0,0,imgW,imgH);
      ctx.restore();
    } else {
      // –ø—Ä–∏—è—Ç–Ω—ã–π —Ñ–æ–Ω, –µ—Å–ª–∏ —Ñ–æ—Ç–æ –Ω–µ—Ç
      ctx.fillStyle='#151515'; ctx.fillRect(0,0,W,H);
    }
    drawGrid();
    drawPipes();
  }

  // –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ
  file.onchange = (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const im = new Image();
    im.onload = ()=>{
      img = im; imgW = im.width; imgH = im.height;
      resetView();
      st('—Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ');
      draw();
      URL.revokeObjectURL(url);
    };
    im.src = url;
  };

  // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å
  document.getElementById('center').onclick = ()=>{
    if (img) { resetView(); draw(); }
  };

  // –†–µ–∂–∏–º ¬´–õ–∏–Ω–∏—è¬ª
  document.getElementById('modeLine').onclick = ()=>{
    modeLine = true; st('—Ä–µ–∂–∏–º: –ª–∏–Ω–∏—è');
  };
  // Undo
  document.getElementById('undo').onclick = ()=>{
    if (current && current.pts.length>1){ current.pts.pop(); }
    else current = null, pipes.pop();
    draw();
  };

  // –∂–µ—Å—Ç—ã (–ø–∞–Ω/–∑—É–º/—Ä–∏—Å–æ–≤–∞–Ω–∏–µ)
  let touches = new Map();
  let lastScale = 1, lastCenter=null;

  function getTouches() {
    return [...touches.values()];
  }
  function centroid(ts) {
    const n=ts.length; let x=0,y=0; ts.forEach(t=>{x+=t.x;y+=t.y}); return {x:x/n,y:y/n};
    }
  function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}

  function onPointerDown(x,y,id,isTouch){
    touches.set(id,{x,y});
    if (touches.size===1 && modeLine) {
      // —Å—Ç–∞—Ä—Ç –Ω–æ–≤–æ–π —Ç—Ä—É–±—ã –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ
      const [wx,wy]=toWorld(x,y);
      if (!current) current = {pts:[[wx,wy]], color: colorEl.value, d:+diamEl.value};
      else current.pts.push([wx,wy]);
      draw();
    }
    if (touches.size===2) {
      const ts = getTouches();
      lastScale = dist(ts[0],ts[1]);
      lastCenter= centroid(ts);
    }
  }
  function onPointerMove(x,y,id){
    if (!touches.has(id)) return;
    touches.set(id,{x,y});
    const ts = getTouches();

    if (ts.length===1 && modeLine && current) {
      // –ø–µ—Ä–µ–º–µ—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É
      const [ax,ay] = current.pts[current.pts.length-2] || current.pts[0];
      let [wx,wy]=toWorld(x,y);
      if (current.pts.length>=2){
        [wx,wy]=snapDir(ax,ay,wx,wy);
      }
      current.pts[current.pts.length-1]=[wx,wy];
      draw();
    }
    if (ts.length===2) {
      const c = centroid(ts);
      const ds = dist(ts[0],ts[1]);
      // –∑—É–º –≤–æ–∫—Ä—É–≥ —Ü–µ–Ω—Ç—Ä–∞ –∂–µ—Å—Ç–∞
      const k = ds / lastScale;
      if (isFinite(k) && k>0) {
        const before = toWorld(c.x,c.y);
        view.scale = Math.max(0.2, Math.min(8, view.scale*k));
        const after  = toWorld(c.x,c.y);
        view.x += (c.x - (after[0]*view.scale)) - (c.x - (before[0]*view.scale));
        view.y += (c.y - (after[1]*view.scale)) - (c.y - (before[1]*view.scale));
      }
      // –ø–∞–Ω
      view.x += (c.x - lastCenter.x);
      view.y += (c.y - lastCenter.y);
      lastCenter = c; lastScale = ds;
      draw();
    }
  }
  function onPointerUp(id){
    touches.delete(id);
    if (current && current.pts.length===1) current=null; // –æ–¥–∏–Ω–æ—á–Ω—ã–π —Ç–∞–ø ‚Äî –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
    draw();
  }

  // –º—ã—à—å
  let mid=1;
  canvas.addEventListener('mousedown',e=>onPointerDown(e.clientX,e.clientY,mid=false?0:++mid,false));
  window.addEventListener('mousemove',e=>onPointerMove(e.clientX,e.clientY,mid));
  window.addEventListener('mouseup',  ()=>onPointerUp(mid));

  // —Å–µ–Ω—Å–æ—Ä
  canvas.addEventListener('touchstart',e=>{
    for(const t of e.changedTouches) onPointerDown(t.clientX,t.clientY,t.identifier,true);
    e.preventDefault();
  },{passive:false});
  canvas.addEventListener('touchmove',e=>{
    for(const t of e.changedTouches) onPointerMove(t.clientX,t.clientY,t.identifier);
    e.preventDefault();
  },{passive:false});
  canvas.addEventListener('touchend',e=>{
    for(const t of e.changedTouches) onPointerUp(t.identifier);
    e.preventDefault();
  },{passive:false});
  canvas.addEventListener('touchcancel',e=>{
    for(const t of e.changedTouches) touches.delete(t.identifier);
    e.preventDefault();
  },{passive:false});

  // –∫–æ–ª–µ—Å–æ ‚Äî –∑—É–º –æ–∫–æ–ª–æ –∫—É—Ä—Å–æ—Ä–∞
  canvas.addEventListener('wheel',e=>{
    const k = Math.exp(-e.deltaY/300);
    const cx = e.clientX, cy = e.clientY;
    const before = toWorld(cx,cy);
    view.scale = Math.max(0.2, Math.min(8, view.scale*k));
    const after  = toWorld(cx,cy);
    view.x += (cx - (after[0]*view.scale)) - (cx - (before[0]*view.scale));
    view.y += (cy - (after[1]*view.scale)) - (cy - (before[1]*view.scale));
    draw();
    e.preventDefault();
  }, {passive:false});

  // –ø–µ—Ä–≤–∏—á–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä
  resize();
  st('–≥–æ—Ç–æ–≤. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ –∏ —Ä–∏—Å—É–π—Ç–µ');
})();
</script>
</body>
</html>