!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>IsoWeb — точный режим</title>
<style>
  :root{--violet:#7b2cff; --violet2:#5b1fe3}
  html,body{height:100%;margin:0;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
  .bar{position:fixed;left:8px;right:8px;top:8px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .btn{height:40px;border:0;border-radius:12px;padding:0 12px;font-weight:800;cursor:pointer;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff}
  .ghost{background:#fff;color:var(--violet);border:1px solid #d8c9ff}
  .warn{background:#ff3b3b;color:#fff}
  .panel{position:fixed;left:8px;right:8px;bottom:8px;background:#fff;border:1px solid #e7e3f7;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.08);padding:12px;z-index:9}
  .row{display:flex;align-items:center;gap:10px;margin:8px 0}
  .row label{min-width:140px;font-size:13px;color:#555}
  .row input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#eee}
  .row input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--violet)}
  .val{width:48px;text-align:right;font-variant-numeric:tabular-nums;color:#666}
  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:8px 10px;border-radius:10px;opacity:0;transition:.2s;z-index:20}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button class="btn" id="bLine">Линия</button>
    <button class="btn" id="bValve">Вентиль</button>
    <button class="btn ghost" id="bGrid">Сетка</button>
    <button class="btn ghost" id="bFit">Fit</button>
    <button class="btn ghost" id="bUndo">Назад</button>
    <button class="btn warn" id="bClear">Очистить</button>
  </div>

  <!-- Лёгкие настройки (по умолчанию магнит ВЫКЛ) -->
  <div class="panel" id="panel">
    <div class="row">
      <label>Толщина линии (px)</label>
      <input id="lineWidth" type="range" min="2" max="24" value="6">
      <span class="val" id="lineWidthVal">6</span>
    </div>
    <div class="row">
      <label>Сетка: прозрачность</label>
      <input id="gridAlpha" type="range" min="0" max="100" value="22">
      <span class="val" id="gridAlphaVal">22%</span>
    </div>
    <div class="row">
      <label>Сетка: шаг (px)</label>
      <input id="gridStep" type="range" min="80" max="480" value="200">
      <span class="val" id="gridStepVal">200</span>
    </div>
    <div class="row">
      <label>Сетка: угол (°)</label>
      <input id="gridAngle" type="range" min="-90" max="90" value="30">
      <span class="val" id="gridAngleVal">30</span>
    </div>
    <div class="row">
      <label>Магнит (снап)</label>
      <input id="snapOn" type="checkbox">
      <span class="val" id="snapState">Выкл</span>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(()=>{
// ====== Настройки точности ======
const DPR = 1;                 // фикс — точные касания без сдвига
const VALVE_LEN_PX = 64;       // длина кусочка трубы на экране (можно поменять)
const VALVE_THICK_PX = 6;      // толщина визуальной «трубы» клапана

// ====== DOM / состояние ======
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d', {alpha:false});
const toastEl = document.getElementById('toast');
const toast=(t,ms=900)=>{ toastEl.textContent=t; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); };

const st = {
  mode:'idle',       // idle | line | valve
  first:null,        // первая точка линии (мир)
  segs:[],           // трубы: {a:{x,y}, b:{x,y}}
  valves:[],         // вентили: {a:{x,y}, b:{x,y}} — храним в мире (масштабируемые)
  grid:true,

  // камера
  s:1, cx:0, cy:0,

  // стиль/сетка/снап
  lineWidth:6,
  gridAlpha:.22,
  gridStep:200,
  gridAngle:30,
  snap:false,          // ВЫКЛ по умолчанию
};

// offscreen сетка
let gridCv=document.createElement('canvas');
let gridDirty=true;

// ====== размер ======
function resize(){
  cv.width = Math.floor(innerWidth*DPR);
  cv.height= Math.floor(innerHeight*DPR);
  if(st.cx===0&&st.cy===0){ st.cx=cv.width/2; st.cy=cv.height/2; st.s=1; }
  gridDirty=true;
  scheduleDraw();
}
addEventListener('resize', resize, {passive:true});
resize();

// ====== преобразования ======
const w2s=(p)=>({x: st.cx + p.x*st.s, y: st.cy + p.y*st.s});
const s2w=(sx,sy)=>({x:(sx-st.cx)/st.s, y:(sy-st.cy)/st.s});

// ====== кэш сетки ======
function redrawGrid(){
  gridCv.width=cv.width; gridCv.height=cv.height;
  const g=gridCv.getContext('2d');
  g.clearRect(0,0,gridCv.width,gridCv.height);

  const step=st.gridStep;
  const angles=[st.gridAngle,90,180-st.gridAngle];
  for(const ang of angles){
    const r=ang*Math.PI/180, vx=Math.cos(r), vy=Math.sin(r), px=-vy, py=vx;
    const stepScr=step*st.s;
    const need=Math.ceil(Math.max(cv.width,cv.height)/stepScr)+2;
    for(let k=-need;k<=need;k++){
      const bx=px*k*step, by=py*k*step;
      const A=w2s({x:bx - vx*20000, y:by - vy*20000});
      const B=w2s({x:bx + vx*20000, y:by + vy*20000});
      const major=(k%3===0);
      g.globalAlpha = major? st.gridAlpha*1.3 : st.gridAlpha;
      g.strokeStyle = major? '#c3c7d1' : '#e6eaf2';
      g.lineWidth   = major? 1.4 : 1.0;
      g.beginPath(); g.moveTo(A.x,A.y); g.lineTo(B.x,B.y); g.stroke();
    }
  }
  g.globalAlpha=1;
  gridDirty=false;
}

// ====== рисование клапана на ЭКРАННЫХ координатах (толщина стабильная) ======
function drawValveScreen(A,B){
  ctx.save();
  ctx.lineCap='round';
  ctx.strokeStyle='#7b2cff';
  ctx.lineWidth=VALVE_THICK_PX;
  ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

  const ang=Math.atan2(B.y-A.y, B.x-A.x);
  const mid={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
  ctx.translate(mid.x, mid.y); ctx.rotate(ang);

  const w=12, h=8; // «бабочка»
  ctx.fillStyle='#7b2cff'; ctx.strokeStyle='#4a21a8'; ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(-w*0.5,0);
  ctx.lineTo(0,-h*0.68);
  ctx.lineTo(w*0.5,0);
  ctx.lineTo(0,h*0.68);
  ctx.closePath(); ctx.fill(); ctx.stroke();

  // ручка вверх
  ctx.strokeStyle='#111'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(0,-h*0.95); ctx.lineTo(0,-h*1.9); ctx.stroke();
  ctx.restore();
}

// ====== отрисовка сцены ======
let needs=false;
function scheduleDraw(){ if(!needs){ needs=true; requestAnimationFrame(draw);} }
function draw(){
  needs=false;
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);

  if(st.grid){
    if(gridDirty) redrawGrid();
    ctx.drawImage(gridCv,0,0);
  }

  // трубы (в мире → динамическая толщина)
  ctx.save(); ctx.translate(st.cx,st.cy); ctx.scale(st.s,st.s);
  for(const s of st.segs){
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.strokeStyle='#5b00bf'; ctx.lineWidth=(st.lineWidth+2)/st.s; ctx.globalAlpha=.7;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    ctx.strokeStyle='#7b2cff'; ctx.lineWidth=st.lineWidth/st.s; ctx.globalAlpha=1;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
  }
  ctx.restore();

  // вентили (в экранных — стабильная толщина)
  for(const v of st.valves){ drawValveScreen(w2s(v.a), w2s(v.b)); }

  // предпросмотр линии
  if(st.mode==='line' && st.first && lastPtr){
    const A=w2s(st.first), B=lastPtr;
    ctx.setLineDash([8,8]); ctx.strokeStyle='#16a34a'; ctx.lineWidth=Math.max(3,st.lineWidth-2);
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#16a34a'; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(A.x,A.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }
}

// ====== снап к изометрии (по желанию) ======
function snapIso(end, start){
  if(!st.snap || !start) return end;
  const dirs=[st.gridAngle,90,180-st.gridAngle].map(d=>d*Math.PI/180);
  const v={x:end.x-start.x,y:end.y-start.y};
  const L=Math.hypot(v.x,v.y); if(!L) return end;
  const ang=Math.atan2(v.y,v.x);
  let best=ang,bestD=1e9;
  for(const a of [...dirs, ...dirs.map(a=>a+Math.PI)]){
    const d=Math.abs(Math.atan2(Math.sin(ang-a),Math.cos(ang-a)));
    if(d<bestD){ bestD=d; best=a; }
  }
  if(bestD<=12*Math.PI/180) return {x:start.x+Math.cos(best)*L, y:start.y+Math.sin(best)*L};
  return end;
}

// ====== жесты ======
const pointers=new Map();
let lastPtr=null;
let panStart=null, pinch=null;

cv.addEventListener('pointerdown', e=>{
  cv.setPointerCapture?.(e.pointerId);
  const p={x:e.clientX*DPR,y:e.clientY*DPR};
  pointers.set(e.pointerId,p); lastPtr=p;

  if(pointers.size===1){
    if(st.mode==='line' && st.first){ /* ждём второй тап */ }
    else if(st.mode==='valve'){ /* 1 тап — поставим ниже в pointerup */ }
    else { panStart={x:p.x,y:p.y,cx:st.cx,cy:st.cy}; }
  }

  if(pointers.size===2){
    const ids=[...pointers.keys()];
    const a=pointers.get(ids[0]), b=pointers.get(ids[1]);
    pinch={d0:Math.hypot(a.x-b.x,a.y-b.y), c:{x:(a.x+b.x)/2,y:(a.y+b.y)/2}};
  }
}, {passive:true});

cv.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  const cur={x:e.clientX*DPR,y:e.clientY*DPR};
  const prev=pointers.get(e.pointerId); pointers.set(e.pointerId,cur); lastPtr=cur;

  if(pointers.size===1){
    if(st.mode==='line' && st.first){ scheduleDraw(); return; }
    if(panStart){
      st.cx = panStart.cx + (cur.x-panStart.x);
      st.cy = panStart.cy + (cur.y-panStart.y);
      gridDirty=true; scheduleDraw();
    }
  }
  if(pointers.size===2 && pinch){
    const ids=[...pointers.keys()];
    const A=pointers.get(ids[0]), B=pointers.get(ids[1]);
    const d=Math.hypot(A.x-B.x, A.y-B.y);
    if(d>0){
      const f=d/pinch.d0;
      const sx=pinch.c.x, sy=pinch.c.y;
      const w=s2w(sx,sy);
      const nextS=Math.max(0.3, Math.min(8, st.s*f));
      st.cx = sx - w.x*nextS; st.cy = sy - w.y*nextS; st.s = nextS;
      pinch.d0=d; pinch.c={x:(A.x+B.x)/2,y:(A.y+B.y)/2};
      gridDirty=true; scheduleDraw();
    }
  }
}, {passive:true});

function endPtr(e){ pointers.delete(e.pointerId); lastPtr=(pointers.size===1)?[...pointers.values()][0]:null; if(pointers.size<2) pinch=null; }
cv.addEventListener('pointerup', e=>{
  endPtr(e);
  const sx=e.clientX*DPR, sy=e.clientY*DPR;

  if(st.mode==='line'){
    const w=s2w(sx,sy);
    if(!st.first){ st.first=w; toast('Поставь вторую точку'); }
    else{
      const b = snapIso(w, st.first); // сработает только если st.snap=true
      st.segs.push({a:st.first, b});
      st.first=null; toast('Линия добавлена');
    }
    scheduleDraw(); return;
  }

  if(st.mode==='valve'){
    // 1 тап → короткий горизонтальный сегмент (в мире), длина фикс по экрану
    const centerW=s2w(sx,sy);
    const half = (VALVE_LEN_PX/2) / st.s; // перевели экранные px в мир
    const a={x:centerW.x-half, y:centerW.y};
    const b={x:centerW.x+half, y:centerW.y};
    st.valves.push({a,b});
    st.mode='idle'; toast('Вентиль добавлен');
    scheduleDraw(); return;
  }
}, {passive:true});
cv.addEventListener('pointercancel', endPtr, {passive:true});

// колесо (десктоп)
cv.addEventListener('wheel', e=>{
  e.preventDefault();
  const sx=e.clientX*DPR, sy=e.clientY*DPR;
  const f=e.deltaY<0?1.12:0.9;
  const w=s2w(sx,sy);
  const nextS=Math.max(0.3, Math.min(8, st.s*f));
  st.cx = sx - w.x*nextS; st.cy = sy - w.y*nextS; st.s = nextS;
  gridDirty=true; scheduleDraw();
}, {passive:false});

// ====== кнопки ======
const $=id=>document.getElementById(id);
$('bLine').onclick  = ()=>{ st.mode='line';  st.first=null; toast('Линия: 2 тапа'); };
$('bValve').onclick = ()=>{ st.mode='valve'; st.first=null; toast('Вентиль: 1 тап'); };
$('bGrid').onclick  = ()=>{ st.grid=!st.grid; scheduleDraw(); };
$('bFit').onclick   = ()=>{ st.s=1; st.cx=cv.width/2; st.cy=cv.height/2; gridDirty=true; scheduleDraw(); };
$('bUndo').onclick  = ()=>{ if(st.first){ st.first=null; } else if(st.valves.length) st.valves.pop(); else if(st.segs.length) st.segs.pop(); scheduleDraw(); };
$('bClear').onclick = ()=>{ st.segs.length=0; st.valves.length=0; st.first=null; scheduleDraw(); };

// ====== ползунки ======
function bindRange(id, fmt, apply){
  const input=$(id), val=$(id+'Val');
  const upd=()=>{ const v=+input.value; val.textContent=fmt(v); apply(v); };
  input.addEventListener('input', ()=>{ upd(); if(id.startsWith('grid')) gridDirty=true; scheduleDraw(); }, {passive:true});
  upd();
}
bindRange('lineWidth', v=>String(v), v=>{ st.lineWidth=v; });
bindRange('gridAlpha', v=>v+'%', v=>{ st.gridAlpha=v/100; });
bindRange('gridStep',  v=>String(v), v=>{ st.gridStep=v; });
bindRange('gridAngle', v=>String(v), v=>{ st.gridAngle=v; });

const snapOn=$('snapOn'), snapState=$('snapState');
snapOn.checked = st.snap;
snapState.textContent = st.snap ? 'Вкл' : 'Выкл';
snapOn.onchange = ()=>{ st.snap = snapOn.checked; snapState.textContent = st.snap ? 'Вкл' : 'Выкл'; };

// старт
scheduleDraw();
})();
</script>
</body>
</html>