<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Трассировка труб — one file</title>
<style>
  :root{
    --ui:#15171a; --ink:#eef2f7; --ink2:#c7d0db; --accent:#6ea8fe; --ok:#19c37d;
  }
  html,body{height:100%;margin:0;background:#0e0f10;color:var(--ink);font:16px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";}
  #toolbar{position:fixed;top:12px;left:12px;right:12px;display:flex;gap:10px;z-index:10;pointer-events:auto;flex-wrap:wrap}
  #toolbar .group{display:flex;gap:8px;background:rgba(18,20,23,.75);backdrop-filter: blur(8px);border:1px solid #2a2e35;border-radius:14px;padding:6px}
  button{color:var(--ink);background:#1d2026;border:1px solid #2b3036;border-radius:12px;padding:8px 12px}
  button.active{background:#5c7cff;border-color:#6ea8fe;color:#fff;box-shadow:0 0 0 2px rgba(110,168,254,.25) inset}
  input[type=file]{display:none}
  #status{position:fixed;left:12px;bottom:14px;z-index:10;background:rgba(0,0,0,.55);padding:8px 12px;border-radius:12px;border:1px solid #2a2e35;color:#bfe7cb}
  #canvas{position:absolute;inset:0;touch-action:none}
  /* settings dialog */
  #btnSettings{font-size:18px}
  dialog{border:none;border-radius:16px;padding:16px 18px;background:var(--ui);color:var(--ink);width:min(92vw,420px)}
  dialog::backdrop{background:rgba(0,0,0,.35)}
  dialog h3{margin:0 0 10px}
  dialog label{display:block;margin:10px 0}
  dialog .row{display:flex;align-items:center;gap:10px}
  dialog input[type=range]{width:100%}
  dialog menu{display:flex;justify-content:flex-end;gap:8px;margin:10px 0 0}
  /* grid crosshair */
  .axis-tip{position:fixed;right:12px;top:12px;z-index:9;color:var(--ink2);font-size:12px;opacity:.8}
</style>
</head>
<body>
  <div id="toolbar">
    <div class="group">
      <button id="btnLine" class="active">Линия</button>
      <button id="btnBack">Назад</button>
      <button id="btnPhoto">Фото</button>
      <label><input id="file" type="file" accept="image/*" /></label>
      <button id="btnCenter">Центр</button>
      <button id="btnSave">Сохранить</button>
      <button id="btnLoad">Загрузить</button>
      <button id="btnSettings" title="Параметры">⚙️</button>
    </div>
  </div>

  <div class="axis-tip">пинч/двумя пальцами — масштаб, одним пальцем по пустому — перенос</div>
  <canvas id="canvas"></canvas>
  <div id="status">Статус: готов</div>

  <!-- Settings dialog -->
  <dialog id="settingsDialog">
    <form method="dialog" id="settingsForm">
      <h3>Параметры</h3>
      <label>Ø трубы, мм
        <input type="range" id="diameterRange" min="10" max="200" step="1">
        <span id="diameterValue"></span>
      </label>
      <label>Сетка, px
        <input type="range" id="gridRange" min="10" max="120" step="1">
        <span id="gridValue"></span>
      </label>
      <label class="row"><input type="checkbox" id="isoCheck"> <span>Изометрия (2.5D)</span></label>
      <label class="row"><input type="checkbox" id="magnetCheck" checked> <span>Магнит 0/45/90°</span></label>
      <menu>
        <button value="cancel">Отмена</button>
        <button id="applySettings" value="ok">Применить</button>
      </menu>
    </form>
  </dialog>

<script>
(() => {
  const cvs = document.getElementById('canvas');
  const ctx = cvs.getContext('2d');
  const statusEl = document.getElementById('status');

  const file = document.getElementById('file');
  const btnPhoto = document.getElementById('btnPhoto');
  const btnLine = document.getElementById('btnLine');
  const btnBack = document.getElementById('btnBack');
  const btnCenter = document.getElementById('btnCenter');
  const btnSave = document.getElementById('btnSave');
  const btnLoad = document.getElementById('btnLoad');
  const btnSettings = document.getElementById('btnSettings');

  // dialog
  const dlg = document.getElementById('settingsDialog');
  const diameterRange = document.getElementById('diameterRange');
  const gridRange = document.getElementById('gridRange');
  const isoCheck = document.getElementById('isoCheck');
  const magnetCheck = document.getElementById('magnetCheck');
  const diameterValue = document.getElementById('diameterValue');
  const gridValue = document.getElementById('gridValue');
  const applyBtn = document.getElementById('applySettings');

  // world state
  const app = window.app = {
    // view
    zoom: 1,
    tx: 0, ty: 0,             // translate in screen px
    // photo
    bg: null, bgW:0, bgH:0,
    // drawing
    mode: 'line',
    pipeDiameter: 40,     // мм (визуально: пиксели = мм при зуме=1)
    gridSize: 40,
    isometric: false,
    magnet: true,
    segments: []          // [{a:{x,y}, b:{x,y}} ...] — в мировых координатах
  };

  // ======= utils =======
  const setStatus = (t)=> statusEl.textContent = 'Статус: ' + t;
  function resize(){
    cvs.width = innerWidth * devicePixelRatio;
    cvs.height = innerHeight * devicePixelRatio;
    cvs.style.width = innerWidth+'px';
    cvs.style.height = innerHeight+'px';
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    draw();
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // экран->мир и мир->экран
  function screenToWorld(x,y){
    return { x:(x - app.tx)/app.zoom, y:(y - app.ty)/app.zoom };
  }
  function worldToScreen(p){
    return { x:p.x*app.zoom + app.tx, y:p.y*app.zoom + app.ty };
  }

  // магнит 0/45/90 относительно последней точки
  function snapPoint(base, p){
    if(!app.magnet || !base) return p;
    const dx = p.x - base.x, dy = p.y - base.y;
    const ang = Math.atan2(dy, dx); // -PI..PI
    // к ближайшему из 0, 45°, 90°, 135°, 180°, ...
    const step = Math.PI/4; // 45°
    const r = Math.hypot(dx,dy);
    const snapped = Math.round(ang/step)*step;
    return { x: base.x + Math.cos(snapped)*r, y: base.y + Math.sin(snapped)*r };
  }

  // ======= drawing =======
  function drawGrid(){
    const g = app.gridSize;
    const w = cvs.width/devicePixelRatio, h = cvs.height/devicePixelRatio;

    // найти сдвиг сетки в экранных координатах
    const x0 = ((-app.tx/app.zoom)%g + g)%g;
    const y0 = ((-app.ty/app.zoom)%g + g)%g;

    ctx.save();
    ctx.globalAlpha = .35;
    ctx.strokeStyle = '#2a2f38';
    ctx.lineWidth = 1;

    // вертикали
    for(let x=x0; x<w; x+=g){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    // горизонтали
    for(let y=y0; y<h; y+=g){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    // оси
    const c = worldToScreen({x:0,y:0});
    ctx.globalAlpha = .55;
    ctx.strokeStyle = '#ff6b6b'; // x
    ctx.beginPath(); ctx.moveTo(0,c.y); ctx.lineTo(w,c.y); ctx.stroke();
    ctx.strokeStyle = '#6bd3ff'; // y
    ctx.beginPath(); ctx.moveTo(c.x,0); ctx.lineTo(c.x,h); ctx.stroke();

    if(app.isometric){
      ctx.globalAlpha = .25;
      ctx.strokeStyle = '#97a6ff';
      // изометрические направляющие 30°/150°
      const spacing = g*2;
      // линия под углом, рисуем через параллели
      const drawIso = (angle)=> {
        const k = Math.tan(angle);
        // y = k(x - xShift)
        for(let y=-h; y<2*h; y+=spacing){
          ctx.beginPath();
          ctx.moveTo(0, y + (x0)*k);
          ctx.lineTo(w, y + (x0 + w)*k);
          ctx.stroke();
        }
      }
      drawIso(Math.PI/6);     // 30°
      drawIso(Math.PI - Math.PI/6); // 150°
    }
    ctx.restore();
  }

  function drawBackground(){
    if(!app.bg) return;
    // фон — это просто изображение под текущим трансформом (увеличивается и двигается вместе)
    const p = worldToScreen({x:0,y:0}); // экранная позиция мирового (0,0)
    const w = app.bgW*app.zoom, h = app.bgH*app.zoom;
    ctx.globalAlpha = 1;
    ctx.drawImage(app.bg, p.x, p.y, w, h);
  }

  function drawPipes(){
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = '#4da3ff';
    ctx.fillStyle = '#4da3ff';

    for(const s of app.segments){
      const a = worldToScreen(s.a);
      const b = worldToScreen(s.b);
      const px = (app.pipeDiameter/10) * (app.zoom*0.5); // приятная толщина визуально
      ctx.lineWidth = Math.max(2, px);

      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();

      // округлённые торцы (дополнительно лёгкий отблеск)
      const capR = ctx.lineWidth/2;
      ctx.beginPath(); ctx.arc(a.x,a.y, capR, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(b.x,b.y, capR, 0, Math.PI*2); ctx.fill();

      // «полутень» (изометрия)
      if(app.isometric){
        ctx.save(); ctx.globalAlpha = .12;
        ctx.lineWidth = Math.max(1, px*1.4);
        ctx.strokeStyle = '#000';
        ctx.beginPath(); ctx.moveTo(a.x+px*.15,a.y+px*.15); ctx.lineTo(b.x+px*.15,b.y+px*.15);
        ctx.stroke(); ctx.restore();
      }
    }
  }

  function draw(){
    const w = cvs.width/devicePixelRatio, h = cvs.height/devicePixelRatio;
    ctx.clearRect(0,0,w,h);
    drawBackground();
    drawGrid();
    drawPipes();
  }

  // ======= input: draw lines =======
  let tempStart = null;      // мировая начальная точка очередного сегмента
  let panning = false;
  let lastPan = null;
  let pinchDist = 0;

  function startPointer(x,y, id, touchesCount){
    const world = screenToWorld(x,y);
    if(touchesCount===2){ panning=false; lastPan=null; return; }
    // если на пустом месте длительно — панорамирование одним пальцем
    // (простое правило: если не активна «Линия» — перемещаем)
    if(app.mode!=='line'){ panning=true; lastPan={x,y}; return; }

    tempStart = world;
  }
  function movePointer(x,y, touchesCount){
    if(touchesCount===2) return; // pinch обрабатываем отдельно
    if(panning && lastPan){
      app.tx += x - lastPan.x; app.ty += y - lastPan.y; lastPan = {x,y}; draw(); return;
    }
  }
  function endPointer(x,y){
    if(panning){ panning=false; lastPan=null; return; }
    if(!tempStart) return;
    const endW = screenToWorld(x,y);
    const snapped = app.magnet ? snapPoint(tempStart, endW) : endW;
    if( Math.hypot(snapped.x-tempStart.x, snapped.y-tempStart.y) > 1 ){
      app.segments.push({a:tempStart, b:snapped});
      setStatus('Сегмент готов. Для следующего нажми «Линия». | Готов');
      draw();
    }
    tempStart = null;
  }

  // mouse
  cvs.addEventListener('mousedown', e => startPointer(e.clientX, e.clientY, 0, 1));
  addEventListener('mousemove', e => movePointer(e.clientX, e.clientY, 1));
  addEventListener('mouseup',   e => endPointer(e.clientX, e.clientY));

  // touch
  cvs.addEventListener('touchstart', e=>{
    if(e.touches.length===2){
      // pinch start
      pinchDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
    }else{
      startPointer(e.touches[0].clientX, e.touches[0].clientY, e.touches[0].identifier, e.touches.length);
    }
  }, {passive:false});

  cvs.addEventListener('touchmove', e=>{
    if(e.touches.length===2){
      const d = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      const factor = d/pinchDist;
      pinchDist = d;
      zoomAt((e.touches[0].clientX+e.touches[1].clientX)/2, (e.touches[0].clientY+e.touches[1].clientY)/2, factor);
      e.preventDefault();
    }else{
      movePointer(e.touches[0].clientX, e.touches[0].clientY, e.touches.length);
    }
  }, {passive:false});

  cvs.addEventListener('touchend', e=>{
    if(e.touches.length===0 && e.changedTouches.length===1){
      endPointer(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
  });

  // wheel zoom
  cvs.addEventListener('wheel', (e)=>{
    const factor = e.deltaY<0 ? 1.1 : 0.9;
    zoomAt(e.clientX, e.clientY, factor);
  }, {passive:true});

  function zoomAt(cx,cy, factor){
    // масштабирование с сохранением точки под курсором
    const before = screenToWorld(cx,cy);
    app.zoom = Math.max(0.1, Math.min(10, app.zoom*factor));
    const after = screenToWorld(cx,cy);
    app.tx += (after.x - before.x)*app.zoom;
    app.ty += (after.y - before.y)*app.zoom;
    draw();
  }

  // ======= buttons =======
  btnLine.onclick = () => { app.mode='line'; btnLine.classList.add('active'); setStatus('режим: линия'); };
  btnBack.onclick = () => { app.segments.pop(); draw(); setStatus('Отменено.'); };
  btnCenter.onclick = () => { app.tx=innerWidth/2; app.ty=innerHeight/2; app.zoom=1; draw(); setStatus('Центр'); };

  btnPhoto.onclick = ()=> file.click();
  file.onchange = (ev)=>{
    const f = ev.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image(); img.onload = ()=>{
      app.bg = img; app.bgW = img.width; app.bgH = img.height;
      // поместим левый верхний угол в (0,0) мира, а экран сцентрируем
      app.tx = 0; app.ty = 0; app.zoom = Math.min(innerWidth/img.width, innerHeight/img.height)*0.9;
      draw(); setStatus('Фото загружено');
    };
    img.src = url;
  };

  // save/load (JSON)
  btnSave.onclick = ()=>{
    const data = {
      segments: app.segments, pipeDiameter: app.pipeDiameter, gridSize: app.gridSize,
      isometric: app.isometric, magnet: app.magnet
    };
    const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'trace.json';
    a.click();
    setStatus('Сохранено в trace.json');
  };
  btnLoad.onclick = ()=>{
    const i = document.createElement('input');
    i.type='file'; i.accept='application/json';
    i.onchange = e=>{
      const f = e.target.files[0]; if(!f) return;
      f.text().then(txt=>{
        try{
          const d = JSON.parse(txt);
          app.segments = d.segments||[];
          app.pipeDiameter = d.pipeDiameter||app.pipeDiameter;
          app.gridSize = d.gridSize||app.gridSize;
          app.isometric = !!d.isometric;
          app.magnet = !!d.magnet;
          syncFormFromSettings();
          draw(); setStatus('Загружено из файла');
        }catch(err){ setStatus('Ошибка загрузки JSON'); }
      });
    };
    i.click();
  };

  // ======= settings dialog logic =======
  function syncFormFromSettings(){
    diameterRange.value = app.pipeDiameter;
    gridRange.value = app.gridSize;
    isoCheck.checked = app.isometric;
    magnetCheck.checked = app.magnet;
    diameterValue.textContent = app.pipeDiameter+' мм';
    gridValue.textContent = app.gridSize+' px';
  }
  function applySettingsFromForm(){
    app.pipeDiameter = +diameterRange.value;
    app.gridSize = +gridRange.value;
    app.isometric = isoCheck.checked;
    app.magnet = magnetCheck.checked;
    draw();
  }
  btnSettings.onclick = ()=>{ syncFormFromSettings(); dlg.showModal(); };
  diameterRange.oninput = ()=> diameterValue.textContent = diameterRange.value+' мм';
  gridRange.oninput = ()=> gridValue.textContent = gridRange.value+' px';
  applyBtn.onclick = (e)=>{ e.preventDefault(); applySettingsFromForm(); dlg.close('ok'); setStatus('Параметры применены'); };

  // старт: слегка сдвинуть центр
  app.tx = innerWidth/2; app.ty = innerHeight/2; draw();
})();
</script>
</body>
</html>