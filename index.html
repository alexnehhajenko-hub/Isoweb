<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Pro Trace — стык-в-стык + Т-стыки + фото-режим</title>
<style>
  :root{--bg:#0f1115;--fg:#eef2f7;--ui:#1c1f26;--bd:#2e3340;--acc:#6aa6ff}
  *{-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;overflow:hidden}
  #wrap{position:fixed;inset:0;overflow:hidden;background:var(--bg)}
  #cv{position:absolute;inset:0;touch-action:none;-webkit-tap-highlight-color:transparent}
  .bar{position:fixed;left:10px;top:10px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  .btn{background:var(--ui);border:1px solid var(--bd);color:var(--fg);padding:10px 14px;border-radius:12px;font-weight:700}
  .btn.active{outline:2px solid var(--acc)}
  #gear{position:fixed;right:10px;top:10px;z-index:12}
  #panel{position:fixed;right:10px;top:58px;width:340px;max-width:92vw;background:rgba(24,26,33,.96);
    border:1px solid var(--bd);border-radius:14px;padding:12px;box-shadow:0 14px 36px rgba(0,0,0,.35);display:none;z-index:20}
  #panel h3{margin:0 0 8px}
  #panel .row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin:10px 0}
  #panel input[type=range]{width:180px}
  #status{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.6);padding:8px 12px;border-radius:10px;border:1px solid var(--bd);font-size:14px;z-index:11}
  #hud{position:fixed;right:10px;bottom:10px;z-index:11;background:rgba(24,26,33,.9);border:1px solid var(--bd);border-radius:10px;
    padding:8px 10px;display:none;align-items:center;gap:8px;flex-wrap:wrap}
  #hud .val{min-width:90px}
  .mini{padding:6px 8px;border-radius:8px;border:1px solid var(--bd);background:var(--ui);color:var(--fg)}
  #file{display:none}
</style>
</head>
<body>
  <div id="wrap"><canvas id="cv"></canvas></div>

  <div class="bar">
    <button id="btnLine"  class="btn">Линия</button>
    <button id="btnUndo"  class="btn">Назад</button>
    <button id="btnPhoto" class="btn">Фото</button>
    <button id="btnPhotoMode" class="btn">Фото-режим</button>
    <button id="btnPhotoCenter" class="btn">Центр фото</button>
    <button id="btnCenter" class="btn">Центр сцены</button>
    <button id="btnSave"  class="btn">Сохранить</button>
  </div>

  <button id="gear" class="btn" title="Параметры">⚙</button>
  <div id="panel">
    <h3>Параметры</h3>
    <div class="row"><span>Ø трубы, мм</span><input id="diam" type="range" min="10" max="200" value="40"><b id="dVal">40</b></div>
    <div class="row"><span>Сетка, мм</span><input id="grid" type="range" min="10" max="120" value="40"><b id="gVal">40</b></div>
    <div class="row" style="justify-content:flex-start">
      <label style="display:flex;gap:8px;align-items:center"><input id="snapDraw" type="checkbox" checked> Магнит 0/45/90° при рисовании</label>
    </div>
    <div class="row" style="justify-content:flex-start">
      <label style="display:flex;gap:8px;align-items:center"><input id="editSnap" type="checkbox"> Привязка при правке (выкл = свободно)</label>
    </div>
    <div class="row"><span>Порог стыка, px</span><input id="joinTol" type="range" min="6" max="32" value="14"><b id="jVal">14</b></div>
  </div>

  <div id="hud">
    <span class="val" id="hudAngle">∠ 0°</span>
    <span class="val" id="hudLen">L 0</span>
  </div>

  <input id="file" type="file" accept="image/*"/>
  <div id="status">Готов: Линия → 1-й тап → 2-й тап. Долгий тап по торцу — правка. Фото-режим — двигает/зумит только фото.</div>

<script>
(()=>{
// ===== Состояние
const S = {
  // трансформация сцены (трубы + сетка)
  scale: 1, ox: 0, oy: 0, minS:.2, maxS:6,
  // фон (независимый трансформ в режиме Фото-режим)
  img:null, iw:0, ih:0, bgx:40, bgy:40, bgs:1,
  // параметры
  pipe:40, grid:40, snapDraw:true, editSnap:false,
  joinTol:14, // px порог для стыковки/пересечений
  // геометрия
  segs:[], // [{a:{x,y}, b:{x,y}}]
  drawing:false, first:null, preview:null,
  // правка
  nodes:[], dragNode:null, longPress:null,
  // режимы ввода
  photoMode:false, // отдельное перемещение/зум только фото
  pinch:null, tap:{x:0,y:0,t:0,moved:false}
};

// ===== DOM
const cv = document.getElementById('cv'); const ctx = cv.getContext('2d');
const btnLine = document.getElementById('btnLine');
const btnUndo = document.getElementById('btnUndo');
const btnPhoto= document.getElementById('btnPhoto');
const btnPhotoMode= document.getElementById('btnPhotoMode');
const btnPhotoCenter= document.getElementById('btnPhotoCenter');
const btnCenter=document.getElementById('btnCenter');
const btnSave = document.getElementById('btnSave');
const gear    = document.getElementById('gear');
const panel   = document.getElementById('panel');
const fileInp = document.getElementById('file');
const diamInp = document.getElementById('diam'); const dVal=document.getElementById('dVal');
const gridInp = document.getElementById('grid'); const gVal=document.getElementById('gVal');
const snapDraw= document.getElementById('snapDraw');
const editSnap= document.getElementById('editSnap');
const joinTol = document.getElementById('joinTol'); const jVal=document.getElementById('jVal');

const hud = document.getElementById('hud');
const hudAngle = document.getElementById('hudAngle');
const hudLen   = document.getElementById('hudLen');
const statusEl = document.getElementById('status');
const setStatus = t => statusEl.textContent = 'Статус: ' + t;

// ===== Размеры
function resize(){
  const dpr = Math.max(1, devicePixelRatio||1);
  const w = innerWidth, h = innerHeight;
  cv.width = Math.round(w*dpr); cv.height = Math.round(h*dpr);
  cv.style.width = w+'px'; cv.style.height = h+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}
addEventListener('resize', resize, {passive:true});

// ===== Координаты
const toWorld  = (x,y)=>({ x:(x - S.ox)/S.scale, y:(y - S.oy)/S.scale });
const toScreen = (x,y)=>({ x:x*S.scale + S.ox,   y:y*S.scale + S.oy   });

// ===== Фото: экран→коорд фона (для независимого зума/пан фото)
const toBgScreen = (wx,wy)=>({ x: wx*S.bgs + S.bgx, y: wy*S.bgs + S.bgy });

// ===== Вспомогательные
function vecInfo(a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  const L=Math.hypot(dx,dy);
  let deg=(Math.atan2(dy,dx)*180/Math.PI+360)%360; if(deg>180) deg=360-deg;
  return {L,deg};
}
function snap45(base,p){
  if(!S.snapDraw || !base) return p;
  const dx=p.x-base.x, dy=p.y-base.y, L=Math.hypot(dx,dy);
  const step=Math.PI/4, s=Math.round(Math.atan2(dy,dx)/step)*step;
  return {x: base.x + Math.cos(s)*L, y: base.y + Math.sin(s)*L};
}
function dot(a,b){return a.x*b.x+a.y*b.y;}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function scale(v,k){return {x:v.x*k,y:v.y*k};}
function len(v){return Math.hypot(v.x,v.y);}
function clamp01(t){return Math.max(0,Math.min(1,t));}

// проекция точки на отрезок (мировые)
function projectPointOnSeg(P,A,B){
  const v=sub(B,A); const L2=dot(v,v)||1;
  let t=dot(sub(P,A),v)/L2; t=clamp01(t);
  const Q=add(A,scale(v,t));
  return {Q,t,dist:len(sub(P,Q))};
}

// пересечение двух отрезков (мировые), возвращает {p,ta,tb} или null
function segIntersection(a1,a2,b1,b2){
  const r=sub(a2,a1), s=sub(b2,b1);
  const rxs = r.x*s.y - r.y*s.x;
  const qpxr = (b1.x-a1.x)*r.y - (b1.y-a1.y)*r.x;
  if(Math.abs(rxs)<1e-12 && Math.abs(qpxr)<1e-12) return null; // коллинеарно (игнор)
  if(Math.abs(rxs)<1e-12) return null; // параллельно
  const t = ((b1.x-a1.x)*s.y - (b1.y-a1.y)*s.x)/rxs;
  const u = ((b1.x-a1.x)*r.y - (b1.y-a1.y)*r.x)/rxs;
  if(t>=0 && t<=1 && u>=0 && u<=1){
    return { p: add(a1,scale(r,t)), ta:t, tb:u };
  }
  return null;
}

// ===== Стыковка: корректировка конца и разрез сегмента при Т-стыке
function prepareEndWithJunction(start,end){
  // 1) ищем ближайшее попадание: к концу существующего сегмента (endpoint snap)
  let bestSnap = null;
  const tolWorld = S.joinTol / S.scale; // в мировых единицах
  for(const s of S.segs){
    for(const P of [s.a,s.b]){
      const proj = projectPointOnSeg(P, start, end);
      if(proj.dist <= tolWorld){
        const distFromStart = proj.t * len(sub(end,start));
        if(!bestSnap || distFromStart < bestSnap.dist){
          bestSnap = { type:'endpoint', p:P, dist:distFromStart };
        }
      }
    }
  }

  // 2) ищем реальное пересечение с серединой любого сегмента → Т-стык
  let bestCross = null;
  for(let i=0;i<S.segs.length;i++){
    const s = S.segs[i];
    const inter = segIntersection(start,end,s.a,s.b);
    if(inter){
      // игнорируем попадание точно в его концы — это покроет endpoint
      if(inter.tb>1e-4 && inter.tb<1-1e-4){
        const distFromStart = inter.ta * len(sub(end,start));
        if(!bestCross || distFromStart < bestCross.dist){
          bestCross = { type:'tee', p:inter.p, segIndex:i, ta:inter.ta, tb:inter.tb, dist:distFromStart };
        }
      }
    }
  }

  // приоритет — ближайшее событие от старта
  const candidate = (!bestCross || (bestSnap && bestSnap.dist<bestCross.dist)) ? bestSnap : bestCross;
  if(!candidate) return {end, split:null};

  if(candidate.type==='endpoint'){
    return { end: {x:candidate.p.x,y:candidate.p.y}, split:null };
  }
  if(candidate.type==='tee'){
    return { end: candidate.p, split: { segIndex:candidate.segIndex, point:candidate.p } };
  }
  return {end, split:null};
}

// разрез существующего сегмента на две части в точке point
function splitSegment(segIndex, point){
  const s = S.segs[segIndex]; if(!s) return;
  // если точка почти на одном из концов — не режем
  const nearA = len(sub(point,s.a))<1e-6;
  const nearB = len(sub(point,s.b))<1e-6;
  if(nearA || nearB) return;
  const A={x:s.a.x,y:s.a.y}, B={x:s.b.x,y:s.b.y};
  // заменить текущий на A-point, и добавить point-B
  S.segs[segIndex] = {a:A, b:{x:point.x,y:point.y}};
  S.segs.splice(segIndex+1, 0, {a:{x:point.x,y:point.y}, b:B});
}

// ===== Рендер
function drawBG(){
  if(!S.img) return;
  // фон рисуем по своим параметрам bgx,bgy,bgs (НЕ по transform сцены)
  ctx.drawImage(S.img, S.bgx, S.bgy, S.iw*S.bgs, S.ih*S.bgs);
}
function drawGrid(){
  // сетка и трубы — в трансформации сцены
  const step = S.grid*S.scale; if(step<8) return;
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
  const x0=((S.ox%step)+step)%step, y0=((S.oy%step)+step)%step;
  for(let x=x0;x<cv.width;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=y0;y<cv.height;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
  ctx.restore();
}
function drawPipes(){
  const W = Math.max(2, S.pipe*S.scale*0.45);
  ctx.lineCap='butt'; // чтобы “в стык” выглядело чисто
  ctx.lineJoin='round';
  ctx.miterLimit=6;

  // тень
  ctx.strokeStyle='rgba(0,0,0,.28)'; ctx.lineWidth=W+4;
  for(const s of S.segs){
    const a=toScreen(s.a.x,s.a.y), b=toScreen(s.b.x,s.b.y);
    ctx.beginPath(); ctx.moveTo(a.x+1.5,a.y+1.5); ctx.lineTo(b.x+1.5,b.y+1.5); ctx.stroke();
  }
  // основная
  ctx.strokeStyle='#4da3ff'; ctx.lineWidth=W;
  for(const s of S.segs){
    const a=toScreen(s.a.x,s.a.y), b=toScreen(s.b.x,s.b.y);
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  // предпросмотр
  if(S.drawing && S.first && S.preview){
    const a=toScreen(S.first.x,S.first.y), b=toScreen(S.preview.x,S.preview.y);
    ctx.strokeStyle='#7fc1ff'; ctx.lineWidth=W; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
}
function updateHUD(a,b){
  if(!a||!b){ hud.style.display='none'; return; }
  const {L,deg}=vecInfo(a,b);
  hudAngle.textContent = `∠ ${Math.round(deg)}°`;
  hudLen.textContent   = `L ${Math.round(L)} мм`;
  hud.style.display='flex';
}
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  drawBG(); // фон без общей трансформации
  // применяем трансформацию сцены (только логически: сетка и трубы рисуются в экранных коорд)
  drawGrid(); drawPipes();
  if(S.drawing && S.first && S.preview) updateHUD(S.first,S.preview);
  else if(S.dragNode){ const L=S.segs[S.dragNode.seg]; updateHUD(L.a,L.b); }
  else hud.style.display='none';
}

// ===== Узлы концов
function rebuildNodes(){
  S.nodes.length=0;
  S.segs.forEach((s,i)=>{
    S.nodes.push({x:s.a.x,y:s.a.y, seg:i, end:'a'});
    S.nodes.push({x:s.b.x,y:s.b.y, seg:i, end:'b'});
  });
}
function pickNodeAt(clientX,clientY){
  const p=toWorld(clientX,clientY);
  const tol=Math.max(10,S.pipe/2)/S.scale;
  let best=null, dmin=1e9;
  for(const n of S.nodes){
    const d=Math.hypot(p.x-n.x,p.y-n.y);
    if(d<tol && d<dmin){ dmin=d; best=n; }
  }
  return best;
}

// ===== Пинч-зум
function pinchBegin(a,b){
  if(S.photoMode){
    S.pinch = { type:'bg', d:Math.hypot(b.x-a.x,b.y-a.y), cx:(a.x+b.x)/2, cy:(a.y+b.y)/2, sc:S.bgs, ox:S.bgx, oy:S.bgy };
  }else{
    S.pinch = { type:'scene', d:Math.hypot(b.x-a.x,b.y-a.y), cx:(a.x+b.x)/2, cy:(a.y+b.y)/2, sc:S.scale, ox:S.ox, oy:S.oy };
  }
}
function pinchMove(a,b){
  if(!S.pinch) return;
  const d=Math.hypot(b.x-a.x,b.y-a.y);
  let s = Math.max(0.2, Math.min(6, S.pinch.sc*(d/S.pinch.d)));
  if(S.pinch.type==='bg'){
    // зум вокруг центра пинча
    const wx = (S.pinch.cx - S.pinch.ox)/S.pinch.sc;
    const wy = (S.pinch.cy - S.pinch.oy)/S.pinch.sc;
    S.bgs = s; S.bgx = S.pinch.cx - wx*s; S.bgy = S.pinch.cy - wy*s;
  }else{
    const wx = (S.pinch.cx - S.pinch.ox)/S.pinch.sc;
    const wy = (S.pinch.cy - S.pinch.oy)/S.pinch.sc;
    S.scale = s; S.ox = S.pinch.cx - wx*s; S.oy = S.pinch.cy - wy*s;
  }
  draw();
}
function pinchEnd(){ S.pinch=null; }

// ===== Ввод
const TAP_MOVE=12, TAP_TIME=350, LONG_MS=450;
let touchMap=new Map();

cv.addEventListener('pointerdown', e=>{
  cv.setPointerCapture(e.pointerId);
  S.tap={x:e.clientX,y:e.clientY,t:performance.now(),moved:false};

  const n=pickNodeAt(e.clientX,e.clientY);
  if(n){
    S.longPress=setTimeout(()=>{ S.dragNode={seg:n.seg,end:n.end}; setStatus(S.editSnap?'Правка (с привязкой)':'Правка (свободно)'); }, LONG_MS);
  }else{
    S.longPress=setTimeout(()=>{}, LONG_MS);
  }
},{passive:false});

cv.addEventListener('pointermove', e=>{
  if(Math.hypot(e.clientX-S.tap.x, e.clientY-S.tap.y)>TAP_MOVE){
    S.tap.moved=true; if(S.longPress){clearTimeout(S.longPress); S.longPress=null;}
  }

  if(S.photoMode && !S.dragNode && S.drawing===false){
    // перетаскиваем ТОЛЬКО фото
    S.bgx += e.movementX; S.bgy += e.movementY; draw(); return;
  }

  if(S.dragNode){
    const L=S.segs[S.dragNode.seg]; if(!L) return;
    let p=toWorld(e.clientX,e.clientY);
    const other=(S.dragNode.end==='a')?L.b:L.a;
    if(S.editSnap) p=snap45(other,p); // иначе свободно
    L[S.dragNode.end]=p; rebuildNodes(); draw();
  }else if(S.drawing && S.first){
    let p=toWorld(e.clientX,e.clientY);
    if(S.snapDraw) p=snap45(S.first,p);
    S.preview=p; draw();
  }
},{passive:false});

cv.addEventListener('pointerup', e=>{
  if(S.longPress){clearTimeout(S.longPress); S.longPress=null;}
  if(S.dragNode){ S.dragNode=null; setStatus('Готов'); draw(); return; }

  const isTap=!S.tap.moved && (performance.now()-S.tap.t<=TAP_TIME);
  if(!isTap) return;

  if(S.drawing){
    const w=toWorld(e.clientX,e.clientY);
    if(!S.first){
      S.first=w; S.preview=null; setStatus('1-я точка: ткни вторую');
    }else{
      let end = S.snapDraw ? snap45(S.first,w) : w;
      // подготовим стыковку: endpoint/tee
      const {end:newEnd, split} = prepareEndWithJunction(S.first,end);
      if(split) splitSegment(split.segIndex, split.point);
      S.segs.push({a:{...S.first}, b:{x:newEnd.x,y:newEnd.y}});
      S.first=null; S.preview=null; S.drawing=false; btnLine.classList.remove('active');
      rebuildNodes(); setStatus('Линия готова. Для новой — снова «Линия».'); draw();
    }
  }
},{passive:false});

// touch: пинч двумя пальцами
cv.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches) touchMap.set(t.identifier,{x:t.clientX,y:t.clientY});
  if(touchMap.size===2){ const [a,b]=[...touchMap.values()]; pinchBegin(a,b); }
},{passive:false});
cv.addEventListener('touchmove', e=>{
  for(const t of e.changedTouches) touchMap.set(t.identifier,{x:t.clientX,y:t.clientY});
  if(touchMap.size===2){ const [a,b]=[...touchMap.values()]; pinchMove(a,b); e.preventDefault(); return; }
  if(S.drawing && S.first && e.touches.length===1){
    const t=e.touches[0]; let p=toWorld(t.clientX,t.clientY); if(S.snapDraw) p=snap45(S.first,p); S.preview=p; draw();
  }
},{passive:false});
cv.addEventListener('touchend', e=>{
  for(const t of e.changedTouches) touchMap.delete(t.identifier);
  if(touchMap.size<2) pinchEnd();
},{passive:false});
cv.addEventListener('touchcancel', e=>{
  for(const t of e.changedTouches) touchMap.delete(t.identifier); pinchEnd();
},{passive:false});

// ===== Кнопки
btnLine.onclick=()=>{ S.drawing=!S.drawing; S.first=null; S.preview=null; btnLine.classList.toggle('active',S.drawing);
  setStatus(S.drawing?'Режим ЛИНИЯ: ткни 1-ю точку':'Готов'); draw(); };
btnUndo.onclick=()=>{ if(S.first){S.first=null; S.preview=null; setStatus('Старт снят'); draw(); return;}
  S.segs.pop(); rebuildNodes(); draw(); setStatus('Отменено'); };

btnCenter.onclick=()=>{ S.scale=1; S.ox=innerWidth/2; S.oy=innerHeight/2; draw(); setStatus('Сцена по центру'); };
btnPhotoCenter.onclick=()=>{ if(!S.img){setStatus('Фото не загружено');return;}
  // вписать фото в экран (по своим осям)
  const k=Math.min(innerWidth/S.iw, innerHeight/S.ih)*0.95;
  S.bgs=k; S.bgx=(innerWidth - S.iw*k)/2; S.bgy=(innerHeight - S.ih*k)/2; draw(); setStatus('Фото по центру'); };
btnSave.onclick=()=>{ const off=document.createElement('canvas'); off.width=cv.width; off.height=cv.height; const o=off.getContext('2d'); o.drawImage(cv,0,0); const a=document.createElement('a'); a.href=off.toDataURL('image/png'); a.download='trace.png'; a.click(); };

btnPhoto.onclick=()=>fileInp.click();
fileInp.onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image();
  img.onload=()=>{
    S.img=img; S.iw=img.naturalWidth; S.ih=img.naturalHeight;
    const k=Math.min(innerWidth/S.iw, innerHeight/S.ih)*0.95;
    S.bgs=k; S.bgx=(innerWidth - S.iw*k)/2; S.bgy=(innerHeight - S.ih*k)/2;
    draw(); setStatus('Фото загружено');
  };
  img.src=url;
};

btnPhotoMode.onclick=()=>{ S.photoMode=!S.photoMode; btnPhotoMode.classList.toggle('active',S.photoMode);
  setStatus(S.photoMode?'Фото-режим: перетаскивай/зумь фото':'Фото-режим выключен'); };

gear.onclick=()=> panel.style.display = panel.style.display==='none' ? 'block' : 'none';
document.addEventListener('pointerdown',e=>{
  if(panel.style.display!=='none' && !panel.contains(e.target) && e.target!==gear) panel.style.display='none';
});
diamInp.oninput=()=>{ S.pipe=+diamInp.value; dVal.textContent=diamInp.value; draw(); };
gridInp.oninput=()=>{ S.grid=+gridInp.value; gVal.textContent=S.grid; draw(); };
snapDraw.onchange=()=>{ S.snapDraw=snapDraw.checked; };
editSnap.onchange=()=>{ S.editSnap=editSnap.checked; };
joinTol.oninput=()=>{ S.joinTol=+joinTol.value; jVal.textContent=S.joinTol; };

// старт
resize();
setStatus('Готов: Линия → 1-й тап → 2-й тап; стыки встык, Т-стыки автоматически. Фото-режим — для перемещения/зума фото.');
})();
</script>
</body>
</html>