<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Pro Trace — холст с рамкой (зум только холста) + фикс второй точки</title>
<style>
  :root{--bg:#ffffff;--fg:#0f1115;--ui:#f2f3f7;--bd:#d9dbe3;--acc:#2979ff}
  *{-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;overflow:hidden}
  #cv{position:fixed;inset:0;touch-action:none}
  .bar{position:fixed;left:10px;top:10px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  .btn{background:var(--ui);border:1px solid var(--bd);color:var(--fg);padding:10px 14px;border-radius:12px;font-weight:700}
  .btn.active{outline:2px solid var(--acc)}
  .zoom{position:fixed;right:10px;top:10px;display:flex;gap:8px;z-index:10}
  .zbtn{background:#fff;border:1px solid var(--bd);border-radius:12px;padding:10px 14px;font-weight:800}
  #status{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.65);color:#fff;padding:8px 12px;border-radius:10px;font-size:14px;z-index:11}
  #file{display:none}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine"  class="btn">Линия</button>
    <button id="btnUndo"  class="btn">Назад</button>
    <button id="btnPhoto" class="btn">Фото</button>
    <button id="btnCenter" class="btn">Центр</button>
    <button id="btnSave"  class="btn">Сохранить</button>
  </div>
  <div class="zoom">
    <button id="btnMinus" class="zbtn">−</button>
    <button id="btnPlus"  class="zbtn">+</button>
  </div>

  <input id="file" type="file" accept="image/*"/>
  <div id="status">Линия → 1-й тап (точка видна) → 2-й тап (линия). Зум/пан — только холст (в рамке).</div>

<script>
(()=>{
// ===== Холст с рамкой (stageRect)
const S={
  // stage rect вычисляется на resize
  stage:{x:8,y:64,w:0,h:0,b:1}, // b=толщина рамки
  // трансформ мира внутри stage (пан/зум)
  scale:1, minS:.2, maxS:8, tx:0, ty:0,
  // фон-фото (в мировых единицах)
  img:null, iw:0, ih:0, bgX:0, bgY:0, bgS:1,
  // чертёж
  pipe:40, segs:[],
  // рисование
  state:'idle', first:null, preview:null,
  // ввод
  pointers:new Map(), pinch:null, isPanning:false, panPrev:null,
  // узлы
  nodes:[],
  // защита
  cooldownUntil:0,
  // визуал
  lockEndpoint:null
};

const END_PX=24;     // липкий радиус торца (экран)
const JOIN_PX=14;    // привязка к трубе (экран)
const MIN_SEG_PX=16; // минимальная длина отрезка (экран)

const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const btnLine=byId('btnLine'), btnUndo=byId('btnUndo'), btnPhoto=byId('btnPhoto');
const btnCenter=byId('btnCenter'), btnSave=byId('btnSave');
const btnPlus=byId('btnPlus'), btnMinus=byId('btnMinus');
const fileInp=byId('file'); const statusEl=byId('status');
function byId(id){return document.getElementById(id)}
const setStatus=t=>statusEl.textContent='Статус: '+t;

// ===== Размер и stageRect
function computeStage(){
  const m=8, top=60; // отступы и запас под кнопки
  S.stage.x=m; S.stage.y=top; S.stage.w=innerWidth-2*m; S.stage.h=innerHeight-top-m;
  if(S.stage.w<80||S.stage.h<80){ S.stage.w=innerWidth-2*m; S.stage.h=innerHeight-2*m; S.stage.y=m; }
  // центрируем мир в stage
  if(S.tx===0 && S.ty===0){ S.tx=S.stage.w/2; S.ty=S.stage.h/2; }
}
function resize(){
  const dpr=Math.max(1,devicePixelRatio||1);
  cv.width=Math.round(innerWidth*dpr); cv.height=Math.round(innerHeight*dpr);
  cv.style.width=innerWidth+'px'; cv.style.height=innerHeight+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  computeStage();
  draw();
}
addEventListener('resize',resize,{passive:true});

// ===== Координаты c учётом stageRect
function toScreen(x,y){ // world->screen
  return {x: S.stage.x + x*S.scale + S.tx, y: S.stage.y + y*S.scale + S.ty};
}
function toWorld(sx,sy){ // screen->world
  return {x: (sx - S.stage.x - S.tx)/S.scale, y: (sy - S.stage.y - S.ty)/S.scale};
}
function inStage(sx,sy){
  return sx>=S.stage.x && sx<=S.stage.x+S.stage.w && sy>=S.stage.y && sy<=S.stage.y+S.stage.h;
}

// ===== Математика
function dot(a,b){return a.x*b.x+a.y*b.y;} function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};} function scale(v,k){return {x:v.x*k,y:v.y*k};}
function len(v){return Math.hypot(v.x,v.y);} function clamp01(t){return Math.max(0,Math.min(1,t));}
function snap45(base,p){ const dx=p.x-base.x,dy=p.y-base.y,L=Math.hypot(dx,dy); if(!L)return p;
  const step=Math.PI/4, s=Math.round(Math.atan2(dy,dx)/step)*step; return {x:base.x+Math.cos(s)*L, y:base.y+Math.sin(s)*L};}
function projectPointOnSeg(P,A,B){const v=sub(B,A);const L2=dot(v,v)||1;let t=dot(sub(P,A),v)/L2; t=clamp01(t); const Q=add(A,scale(v,t)); return {Q,t,dist:len(sub(P,Q))};}
function segIntersection(a1,a2,b1,b2){const r=sub(a2,a1),s=sub(b2,b1);const rxs=r.x*s.y-r.y*s.x; if(Math.abs(rxs)<1e-12) return null;
  const t=((b1.x-a1.x)*s.y-(b1.y-a1.y)*s.x)/rxs; const u=((b1.x-a1.x)*r.y-(b1.y-a1.y)*r.x)/rxs;
  if(t>=0&&t<=1&&u>=0&&u<=1) return {p:add(a1,scale(r,t)),ta:t,tb:u}; return null;}

// ===== Привязки (экранные пиксели)
function pickEndpointAt(sx,sy){
  let best=null, d2min=1e9;
  for(const n of S.nodes){
    const p=toScreen(n.x,n.y); const dx=sx-p.x, dy=sy-p.y; const d2=dx*dx+dy*dy;
    if(d2<END_PX*END_PX && d2<d2min){ d2min=d2; best=n; }
  }
  return best;
}
function pickPointOnSegment(sx,sy){ // для Т-стыка
  let best=null, dmin=1e9;
  for(let i=0;i<S.segs.length;i++){
    const s=S.segs[i]; const A=toScreen(s.a.x,s.a.y), B=toScreen(s.b.x,s.b.y);
    const vx=B.x-A.x, vy=B.y-A.y, L2=vx*vx+vy*vy; if(!L2) continue;
    let t=((sx-A.x)*vx+(sy-A.y)*vy)/L2; t=Math.max(0,Math.min(1,t));
    const px=A.x+vx*t, py=A.y+vy*t, d=Math.hypot(px-sx,py-sy);
    if(d<=JOIN_PX && d<dmin){ dmin=d; best={segIndex:i, point:toWorld(px,py)}; }
  }
  return best;
}
function endWithJunction(start,end){
  const tolW=JOIN_PX/S.scale; let bestSnap=null,bestCross=null;
  for(const s of S.segs){ for(const P of [s.a,s.b]){ const pr=projectPointOnSeg(P,start,end);
    if(pr.dist<=tolW){ const d=pr.t*len(sub(end,start)); if(!bestSnap||d<bestSnap.dist) bestSnap={p:P,dist:d}; } } }
  for(let i=0;i<S.segs.length;i++){ const s=S.segs[i]; const inter=segIntersection(start,end,s.a,s.b);
    if(inter && inter.tb>1e-4 && inter.tb<1-1e-4){ const d=inter.ta*len(sub(end,start)); if(!bestCross||d<bestCross.dist) bestCross={p:inter.p,segIndex:i,dist:d}; } }
  if(bestCross && (!bestSnap || bestCross.dist<bestSnap.dist)) return {end:bestCross.p, split:bestCross};
  if(bestSnap) return {end:{x:bestSnap.p.x,y:bestSnap.p.y}, split:null};
  return {end,split:null};
}
function splitSegment(i,p){
  const s=S.segs[i]; if(!s) return; if(len(sub(p,s.a))<1e-6||len(sub(p,s.b))<1e-6) return;
  const A={x:s.a.x,y:s.a.y}, B={x:s.b.x,y:s.b.y};
  S.segs[i]={a:A,b:{x:p.x,y:p.y}}; S.segs.splice(i+1,0,{a:{x:p.x,y:p.y}, b:B});
}
function rebuildNodes(){ S.nodes.length=0; S.segs.forEach((s,i)=>{ S.nodes.push({x:s.a.x,y:s.a.y,seg:i,end:'a'}); S.nodes.push({x:s.b.x,y:s.b.y,seg:i,end:'b'}); });}

// ===== Рендер
function drawStageFrame(){
  // фон
  ctx.fillStyle='#fff'; ctx.fillRect(S.stage.x, S.stage.y, S.stage.w, S.stage.h);
  // рамка
  ctx.strokeStyle='#cfd3dc'; ctx.lineWidth=S.stage.b; ctx.strokeRect(S.stage.x+0.5, S.stage.y+0.5, S.stage.w-1, S.stage.h-1);
}
function drawWorldContent(){
  // клип внутрь холста
  ctx.save();
  ctx.beginPath(); ctx.rect(S.stage.x, S.stage.y, S.stage.w, S.stage.h); ctx.clip();
  // мировая матрица
  ctx.setTransform(S.scale,0,0,S.scale, S.stage.x+S.tx, S.stage.y+S.ty);

  // фото
  if(S.img) ctx.drawImage(S.img, S.bgX, S.bgY, S.iw*S.bgS, S.ih*S.bgS);

  // трубы
  const W=Math.max(2,S.pipe*S.scale*0.45);
  ctx.lineCap='butt'; ctx.lineJoin='round'; ctx.miterLimit=6;
  // тень
  ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.lineWidth=W+3;
  for(const s of S.segs){ ctx.beginPath(); ctx.moveTo(s.a.x+1/S.scale,s.a.y+1/S.scale); ctx.lineTo(s.b.x+1/S.scale,s.b.y+1/S.scale); ctx.stroke(); }
  // основная
  ctx.strokeStyle='#2f8cff'; ctx.lineWidth=W;
  for(const s of S.segs){ ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke(); }

  // предпросмотр линии
  if(S.state==='awaitSecond'&&S.first&&S.preview){
    ctx.strokeStyle='#7db6ff'; ctx.lineWidth=W;
    ctx.beginPath(); ctx.moveTo(S.first.x,S.first.y); ctx.lineTo(S.preview.x,S.preview.y); ctx.stroke();
  }

  // маркеры
  if(S.first){ ctx.fillStyle='#ff3b30'; ctx.beginPath(); ctx.arc(S.first.x,S.first.y, 5/S.scale, 0, Math.PI*2); ctx.fill(); }
  if(S.lockEndpoint){ ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(S.lockEndpoint.x,S.lockEndpoint.y, 6/S.scale, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='#2f8cff'; ctx.lineWidth=2/S.scale; ctx.beginPath(); ctx.arc(S.lockEndpoint.x,S.lockEndpoint.y, 8/S.scale, 0, Math.PI*2); ctx.stroke(); }

  ctx.restore();
}
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  drawStageFrame();
  drawWorldContent();
}

// ===== Зум
function zoomAtScreen(f, sx, sy){
  const ns=Math.max(S.minS,Math.min(S.maxS,S.scale*f));
  const wx=(sx - S.stage.x - S.tx)/S.scale;
  const wy=(sy - S.stage.y - S.ty)/S.scale;
  S.scale=ns;
  S.tx = sx - S.stage.x - wx*ns;
  S.ty = sy - S.stage.y - wy*ns;
}
function zoomAtCenter(f){
  const cx=S.stage.x+S.stage.w/2, cy=S.stage.y+S.stage.h/2;
  zoomAtScreen(f,cx,cy);
}

// ===== Pointer Events
const allow = e => (e.pointerType==='touch'||e.pointerType==='pen'||e.pointerType==='unknown');
function updPtr(e){ S.pointers.set(e.pointerId,{id:e.pointerId,x:e.clientX,y:e.clientY}); }
function delPtr(e){ S.pointers.delete(e.pointerId); }
function centroid(){ const a=[...S.pointers.values()]; if(a.length<2) return null; return {x:(a[0].x+a[1].x)/2, y:(a[0].y+a[1].y)/2}; }
function distance(){ const a=[...S.pointers.values()]; if(a.length<2) return 0; return Math.hypot(a[1].x-a[0].x,a[1].y-a[0].y); }
function pinchBegin(){ const c=centroid(), d=distance(); if(!c||!d) return; S.pinch={cx:c.x,cy:c.y,d,sc:S.scale,tx:S.tx,ty:S.ty}; }
function pinchMove(){ if(!S.pinch) return; const c=centroid(), d=distance(); if(!c||!d) return;
  const f = d/S.pinch.d; zoomAtScreen(f, c.x, c.y); draw();
}
function pinchEnd(){ S.pinch=null; }

cv.addEventListener('pointerdown', e=>{
  if(!allow(e)) return;
  updPtr(e); cv.setPointerCapture(e.pointerId);

  // вне холста — игнор
  if(!inStage(e.clientX,e.clientY)) return;

  if(S.pointers.size===2){ pinchBegin(); return; }

  // не рисуем — панорамирование холста одним пальцем
  if(S.state==='idle'){ S.isPanning=true; S.panPrev={x:e.clientX,y:e.clientY}; return; }

  // === Режим рисования ===
  if(S.state==='awaitFirst'){
    // 1) липкий торец
    const ep=pickEndpointAt(e.clientX,e.clientY);
    if(ep){ S.first={x:ep.x,y:ep.y}; S.lockEndpoint={x:ep.x,y:ep.y}; S.preview=null; draw(); return; }
    // 2) по трубе — Т-стык
    const ps=pickPointOnSegment(e.clientX,e.clientY);
    if(ps){ S.first={x:ps.point.x,y:ps.point.y}; splitSegment(ps.segIndex, ps.point); rebuildNodes(); S.lockEndpoint=null; draw(); return; }
    // 3) свободная точка
    S.first=toWorld(e.clientX,e.clientY); S.lockEndpoint=null; draw(); return;
  }

  if(S.state==='awaitSecond' && S.first){
    // показываем вторую точку СРАЗУ при касании (чтоб было видно)
    let p=toWorld(e.clientX,e.clientY);
    p=snap45(S.first,p);
    S.preview=p; draw();
  }
},{passive:false});

cv.addEventListener('pointermove', e=>{
  if(!allow(e)) return;
  const prev=S.pointers.get(e.pointerId); updPtr(e);

  if(S.pointers.size===2){ pinchMove(); return; }

  if(S.isPanning && prev){
    S.tx += (e.clientX - prev.x);
    S.ty += (e.clientY - prev.y);
    draw(); return;
  }

  if(S.state==='awaitSecond' && S.first && inStage(e.clientX,e.clientY)){
    let p=toWorld(e.clientX,e.clientY);
    p=snap45(S.first,p);
    S.preview=p; draw(); return;
  }
},{passive:false});

cv.addEventListener('pointerup', e=>{
  if(!allow(e)){ delPtr(e); return; }
  if(S.pointers.size<2 && S.pinch) pinchEnd();

  if(S.isPanning){ S.isPanning=false; S.panPrev=null; delPtr(e); return; }
  if(!inStage(e.clientX,e.clientY)){ delPtr(e); return; }

  if(S.state==='awaitSecond' && S.first){
    let end=toWorld(e.clientX,e.clientY);
    end=snap45(S.first,end);

    // коротыш?
    const a=toScreen(S.first.x,S.first.y), b=toScreen(end.x,end.y);
    if(Math.hypot(b.x-a.x,b.y-a.y) < MIN_SEG_PX){ setStatus('Слишком коротко — ткни подальше'); delPtr(e); return; }

    const {end:newEnd, split}=endWithJunction(S.first,end); if(split) splitSegment(split.segIndex,split.p);
    S.segs.push({a:{...S.first}, b:{x:newEnd.x,y:newEnd.y}});
    S.first=null; S.preview=null; S.lockEndpoint=null; S.state='idle'; btnLine.classList.remove('active');
    rebuildNodes(); setStatus('Линия готова. Для новой — «Линия».'); draw(); delPtr(e); return;
  }

  delPtr(e);
},{passive:false});

cv.addEventListener('pointercancel', e=>{
  S.isPanning=false; S.panPrev=null; delPtr(e); if(S.pinch) pinchEnd();
});

// ===== Кнопки
btnLine.onclick=()=>{ S.state = (S.state==='idle') ? 'awaitFirst' : 'idle';
  S.first=null; S.preview=null; S.lockEndpoint=null;
  btnLine.classList.toggle('active', S.state!=='idle');
  setStatus(S.state!=='idle'?'Рисую: ткни 1-ю точку внутри холста':'Готов');
  draw();
};
btnUndo.onclick=()=>{ if(S.state==='awaitSecond'&&S.first){ S.state='awaitFirst'; S.first=null; S.preview=null; S.lockEndpoint=null; setStatus('Старт снят'); draw(); return; }
  S.segs.pop(); rebuildNodes(); draw(); setStatus('Отменено'); };

btnPlus.onclick=()=>{ zoomAtCenter(1.2); draw(); };
btnMinus.onclick=()=>{ zoomAtCenter(1/1.2); draw(); };
function zoomAtCenter(f){ zoomAtScreen(f, S.stage.x+S.stage.w/2, S.stage.y+S.stage.h/2); }

btnCenter.onclick=()=>{ S.scale=1; S.tx=S.stage.w/2; S.ty=S.stage.h/2; draw(); setStatus('Холст по центру'); };
btnSave.onclick=()=>{ const off=document.createElement('canvas'); off.width=cv.width; off.height=cv.height; const o=off.getContext('2d');
  // рендерим фон и трубы так же, как на экране
  o.drawImage(cv,0,0); const a=document.createElement('a'); a.href=off.toDataURL('image/png'); a.download='trace.png'; a.click(); };

btnPhoto.onclick=()=>fileInp.click();
fileInp.onchange=e=>{
  const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); const img=new Image();
  img.onload=()=>{
    S.img=img; S.iw=img.naturalWidth; S.ih=img.naturalHeight;
    // вписываем фото в текущий видимый мир (чтобы потом зум/пан шли вместе с холстом)
    const worldW = S.stage.w / S.scale, worldH = S.stage.h / S.scale;
    const k = Math.min(worldW/S.iw, worldH/S.ih)*0.95;
    S.bgS = k;
    S.bgX = - (S.iw*S.bgS)/2;
    S.bgY = - (S.ih*S.bgS)/2;
    draw(); setStatus('Фото загружено: зум/пан — только холст');
  };
  img.src=url;
};

// ===== Старт
resize(); rebuildNodes();
setStatus('Готов: рамка — это холст. Зум/пан двигают ТОЛЬКО холст. «Линия» → 1-я точка → 2-я.');
})();
</script>
</body>
</html>