<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî v852-check-return</title>
<style>
  :root{--violet:#6b1dff; --violet2:#7c5bff}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{position:fixed;inset:0;display:block;width:100vw;height:100vh;background:#fff;touch-action:none;-webkit-user-select:none;user-select:none}
  .bar{position:fixed;left:8px;top:8px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
  .btn{height:44px;padding:0 14px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:linear-gradient(180deg,#8c8c8c,#6a6a6a)}
  .status{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.70);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;z-index:11;max-width:92vw}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine"  class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnValve" class="btn ghost">–ö—Ä–∞–Ω</button>
    <button id="btnCheck" class="btn ghost">–ö–ª–∞–ø–∞–Ω</button>
    <button id="btnPump"  class="btn ghost">–ù–∞—Å–æ—Å</button>
    <button id="btnUndo"  class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnHand"  class="btn ghost">üñê –†—É–∫–∞</button>
  </div>

  <div id="status" class="status">–°—Ç–∞—Ç—É—Å: –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>

<script>
(()=>{"use strict";

/* ===== –±–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===== */
const DPR=Math.max(1,window.devicePixelRatio||1);
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d',{alpha:false});
const statusEl=document.getElementById('status');

window.addEventListener('error', e=>{
  statusEl.textContent='–°—Ç–∞—Ç—É—Å: –û—à–∏–±–∫–∞ ‚Äî '+(e.message||'unknown');
});

const view={tx:0,ty:0,scale:1}; // –ø–∞–Ω (–±–µ–∑ –∑—É–º–∞)
function fit(){ cv.width=Math.round(innerWidth*DPR); cv.height=Math.round(innerHeight*DPR); need(); }
addEventListener('resize',fit,{passive:true});

/* ===== –¥–∞–Ω–Ω—ã–µ —Å—Ü–µ–Ω—ã ===== */
const segs=[];           // {a:{x,y}, b:{x,y}}
const comps=[];          // {segIndex,t,type}
const stack=[];          // 'seg' | 'comp'
let mode='line';         // line | place | hand
let currentComp='valve'; // valve | check | pump
let first=null, preview=null;

/* —Ç–æ–ª—â–∏–Ω–∞ —Ç—Ä—É–±—ã = –≤–∏–∑—É–∞–ª—å–Ω–∞—è ¬´–µ–¥–∏–Ω–∏—Ü–∞¬ª —Ä–∞–∑–º–µ—Ä–∞ –∞—Ä–º–∞—Ç—É—Ä—ã */
const params={ linePx:10, lineColor:'#1f6bff', compScale:1.15 };

/* ===== —É—Ç–∏–ª–∏—Ç—ã ===== */
function s2w(sx,sy){ return { x:(sx-view.tx)/view.scale, y:(sy-view.ty)/view.scale }; }
function w2s(x,y){ return { x:x*view.scale+view.tx, y:y*view.scale+view.ty }; }
function darker(hex,k=0.45){
  const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return '#333';
  let [r,g,b]=[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)];
  r=Math.max(0,Math.floor(r*(1-k))); g=Math.max(0,Math.floor(g*(1-k))); b=Math.max(0,Math.floor(b*(1-k)));
  return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
}
function segGeom(seg){ const vx=seg.b.x-seg.a.x, vy=seg.b.y-seg.a.y; const L=Math.hypot(vx,vy)||1; return {vx,vy,L,nx:vx/L,ny:vy/L}; }
function compBasis(seg,t){ const g=segGeom(seg); return {x:seg.a.x+g.nx*g.L*t, y:seg.a.y+g.ny*g.L*t, ux:g.nx,uy:g.ny,nx:-g.ny,ny:g.nx}; }
function findNearestSegment(sx,sy,maxDistPx=28){ let best=-1,bd=1e9,bt=0;
  for(let i=0;i<segs.length;i++){ const s=segs[i]; const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y);
    const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy; if(!len2) continue;
    const t=Math.max(0,Math.min(1,((sx-A.x)*vx+(sy-A.y)*vy)/len2));
    const px=A.x+vx*t, py=A.y+vy*t, d=Math.hypot(px-sx,py-sy);
    if(d<bd){ bd=d; best=i; bt=t; }
  }
  return (best!==-1 && bd<=maxDistPx)?{segIndex:best,t:bt}:null;
}

/* ===== –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ===== */
function badgeWorld(wx,wy,txt){
  const p=w2s(wx,wy);
  ctx.setTransform(1,0,0,1,0,0); ctx.font='700 11px system-ui,-apple-system,Segoe UI,Roboto';
  const pad=6,h=18,r=7,w=ctx.measureText(txt).width+pad*2,x=p.x+8,y=p.y-8-h,rr=Math.min(r,w/2,h/2);
  ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#111'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#111'; ctx.textBaseline='middle'; ctx.fillText(txt,x+pad,y+h/2);
}

function drawSegments(){
  ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
  const col=params.lineColor, sh=darker(col,0.45);
  for(const s of segs){
    ctx.strokeStyle=sh; ctx.globalAlpha=.75; ctx.lineWidth=(params.linePx+2)/view.scale;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    ctx.strokeStyle=col; ctx.globalAlpha=1; ctx.lineWidth=params.linePx/view.scale;
    ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
  }
}

/* ‚Äî‚Äî‚Äî –ö—Ä–∞–Ω (—à–∞—Ä–æ–≤—ã–π, –∫–∞–∫ —Ä–∞–Ω—å—à–µ) ‚Äî‚Äî‚Äî */
function drawValve(seg,t){
  const b=compBasis(seg,t), base=params.linePx*params.compScale;
  const bodyLen=base*10.5, bodyR=base*2.6, coneL=base*3.2, pipeR=base*1.4, ballR=base*2.0, neckH=base*2.6, neckR=base*0.9, handleL=base*6.5, handleW=base*0.9;
  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;
  const L={x:b.x-ux*bodyLen/2,y:b.y-uy*bodyLen/2}, R={x:b.x+ux*bodyLen/2,y:b.y+uy*bodyLen/2};
  const P1={x:L.x-ux*coneL,y:L.y-uy*coneL}, P2={x:R.x+ux*coneL,y:R.y+uy*coneL};
  ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(L.x-nx*bodyR, L.y-ny*bodyR); ctx.lineTo(R.x-nx*bodyR, R.y-ny*bodyR);
  ctx.arc(R.x,R.y,bodyR, Math.atan2(-ny,-nx), Math.atan2(ny,-nx), false);
  ctx.lineTo(L.x+nx*bodyR, L.y+ny*bodyR);
  ctx.arc(L.x,L.y,bodyR, Math.atan2(ny,nx), Math.atan2(-ny,nx), false);
  ctx.closePath(); ctx.fillStyle='#6b1dff'; ctx.fill(); ctx.lineWidth=2/view.scale; ctx.strokeStyle='#2b145f'; ctx.stroke();
  // –∫–æ–Ω—É—Å—ã –∫ —Ç—Ä—É–±–µ
  ctx.beginPath(); ctx.moveTo(P1.x-nx*pipeR,P1.y-ny*pipeR); ctx.lineTo(L.x-nx*bodyR,L.y-ny*bodyR);
  ctx.lineTo(L.x+nx*bodyR,L.y+ny*bodyR); ctx.lineTo(P1.x+nx*pipeR,P1.y+ny*pipeR); ctx.closePath(); ctx.fillStyle='#6b1dff'; ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(R.x-nx*bodyR,R.y-ny*bodyR); ctx.lineTo(P2.x-nx*pipeR,P2.y-ny*pipeR);
  ctx.lineTo(P2.x+nx*pipeR,P2.y+ny*pipeR); ctx.lineTo(R.x+nx*bodyR,R.y+ny*bodyR); ctx.closePath(); ctx.fillStyle='#6b1dff'; ctx.fill(); ctx.stroke();
  // —à–∞—Ä –∏ —Ä—É—á–∫–∞
  ctx.beginPath(); ctx.arc(b.x,b.y,ballR,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.strokeStyle='#1b1b1b'; ctx.stroke();
  const top={x:b.x+nx*bodyR,y:b.y+ny*bodyR}, neckTop={x:top.x+nx*neckH,y:top.y+ny*neckH};
  ctx.beginPath(); ctx.arc(b.x,b.y,neckR,0,Math.PI*2); ctx.lineWidth=2/view.scale; ctx.strokeStyle='#1b1b1b'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(top.x,top.y); ctx.lineTo(neckTop.x,neckTop.y); ctx.stroke();
  const hw=handleW/2; ctx.fillStyle='#111';
  ctx.beginPath(); ctx.moveTo(neckTop.x-nx*hw, neckTop.y-ny*hw);
  ctx.lineTo(neckTop.x+ux*handleL-nx*hw, neckTop.y+uy*handleL-ny*hw);
  ctx.lineTo(neckTop.x+ux*handleL+nx*hw, neckTop.y+uy*handleL+ny*hw);
  ctx.lineTo(neckTop.x+nx*hw, neckTop.y+ny*hw); ctx.closePath(); ctx.fill();
  ctx.restore(); badgeWorld(b.x,b.y,'BALL');
}

/* ‚Äî‚Äî‚Äî –ö–ª–∞–ø–∞–Ω (–≤–µ—Ä–Ω—É–ª–∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω—ã–π –≤–∏–¥) ‚Äî‚Äî‚Äî
   –î–≤–µ —Ç–æ–Ω–∫–∏–µ –ø–æ–ª–æ—Å–∫–∏-—Ñ–ª–∞–Ω—Ü–∞ (–≤–∏–∑—É–∞–ª—å–Ω–æ ~2 px –ø—Ä–∏ 100%*)
   –º–µ–∂–¥—É –Ω–∏–º–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫, –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ¬´–≤–≤–µ—Ä—Ö¬ª –ø–æ –Ω–æ—Ä–º–∞–ª–∏ —Ç—Ä—É–±—ã.
   *–¢–æ—á–Ω–æ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –ª—é–±–æ–º –º–∞—Å—à—Ç–∞–±–µ, —Ç.–∫. –ª–∏–Ω–∏–∏ —Ä–∏—Å—É–µ–º —Å —É—á—ë—Ç–æ–º view.scale. */
function drawCheck(seg,t){
  const b=compBasis(seg,t);
  const base=params.linePx*params.compScale;       // –±–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä = —Ç–æ–ª—â–∏–Ω–∞ —Ç—Ä—É–±—ã
  const gap     = base*6.5;                         // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ñ–ª–∞–Ω—Ü–∞–º–∏ (–∑–æ–Ω–∞ —Å–∏–º–≤–æ–ª–∞)
  const flangeL = base*5.0;                         // –¥–ª–∏–Ω–∞ –∫–∞–∂–¥–æ–π –ø–æ–ª–æ—Å–∫–∏-—Ñ–ª–∞–Ω—Ü–∞
  const triHalf = base*1.75;                        // –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
  const triRise = base*2.4;                         // –≤—ã—Å–æ—Ç–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ø–æ –Ω–æ—Ä–º–∞–ª–∏
  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;

  // –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–æ–≤ —Ñ–ª–∞–Ω—Ü–µ–≤
  const Lc={x:b.x-ux*gap/2, y:b.y-uy*gap/2};
  const Rc={x:b.x+ux*gap/2, y:b.y+uy*gap/2};

  ctx.save();
  ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);

  // –§–ª–∞–Ω—Ü—ã ‚Äî —É–∑–∫–∏–µ –ø–æ–ª–æ—Å–∫–∏ –í–î–û–õ–¨ –æ—Å–∏ —Ç—Ä—É–±—ã.
  ctx.strokeStyle='#111';
  ctx.lineCap='butt';
  ctx.lineWidth=Math.max(1.5/view.scale, 2.0/view.scale); // ‚âà 2 px –Ω–∞ —ç–∫—Ä–∞–Ω–µ
  // –ª–µ–≤—ã–π
  ctx.beginPath();
  ctx.moveTo(Lc.x-ux*flangeL/2, Lc.y-uy*flangeL/2);
  ctx.lineTo(Lc.x+ux*flangeL/2, Lc.y+uy*flangeL/2);
  ctx.stroke();
  // –ø—Ä–∞–≤—ã–π
  ctx.beginPath();
  ctx.moveTo(Rc.x-ux*flangeL/2, Rc.y-uy*flangeL/2);
  ctx.lineTo(Rc.x+ux*flangeL/2, Rc.y+uy*flangeL/2);
  ctx.stroke();

  // –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫: –æ—Å–Ω–æ–≤–∞–Ω–∏–µ –ø–æ–ø–µ—Ä—ë–∫ —Ç—Ä—É–±—ã, –≤–µ—Ä—à–∏–Ω–∞ ‚Äî ¬´–≤–≤–µ—Ä—Ö¬ª –ø–æ –Ω–æ—Ä–º–∞–ª–∏ (nx,ny).
  const A={x:b.x - nx*triHalf, y:b.y - ny*triHalf};     // –ª–µ–≤–æ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
  const B={x:b.x + nx*triHalf, y:b.y + ny*triHalf};     // –ø—Ä–∞–≤–æ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
  const T={x:b.x + nx*0 + nx*0 + 0*ux + nx*0,           // —Ü–µ–Ω—Ç—Ä + –ø–æ–¥—ä—ë–º –ø–æ –Ω–æ—Ä–º–∞–ª–∏
           y:b.y + ny*0}; // –≤—Ä–µ–º–µ–Ω–æ, –Ω–∏–∂–µ —Ä–µ–∞–ª—å–Ω—ã–π tip
  const tip={x:b.x + nx*0 + 0*ux + (nx*0) + 0, y:b.y + ny*0}; // –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (–¥–ª—è —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏)

  const V={x:b.x + nx*0 + ux*0 + nx*0 + 0, y:b.y + ny*0}; // —Ü–µ–Ω—Ç—Ä
  const Tip={x:b.x + nx*0 + 0, y:b.y + ny*0};             // —Ü–µ–Ω—Ç—Ä (–µ—â—ë —Ä–∞–∑, —á–∏—Å—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã)

  const realTip={x:b.x + nx*0 + nx*0 + 0, y:b.y + ny*0};  // —Ü–µ–Ω—Ç—Ä, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏

  const TIP={x:b.x + nx*0 + 0, y:b.y + ny*0}; // —Ü–µ–Ω—Ç—Ä (—Ñ–∏–Ω–∞–ª—å–Ω–æ –Ω–µ –Ω—É–∂–µ–Ω)

  // —Ä–µ–∞–ª—å–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞:
  const TR={x:b.x + nx*0 + 0, y:b.y + ny*triRise};

  ctx.fillStyle='#6b1dff';
  ctx.strokeStyle='#2b145f';
  ctx.lineWidth=1.6/view.scale;
  ctx.beginPath();
  ctx.moveTo(TR.x,TR.y);
  ctx.lineTo(B.x,B.y);
  ctx.lineTo(A.x,A.y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.restore();
  badgeWorld(b.x,b.y,'CHECK');
}

/* ‚Äî‚Äî‚Äî –ù–∞—Å–æ—Å ‚Äî‚Äî‚Äî */
function drawPump(seg,t){
  const b=compBasis(seg,t), base=params.linePx*params.compScale;
  const volR=base*4.2, flLen=base*2.6, flHalf=base*1.6, motorW=base*5.2, motorH=base*7.2;
  const ux=b.ux, uy=b.uy, nx=b.nx, ny=b.ny;
  const Lc={x:b.x-ux*(volR+flLen*0.9), y:b.y-uy*(volR+flLen*0.9)}, Rc={x:b.x+ux*(volR+flLen*0.9), y:b.y+uy*(volR+flLen*0.9)};
  ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.fillStyle='#6b1dff'; ctx.strokeStyle='#2b145f'; ctx.lineWidth=2.0/view.scale;
  ctx.beginPath(); ctx.arc(b.x,b.y,volR,0,Math.PI*2); ctx.fill(); ctx.stroke();
  function flange(cx,cy){
    const ax=ux*(flLen/2), ay=uy*(flLen/2), px=nx*flHalf, py=ny*flHalf;
    ctx.beginPath(); ctx.moveTo(cx-ax-px, cy-ay-py); ctx.lineTo(cx+ax-px, cy+ay-py); ctx.lineTo(cx+ax+px, cy+ay+py); ctx.lineTo(cx-ax+px, cy-ay+py);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
  flange(Lc.x,Lc.y); flange(Rc.x,Rc.y);
  const mL={x:b.x + nx*(volR*0.6) - nx*(motorW/2), y:b.y + ny*(volR*0.6) - ny*(motorW/2)};
  const mR={x:b.x + nx*(volR*0.6) + nx*(motorW/2), y:b.y + ny*(volR*0.6) + ny*(motorW/2)};
  const mT={x:mR.x + ux*motorH, y:mR.y + uy*motorH};
  const mB={x:mL.x + ux*motorH, y:mL.y + uy*motorH};
  ctx.beginPath(); ctx.moveTo(mL.x,mL.y); ctx.lineTo(mB.x,mB.y); ctx.lineTo(mT.x,mT.y); ctx.lineTo(mR.x,mR.y); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.restore(); badgeWorld(b.x,b.y,'PUMP');
}

function draw(){
  // —Ñ–æ–Ω
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);

  // —Ç—Ä—É–±—ã
  drawSegments();

  // –∞—Ä–º–∞—Ç—É—Ä–∞
  for(const c of comps){
    const seg=segs[c.segIndex]; if(!seg) continue;
    if(c.type==='valve') drawValve(seg,c.t);
    else if(c.type==='check') drawCheck(seg,c.t);
    else if(c.type==='pump') drawPump(seg,c.t);
  }

  // –ø—Ä–µ–≤—å—é –ª–∏–Ω–∏–∏
  if(first && preview){
    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.setLineDash([12/view.scale,8/view.scale]); ctx.strokeStyle=params.lineColor; ctx.lineWidth=Math.max(3,params.linePx-2)/view.scale;
    ctx.beginPath(); ctx.moveTo(first.x,first.y); ctx.lineTo(preview.x,preview.y); ctx.stroke(); ctx.setLineDash([]);
  }
  if(first){
    const p=w2s(first.x,first.y); ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#ff3b30'; ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }
}
let raf=0, dirty=false; function need(){ dirty=true; if(!raf){ raf=requestAnimationFrame(()=>{ raf=0; if(dirty){ dirty=false; draw(); } }); } }

/* ===== –≤–≤–æ–¥ ===== */
const pointers=new Map();
let isPanning=false, panLast=null;

function canvasXY(e){ const r=cv.getBoundingClientRect(); return { sx:(e.clientX-r.left)*(cv.width/r.width), sy:(e.clientY-r.top)*(cv.height/r.height) }; }

cv.addEventListener('pointerdown', e=>{
  e.preventDefault();
  const {sx,sy}=canvasXY(e);
  pointers.set(e.pointerId,{sx,sy});

  if(mode==='hand'){
    isPanning=true; panLast={sx,sy};
    statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π';
    return;
  }

  const W=s2w(sx,sy);
  if(mode==='line'){
    if(!first){ first=W; preview=null; need(); statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ø–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞'; }
    else{ segs.push({a:first,b:W}); stack.push('seg'); first=null; preview=null; need(); statusEl.textContent='–°—Ç–∞—Ç—É—Å: —Å–µ–≥–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω'; }
  }else if(mode==='place'){
    const near=findNearestSegment(sx,sy,28*DPR);
    if(near){ comps.push({segIndex:near.segIndex,t:near.t,type:currentComp}); stack.push('comp'); mode='hand'; need(); statusEl.textContent='–°—Ç–∞—Ç—É—Å: —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Å—Ç–∞–≤–ª–µ–Ω'; }
    else{ statusEl.textContent='–°—Ç–∞—Ç—É—Å: —Ç–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏'; }
  }
},{passive:false});

cv.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  const {sx,sy}=canvasXY(e);
  pointers.set(e.pointerId,{sx,sy});

  if(isPanning && panLast){
    view.tx += (sx - panLast.sx);
    view.ty += (sy - panLast.sy);
    panLast={sx,sy};
    need();
    return;
  }

  if(mode==='line' && first){
    preview=s2w(sx,sy);
    need();
  }
},{passive:false});

cv.addEventListener('pointerup', e=>{
  pointers.delete(e.pointerId);
  if(isPanning && pointers.size===0){ isPanning=false; panLast=null; }
},{passive:false});

cv.addEventListener('pointercancel', e=>{
  pointers.delete(e.pointerId);
  if(isPanning && pointers.size===0){ isPanning=false; panLast=null; }
},{passive:false});

/* ===== –∫–Ω–æ–ø–∫–∏ ===== */
const $=id=>document.getElementById(id);
$('btnLine').onclick =()=>{ mode='line'; first=null; preview=null; statusEl.textContent='–°—Ç–∞—Ç—É—Å: –†–µ–∂–∏–º –ª–∏–Ω–∏—è'; };
$('btnHand').onclick =()=>{ mode='hand'; first=null; preview=null; statusEl.textContent='–°—Ç–∞—Ç—É—Å: –†—É–∫–∞ (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º)'; };
$('btnValve').onclick=()=>{ currentComp='valve'; mode='place'; statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ö—Ä–∞–Ω ‚Äî —Ç–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏'; };
$('btnCheck').onclick=()=>{ currentComp='check'; mode='place'; statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ö–ª–∞–ø–∞–Ω ‚Äî —Ç–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏'; };
$('btnPump').onclick =()=>{ currentComp='pump';  mode='place'; statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ù–∞—Å–æ—Å ‚Äî —Ç–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏'; };
$('btnUndo').onclick =()=>{
  if(first){ first=null; preview=null; need(); statusEl.textContent='–°—Ç–∞—Ç—É—Å: —Ç–æ—á–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞'; return; }
  const last=stack.pop(); if(!last){ statusEl.textContent='–°—Ç–∞—Ç—É—Å: –Ω–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å'; return; }
  if(last==='seg' && segs.length) segs.pop(); else if(last==='comp' && comps.length) comps.pop();
  need(); statusEl.textContent='–°—Ç–∞—Ç—É—Å: –æ—Ç–º–µ–Ω–µ–Ω–æ';
};

/* ===== —Å—Ç–∞—Ä—Ç ===== */
fit(); need();
statusEl.textContent='–°—Ç–∞—Ç—É—Å: –ì–æ—Ç–æ–≤–æ (v852-check-return)';

})();
</script>
</body>
</html>