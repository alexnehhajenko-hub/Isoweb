<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî 3D draw (clean HUD + settings + photo)</title>
<style>
  :root{--violet:#6b1dff; --violet2:#7c5bff; --edge:#e7e3f7}
  html,body{margin:0;height:100%;background:#1a1a1a;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{position:fixed;inset:0;display:block;width:100vw;height:100vh;background:#111;touch-action:none;-webkit-user-select:none;user-select:none}

  .bar{position:fixed;left:8px;top:8px;z-index:10;display:flex;gap:8px}
  .btn{height:44px;padding:0 14px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:#2b2b2b;color:#eee;border:1px solid #3a3a3a}
  .zbtn{height:44px;min-width:44px;border:0;border-radius:12px;background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.1);font-size:18px}

  .gear{position:fixed;right:8px;top:8px;z-index:11;height:44px;width:44px;border:1px solid var(--edge);border-radius:12px;background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.08);font-size:20px}

  .status{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.70);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;z-index:11;max-width:92vw}
  .badge{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.5);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;pointer-events:none;display:none;z-index:12}

  /* –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
  .panel-wrap{position:fixed;inset:0;z-index:20;display:none}
  .panel-wrap.open{display:block}
  .panel-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.18)}
  .panel{position:absolute;top:64px;right:8px;background:#1f1f1f;border:1px solid #2e2e2e;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.18);padding:12px;width:min(92vw,420px);max-height:80vh;overflow:auto;color:#eee}
  .panel h4{margin:8px 0 10px;font-size:15px;color:#fff}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0;flex-wrap:wrap}
  .close{position:sticky;top:0;margin:-6px -6px 6px auto;background:#2b2b2b;border:1px solid #3a3a3a;width:32px;height:32px;border-radius:8px;color:#fff}
  input[type=range], select{height:40px;border-radius:10px;border:1px solid #3a3a3a;background:#2b2b2b;color:#eee}
  .tog{padding:8px 12px;border-radius:10px;border:1px solid #3a3a3a;background:#2b2b2b;color:#eee}
  .tog.on{outline:3px solid #ffd54d}
  .upl{position:relative;min-width:120px;display:inline-flex;justify-content:center}
  .upl input{position:absolute;inset:0;opacity:0}
  .num{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine"  class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnUndo"  class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnMinus" class="zbtn" title="–£–º–µ–Ω—å—à–∏—Ç—å">‚àí</button>
    <button id="btnPlus"  class="zbtn" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
  </div>
  <button id="btnSettings" class="gear" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öô</button>

  <div id="panelWrap" class="panel-wrap" aria-hidden="true">
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <div id="panel" class="panel" role="dialog" aria-modal="true">
      <button id="btnClosePanel" class="close" title="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>

      <h4>–†–µ–∂–∏–º—ã</h4>
      <div class="row">
        <button id="togRuler" class="tog">üìè –õ–∏–Ω–µ–π–∫–∞</button>
        <button id="togY" class="tog">–î–≤–∏–≥–∞—Ç—å –ø–æ Y‚Üï</button>
      </div>

      <h4>–ú–∞–≥–Ω–∏—Ç—ã</h4>
      <div class="row">
        <button id="togSnapEnds" class="tog on">–°—Ç—ã–∫</button>
        <button id="togSnapMid"  class="tog">–°–µ—Ä–µ–¥–∏–Ω–∞</button>
        <button id="togSnapGrid" class="tog on">–°–µ—Ç–∫–∞</button>
        <button id="togGridVisible" class="tog on">–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É</button>
      </div>

      <h4>–¢—Ä—É–±–∞</h4>
      <div class="row">
        <label>√ò</label>
        <input id="rangeR" type="range" min="0.015" max="0.12" step="0.005" value="0.035" style="width:160px">
        <span id="rangeRVal" class="num">35</span>
      </div>
      <div class="row">
        <label>–ú–∞—Ç–µ—Ä–∏–∞–ª</label>
        <select id="matSel">
          <option value="metal" selected>–ú–µ—Ç–∞–ª–ª</option>
          <option value="plastic">–ü–ª–∞—Å—Ç–∏–∫</option>
          <option value="matte">–ú–∞—Ç–æ–≤—ã–π</option>
        </select>
      </div>

      <h4>–ê—Ä–º–∞—Ç—É—Ä–∞</h4>
      <div class="row">
        <select id="compSel">
          <option value="valve">–ö—Ä–∞–Ω</option>
          <option value="check">–ö–ª–∞–ø–∞–Ω</option>
          <option value="pump">–ù–∞—Å–æ—Å</option>
        </select>
        <button id="btnPlaceComp" class="tog">–ü–æ—Å—Ç–∞–≤–∏—Ç—å</button>
      </div>

      <h4>–§–æ—Ç–æ (—Ñ–æ–Ω)</h4>
      <div class="row">
        <label class="btn ghost upl">üì∑ –ö–∞–º–µ—Ä–∞
          <input id="fileCam" type="file" accept="image/*" capture="environment">
        </label>
        <label class="btn ghost upl">üìÇ –ì–∞–ª–µ—Ä–µ—è
          <input id="fileGal" type="file" accept="image/*">
        </label>
        <button id="btnToggleBg" class="tog">–°–∫—Ä—ã—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å</button>
        <button id="btnClearBg" class="tog">–£–¥–∞–ª–∏—Ç—å —Ñ–æ–Ω</button>
      </div>

      <h4>–ü—Ä–æ–µ–∫—Ç</h4>
      <div class="row">
        <button id="btnSave" class="btn ghost">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å JSON</button>
        <label class="btn ghost upl">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å JSON
          <input id="fileLoad" type="file" accept="application/json">
        </label>
      </div>
    </div>
  </div>

  <div id="status" class="status">–°—Ç–∞—Ç—É—Å: –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
  <div id="badge" class="badge"></div>

<script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.1/examples/js/controls/OrbitControls.js"></script>
<script>
(()=>{"use strict";

/* ===== –∫–æ—Ä–æ—Ç–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã ===== */
const $=id=>document.getElementById(id);
const statusEl=$('status'), badgeEl=$('badge');
const DPR=Math.min(2, Math.max(1, window.devicePixelRatio||1));
const say=s=>statusEl.textContent=s;
const badge=s=>{ if(!s){badgeEl.style.display='none';}else{badgeEl.textContent=s;badgeEl.style.display='block';} };
const mm=v=>Math.round(v*1000);
const fmtLen=m=> (m>=1 ? m.toFixed(3)+' –º' : mm(m)+' –º–º');

/* ===== THREE setup ===== */
const cv=$('cv');
let renderer, scene, camera, controls, raycaster, mouseNDC;
let grid, ground;            // —Å–µ—Ç–∫–∞ –∏ –Ω–µ–≤–∏–¥–∏–º–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å –¥–ª—è –ø–∏–∫–∞
let bgPlane=null;            // —Ñ–æ–Ω–æ–≤–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ (–ø–ª–æ—Å–∫–æ—Å—Ç—å)
const GRID_STEP=0.2;

function init3D(){
  renderer=new THREE.WebGLRenderer({canvas:cv, antialias:true});
  renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
  renderer.setSize(innerWidth, innerHeight, false);
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x101010);

  camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 500);
  camera.position.set(3,2.6,3);

  controls=new THREE.OrbitControls(camera, cv);
  controls.enableDamping=true; controls.dampingFactor=0.08;
  controls.target.set(0,0,0);

  scene.add(new THREE.AmbientLight(0xffffff, .9));
  const dir=new THREE.DirectionalLight(0xffffff, .65); dir.position.set(2,3,1); scene.add(dir);

  grid=new THREE.GridHelper(40, 40/GRID_STEP, 0x333333, 0x2f2f2f);
  grid.material.opacity=0.9; grid.material.transparent=true; scene.add(grid);

  ground=new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshBasicMaterial({visible:false}));
  ground.rotateX(-Math.PI/2); scene.add(ground);

  raycaster=new THREE.Raycaster(); mouseNDC=new THREE.Vector2();

  animate();
}
function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
function onResize(){ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight,false); }
addEventListener('resize', onResize, {passive:true});

/* ===== —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è/–æ–ø—Ü–∏–π ===== */
let st='idle'; // 'idle'|'awaitFirst'|'awaitSecond'
let ruler=false;
let wantY=false;
let snapEnds=true, snapMid=false, snapGrid=true, gridVisible=true;
let pipeRadius=0.035;
let matKind='metal';
let placingComp=false;

const pipes=[]; // {a:V3,b:V3,radius,mesh}
const comps=[]; // {pipeIndex,t,type,group}

/* ===== –º–∞—Ç–µ—Ä–∏–∞–ª—ã ===== */
const materialByKind=()=>{
  if(matKind==='metal') return new THREE.MeshStandardMaterial({color:0x6b1dff, metalness:.75, roughness:.25});
  if(matKind==='plastic') return new THREE.MeshStandardMaterial({color:0x7fc5ff, metalness:.05, roughness:.35});
  return new THREE.MeshStandardMaterial({color:0x6b7b8f, metalness:0.0, roughness:.9});
};

/* ===== –≥–µ–æ–º–µ—Ç—Ä–∏—è (—Ç—Ä—É–±–∞/–∞—Ä–º–∞—Ç—É—Ä–∞) ===== */
function makePipeMesh(a,b,r,mat){
  const dir=new THREE.Vector3().subVectors(b,a);
  const len=dir.length()||1e-6;
  const geom=new THREE.CylinderGeometry(r,r,len,20);
  const mesh=new THREE.Mesh(geom, mat.clone());
  const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
  mesh.position.copy(mid);
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
  return mesh;
}
function refreshPipe(i){
  const p=pipes[i];
  if(p.mesh){ scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); }
  p.mesh=makePipeMesh(p.a,p.b,p.radius, materialByKind());
  scene.add(p.mesh);
  comps.forEach((c,idx)=>{ if(c.pipeIndex===i) refreshComp(idx); });
}
function makeCompModel(type, radius){
  const g=new THREE.Group(); const col=0x6b1dff, stroke=0x1b1b1b;
  if(type==='valve'){
    g.add(new THREE.Mesh(new THREE.CapsuleGeometry(radius*1.6, radius*6.0, 8, 16), new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.3})));
    g.add(new THREE.Mesh(new THREE.SphereGeometry(radius*1.3, 16, 12), new THREE.MeshStandardMaterial({color:0xffffff, metalness:.1, roughness:.5})));
    const h=new THREE.Mesh(new THREE.BoxGeometry(radius*0.6, radius*4.0, radius*0.6), new THREE.MeshStandardMaterial({color:stroke, metalness:.2, roughness:.7}));
    h.position.y=radius*2.2; h.rotation.z=Math.PI/2; g.add(h);
  }else if(type==='check'){
    g.add(new THREE.Mesh(new THREE.CapsuleGeometry(radius*1.6, radius*5.0, 8, 16), new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.3})));
    const cone=new THREE.Mesh(new THREE.ConeGeometry(radius*1.2, radius*2.0, 16), new THREE.MeshStandardMaterial({color:0xffffff, metalness:0, roughness:.6}));
    cone.rotation.x=Math.PI/2; g.add(cone);
  }else{
    const vol=new THREE.Mesh(new THREE.CylinderGeometry(radius*2.2, radius*2.2, radius*1.6, 20), new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.35}));
    vol.rotation.x=Math.PI/2; g.add(vol);
    const motor=new THREE.Mesh(new THREE.BoxGeometry(radius*2.8, radius*1.8, radius*4.2), new THREE.MeshStandardMaterial({color:col, metalness:.5, roughness:.35}));
    motor.position.y=radius*2.0; g.add(motor);
  }
  return g;
}
function basisOnPipe(pipe,t){
  const pos=new THREE.Vector3().lerpVectors(pipe.a, pipe.b, t);
  const dir=new THREE.Vector3().subVectors(pipe.b, pipe.a).normalize();
  const quat=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
  return {pos,quat};
}
function refreshComp(i){
  const c=comps[i], p=pipes[c.pipeIndex]; if(!p) return;
  if(c.group){ c.group.traverse(o=>{o.geometry?.dispose?.(); o.material?.dispose?.();}); scene.remove(c.group); }
  const g=makeCompModel(c.type, p.radius);
  const {pos,quat}=basisOnPipe(p,c.t); g.position.copy(pos); g.quaternion.copy(quat);
  g.userData={compIndex:i};
  scene.add(g); c.group=g;
}

/* ===== —Å–Ω–∞–ø—ã –∏ –ø–∏–∫–∏–Ω–≥ ===== */
function pickOnGround(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const hit=raycaster.intersectObject(ground,false)[0];
  return hit? hit.point.clone() : null;
}
function snapGrid(v){ if(!snapGridOn) return v; v.x=Math.round(v.x/GRID_STEP)*GRID_STEP; v.y=Math.round(v.y/GRID_STEP)*GRID_STEP; v.z=Math.round(v.z/GRID_STEP)*GRID_STEP; return v; }
let snapGridOn=true;
function allEnds(){ const arr=[]; pipes.forEach((p,i)=>arr.push({i,end:'a',v:p.a},{i,end:'b',v:p.b})); return arr; }
function allMids(){ const arr=[]; pipes.forEach((p,i)=>arr.push({i,t:.5,v:new THREE.Vector3().lerpVectors(p.a,p.b,.5)})); return arr; }
function snapVertices(v){
  let best=null,bd=1e9;
  if(snapEnds){ for(const it of allEnds()){ const d=it.v.distanceTo(v); if(d<bd){bd=d; best=it.v;} } }
  if(snapMid){  for(const it of allMids()){ const d=it.v.distanceTo(v); if(d<bd){bd=d; best=it.v;} } }
  return (best && bd<=Math.max(pipeRadius*3,0.25)) ? best.clone() : null;
}
function raycastPipe(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const meshes=pipes.map(p=>p.mesh).filter(Boolean);
  const hits=raycaster.intersectObjects(meshes, false);
  if(!hits.length) return null;
  const mesh=hits[0].object;
  const idx=pipes.findIndex(p=>p.mesh===mesh);
  const p=pipes[idx], a=p.a, b=p.b, hitPoint=hits[0].point.clone();
  const t=THREE.MathUtils.clamp(a.clone().distanceTo(hitPoint)/a.distanceTo(b),0,1);
  return {idx,t};
}
function raycastComp(e){
  const rect=cv.getBoundingClientRect();
  mouseNDC.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouseNDC, camera);
  const groups=comps.map(c=>c.group).filter(Boolean);
  const hits=raycaster.intersectObjects(groups,true);
  if(!hits.length) return null;
  let g=hits[0].object;
  while(g && g.userData?.compIndex==null) g=g.parent;
  if(!g) return null;
  return {compIndex:g.userData.compIndex};
}

/* ===== –≤–≤–æ–¥ ===== */
let first=null, preview=null, pressTimer=null;
let editEnd=null;      // {idx,end,axis:'xz'|'y'}
let dragComp=null;     // {compIndex}

cv.addEventListener('pointerdown', e=>{
  clearTimeout(pressTimer);

  // –¥–æ–ª–≥–∏–π —Ç–∞–ø –ø–æ –∞—Ä–º–∞—Ç—É—Ä–µ ‚Äî —Ç—è–Ω—É—Ç—å –≤–¥–æ–ª—å —Ç—Ä—É–±—ã
  const hitC=raycastComp(e);
  if(hitC){
    pressTimer=setTimeout(()=>{ dragComp={compIndex:hitC.compIndex}; say('–¢—è–Ω–∏ –∞—Ä–º–∞—Ç—É—Ä—É –≤–¥–æ–ª—å —Ç—Ä—É–±—ã'); }, 650);
  }

  // –¥–æ–ª–≥–∏–π —Ç–∞–ø –ø–æ –∫–æ–Ω—Ü—É —Ç—Ä—É–±—ã ‚Äî –ø—Ä–∞–≤–∫–∞
  const p=pickOnGround(e);
  if(p){
    const near=allEnds().sort((A,B)=>A.v.distanceTo(p)-B.v.distanceTo(p))[0];
    if(near && near.v.distanceTo(p)<=Math.max(pipeRadius*3,0.25)){
      pressTimer=setTimeout(()=>{ editEnd={idx:near.i,end:near.end,axis:(wantY?'y':'xz')}; say('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞'); }, 650);
    }
  }

  // –≤—Å—Ç–∞–≤–∫–∞ –∞—Ä–º–∞—Ç—É—Ä—ã
  if(placingComp){
    const hit=raycastPipe(e);
    if(hit){ comps.push({pipeIndex:hit.idx,t:hit.t,type:$('compSel').value,group:null}); refreshComp(comps.length-1); placingComp=false; $('btnPlaceComp').classList.remove('on'); say('–ê—Ä–º–∞—Ç—É—Ä–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞'); }
    else say('–¢–∫–Ω–∏ –ø–æ —Ç—Ä—É–±–µ');
    return;
  }

  // –ª–∏–Ω–µ–π–∫–∞
  if(ruler){
    let v=p? p.clone(): null; if(!v) return;
    v = snapGridOn? snapGrid(v): v;
    const j=snapVertices(v); if(j) v=j;
    if(!first){ first=v.clone(); badge('0 –º–º'); say('–õ–∏–Ω–µ–π–∫–∞: –≤—ã–±–µ—Ä–∏ –≤—Ç–æ—Ä—É—é —Ç–æ—á–∫—É'); }
    else{
      const d=first.distanceTo(v); badge(fmtLen(d)); setTimeout(()=>badge(''),1600); first=null;
    }
    return;
  }

  // —Ä–∏—Å–æ–≤–∞–Ω–∏–µ
  if(st==='awaitFirst'){
    let v=p? p.clone(): null; if(!v) return;
    v = snapGridOn? snapGrid(v): v; const j=snapVertices(v); if(j) v=j;
    first=v.clone(); st='awaitSecond'; say('1-—è —Ç–æ—á–∫–∞. –ü–æ—Å—Ç–∞–≤—å –≤—Ç–æ—Ä—É—é.');
    return;
  }
  if(st==='awaitSecond' && first){
    let v=p? p.clone(): null; if(!v) return;
    v = snapGridOn? snapGrid(v): v; const j=snapVertices(v); if(j) v=j;
    const i=pipes.push({a:first.clone(), b:v.clone(), radius:pipeRadius, mesh:null})-1;
    refreshPipe(i);
    first=null; if(preview){scene.remove(preview); preview=null;} st='idle'; badge(''); say('–¢—Ä—É–±–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞. –î–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Å–Ω–æ–≤–∞ –Ω–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª.');
    return;
  }
});

cv.addEventListener('pointermove', e=>{
  if(pressTimer && Math.hypot(e.movementX,e.movementY)>6){ clearTimeout(pressTimer); pressTimer=null; }

  // –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∞—Ä–º–∞—Ç—É—Ä—ã
  if(dragComp){
    const c=comps[dragComp.compIndex]; const hit=raycastPipe(e);
    if(hit && hit.idx===c.pipeIndex){ c.t=hit.t; refreshComp(dragComp.compIndex); say('t='+c.t.toFixed(2)); }
    return;
  }
  // –ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞
  if(editEnd){
    const p=pickOnGround(e); if(!p) return;
    const pipe=pipes[editEnd.idx]; const other = (editEnd.end==='a'? pipe.b:pipe.a);
    let v=snapGridOn? snapGrid(p.clone()): p.clone(); const j=snapVertices(v); if(j) v=j;
    if(editEnd.axis==='xz') v.y=other.y;
    if(editEnd.end==='a') pipe.a.copy(v); else pipe.b.copy(v);
    refreshPipe(editEnd.idx); return;
  }

  // –ø—Ä–µ–≤—å—é –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏
  if(st==='awaitSecond' && first){
    const p=pickOnGround(e); if(!p) return;
    let v=snapGridOn? snapGrid(p.clone()): p.clone(); const j=snapVertices(v); if(j) v=j;
    if(preview){ scene.remove(preview); preview=null; }
    preview=makePipeMesh(first, v, Math.max(0.8*pipeRadius,0.01), new THREE.MeshStandardMaterial({color:0x7c5bff,metalness:.2,roughness:.5}));
    scene.add(preview); badge(fmtLen(first.distanceTo(v)));
  }
});
cv.addEventListener('pointerup', ()=>{ clearTimeout(pressTimer); pressTimer=null; if(editEnd){editEnd=null; say('–ì–æ—Ç–æ–≤–æ');} if(dragComp){dragComp=null; say('–ì–æ—Ç–æ–≤–æ');} });

/* ===== –∫–Ω–æ–ø–∫–∏ HUD ===== */
$('btnLine').onclick=()=>{
  if(ruler){ say('–°–Ω–∞—á–∞–ª–∞ –≤—ã–∫–ª—é—á–∏ ¬´–õ–∏–Ω–µ–π–∫—É¬ª –≤ ‚öô'); return; }
  if(st==='idle'){ st='awaitFirst'; first=null; if(preview){scene.remove(preview); preview=null;} say('–†–µ–∂–∏–º –õ–∏–Ω–∏—è: —Ç–∫–Ω–∏ 1-—é —Ç–æ—á–∫—É'); return; }
  if(st==='awaitFirst'){ st='idle'; say('–û—Ç–º–µ–Ω–∞'); return; }
  if(st==='awaitSecond'){ st='idle'; first=null; if(preview){scene.remove(preview); preview=null;} say('–û—Ç–º–µ–Ω–∞'); return; }
};
$('btnUndo').onclick=()=>{ if(preview){scene.remove(preview); preview=null;} const last=pipes.pop(); if(last){scene.remove(last.mesh); last.mesh.geometry.dispose(); last.mesh.material.dispose();} say('–û—Ç–º–µ–Ω–µ–Ω–æ'); };
$('btnPlus').onclick =()=>{ controls.dollyOut(0.9); controls.update(); };
$('btnMinus').onclick=()=>{ controls.dollyIn(0.9);  controls.update(); };

/* ===== –ü–∞–Ω–µ–ª—å ===== */
const wrap=$('panelWrap'), backdrop=$('panelBackdrop'), panel=$('panel');
$('btnSettings').onclick=()=>{ wrap.classList.add('open'); wrap.setAttribute('aria-hidden','false'); };
$('btnClosePanel').onclick=()=>{ wrap.classList.remove('open'); wrap.setAttribute('aria-hidden','true'); };
backdrop.onclick=$('btnClosePanel').onclick;
['pointerdown','pointermove','pointerup','click','wheel'].forEach(ev=>panel.addEventListener(ev, e=>e.stopPropagation(), {passive:true}));

// –¢–æ–≥–≥–ª—ã
$('togRuler').onclick =()=>{ ruler=!ruler; $('togRuler').classList.toggle('on',ruler); st='idle'; first=null; if(preview){scene.remove(preview); preview=null;} say(ruler?'–õ–∏–Ω–µ–π–∫–∞: —Ç–∫–Ω–∏ 2 —Ç–æ—á–∫–∏':'–õ–∏–Ω–µ–π–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω–∞'); };
$('togY').onclick      =()=>{ wantY=!wantY; $('togY').classList.toggle('on',wantY); say(wantY?'–î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ Y':'–ü–ª–æ—Å–∫–æ—Å—Ç—å XZ'); };
$('togSnapEnds').onclick =()=>{ snapEnds=!snapEnds; $('togSnapEnds').classList.toggle('on',snapEnds); say('–ú–∞–≥–Ω–∏—Ç –∫ —Å—Ç—ã–∫–∞–º: '+(snapEnds?'–≤–∫–ª':'–≤—ã–∫–ª')); };
$('togSnapMid').onclick  =()=>{ snapMid=!snapMid;   $('togSnapMid').classList.toggle('on',snapMid);   say('–ú–∞–≥–Ω–∏—Ç –∫ —Å–µ—Ä–µ–¥–∏–Ω–∞–º: '+(snapMid?'–≤–∫–ª':'–≤—ã–∫–ª')); };
$('togSnapGrid').onclick =()=>{ snapGridOn=!snapGridOn; $('togSnapGrid').classList.toggle('on',snapGridOn); say('–ú–∞–≥–Ω–∏—Ç –∫ —Å–µ—Ç–∫–µ: '+(snapGridOn?'–≤–∫–ª':'–≤—ã–∫–ª')); };
$('togGridVisible').onclick=()=>{ gridVisible=!gridVisible; $('togGridVisible').classList.toggle('on',gridVisible); grid.visible=gridVisible; say('–°–µ—Ç–∫–∞: '+(gridVisible?'–ø–æ–∫–∞–∑–∞–Ω–∞':'—Å–∫—Ä—ã—Ç–∞')); };

// √ò –∏ –º–∞—Ç–µ—Ä–∏–∞–ª
$('rangeR').oninput = e=>{ pipeRadius=parseFloat(e.target.value||'0.035'); $('rangeRVal').textContent=String(Math.round(pipeRadius*1000)); say('√ò '+Math.round(pipeRadius*1000)+' –º–º'); };
$('matSel').onchange= e=>{ matKind=e.target.value; pipes.forEach((_,i)=>refreshPipe(i)); say('–ú–∞—Ç–µ—Ä–∏–∞–ª: '+matKind); };

// –ê—Ä–º–∞—Ç—É—Ä–∞
$('btnPlaceComp').onclick=()=>{ placingComp=!placingComp; $('btnPlaceComp').classList.toggle('on',placingComp); say(placingComp?'–†–µ–∂–∏–º –∞—Ä–º–∞—Ç—É—Ä—ã: —Ç–∫–Ω–∏ –ø–æ —Ç—Ä—É–±–µ':'–†–µ–∂–∏–º –∞—Ä–º–∞—Ç—É—Ä—ã –≤—ã–∫–ª—é—á–µ–Ω'); };

// –§–æ—Ç–æ/—Ñ–æ–Ω
function setBackgroundFromFile(file){
  if(!file) return;
  const img=new Image();
  img.onload=()=>{
    const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace;
    const ar=img.width/img.height;
    const W=10, H=W/ar;
    if(bgPlane){ scene.remove(bgPlane); bgPlane.geometry.dispose(); bgPlane.material.map?.dispose?.(); bgPlane.material.dispose(); }
    const geo=new THREE.PlaneGeometry(W,H);
    const mat=new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:true, opacity:.95});
    bgPlane=new THREE.Mesh(geo,mat);
    bgPlane.rotation.x=-Math.PI/2;
    bgPlane.position.y=-0.001; // –ø–æ–¥ —Å–µ—Ç–∫–æ–π
    scene.add(bgPlane);
    say('–§–æ–Ω –¥–æ–±–∞–≤–ª–µ–Ω');
  };
  img.src=URL.createObjectURL(file);
}
$('fileCam').onchange=e=>setBackgroundFromFile(e.target.files?.[0]);
$('fileGal').onchange=e=>setBackgroundFromFile(e.target.files?.[0]);
$('btnToggleBg').onclick=()=>{ if(bgPlane){ bgPlane.visible=!bgPlane.visible; say('–§–æ–Ω: '+(bgPlane.visible?'–ø–æ–∫–∞–∑–∞–Ω':'—Å–∫—Ä—ã—Ç')); } };
$('btnClearBg').onclick=()=>{ if(bgPlane){ scene.remove(bgPlane); bgPlane.geometry.dispose(); bgPlane.material.map?.dispose?.(); bgPlane.material.dispose(); bgPlane=null; say('–§–æ–Ω —É–¥–∞–ª—ë–Ω'); } };

// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å/–∑–∞–≥—Ä—É–∑–∏—Ç—å
function serialize(){
  return {
    version:1,
    settings:{pipeRadius,matKind,snapEnds,snapMid,snapGridOn,gridVisible,wantY},
    pipes:pipes.map(p=>({a:p.a,b:p.b,radius:p.radius})),
    comps:comps.map(c=>({pipeIndex:c.pipeIndex,t:c.t,type:c.type}))
  };
}
$('btnSave').onclick=()=>{
  const blob=new Blob([JSON.stringify(serialize())],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download='pro-trace.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
  say('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
};
$('fileLoad').onchange=e=>{
  const f=e.target.files?.[0]; if(!f) return;
  const rd=new FileReader();
  rd.onload=()=>{
    try{
      const data=JSON.parse(rd.result);
      // –æ—á–∏—Å—Ç–∫–∞
      pipes.splice(0).forEach(p=>{ if(p.mesh){scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose();}});
      comps.splice(0).forEach(c=>{ if(c.group){c.group.traverse(o=>{o.geometry?.dispose?.();o.material?.dispose?.();}); scene.remove(c.group);} });
      // –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
      if(data.settings){
        pipeRadius=data.settings.pipeRadius??pipeRadius; $('rangeR').value=pipeRadius; $('rangeRVal').textContent=Math.round(pipeRadius*1000);
        matKind=data.settings.matKind??matKind; $('matSel').value=matKind;
        snapEnds=!!data.settings.snapEnds; $('togSnapEnds').classList.toggle('on',snapEnds);
        snapMid=!!data.settings.snapMid;   $('togSnapMid').classList.toggle('on',snapMid);
        snapGridOn=!!data.settings.snapGridOn; $('togSnapGrid').classList.toggle('on',snapGridOn);
        gridVisible=!!data.settings.gridVisible; $('togGridVisible').classList.toggle('on',gridVisible); grid.visible=gridVisible;
        wantY=!!data.settings.wantY; $('togY').classList.toggle('on',wantY);
      }
      // —Ç—Ä—É–±—ã
      (data.pipes||[]).forEach(p=>{ pipes.push({a:new THREE.Vector3(p.a.x,p.a.y,p.a.z), b:new THREE.Vector3(p.b.x,p.b.y,p.b.z), radius:p.radius||pipeRadius, mesh:null}); });
      pipes.forEach((_,i)=>refreshPipe(i));
      // –∞—Ä–º–∞—Ç—É—Ä–∞
      (data.comps||[]).forEach(c=>{ comps.push({pipeIndex:c.pipeIndex,t:c.t,type:c.type,group:null}); });
      comps.forEach((_,i)=>refreshComp(i));
      say('–ü—Ä–æ–µ–∫—Ç –∑–∞–≥—Ä—É–∂–µ–Ω');
    }catch(err){ alert('–û—à–∏–±–∫–∞ JSON: '+err); }
  };
  rd.readAsText(f);
};

/* ===== —Å—Ç–∞—Ä—Ç ===== */
init3D();
say('–ì–æ—Ç–æ–≤–æ: 3D-—Å–µ—Ç–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª ‚Üí 1-—è —Ç–æ—á–∫–∞ ‚Üí 2-—è —Ç–æ—á–∫–∞. –í—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ ‚Äî –≤ ‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏.');
})();
</script>
</body>
</html>