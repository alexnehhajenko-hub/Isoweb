<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî ISO –±–µ–π–¥–∂–∏, —Ä—É—á–∫–∞ –≤–≤–µ—Ä—Ö, –ø–æ–¥–ø–∏—Å–∏ –Ω–∞ —Ç—Ä—É–±–µ (v802)</title>
<style>
  :root{--violet:#8000ff; --violet2:#6b1dff; --border:#e7e3f7}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}

  .bar{position:fixed;left:8px;right:56px;top:8px;z-index:1000;display:flex;gap:8px}
  .btn{height:44px;padding:0 16px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:linear-gradient(180deg,#8c8c8c,#6a6a6a)}
  .gear{position:fixed;top:8px;right:8px;width:44px;height:44px;border-radius:12px;border:1px solid var(--border);background:#fff;color:#5b30c2;font-weight:800;z-index:1001}

  .panel-wrap{position:fixed;inset:0;z-index:1050;display:none}
  .panel-wrap.open{display:block}
  .panel-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.18)}
  .panel{position:absolute;top:64px;right:8px;background:#fff;border:1px solid var(--border);
         border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:12px;width:min(92vw,380px);
         max-height:80vh;overflow:auto}
  .panel h4{margin:6px 0 8px 0;font-size:15px}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{min-width:150px;font-size:13px;color:#444}
  .row input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#eee}
  .row input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--violet)}
  .val{width:56px;text-align:right;font-size:12px;color:#666}
  .sw{display:flex;align-items:center;gap:8px}
  .hr{height:1px;background:#eee;margin:10px 0}
  .panel .btn{height:38px}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{border:1px solid #ddd;border-radius:999px;padding:4px 8px;font-size:12px;color:#555}
  .radio-row{display:flex;gap:10px;flex-wrap:wrap}
  .radio{display:flex;align-items:center;gap:6px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;font-size:12px;color:#333}
  .radio input{accent-color:#6b1dff}
  .close{position:sticky;top:0;margin:-6px -6px 6px auto;background:#fff;border:1px solid var(--border);width:32px;height:32px;border-radius:8px}

  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:10px 12px;border-radius:12px;opacity:0;transition:.25s;z-index:1200;pointer-events:none}
  .toast.show{opacity:1}

  /* –ú–æ–¥–∞–ª–∫–∞ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1200}
  .modal.show{display:flex}
  .modal .bg{position:absolute;inset:0;background:rgba(0,0,0,.25)}
  .modal .card{position:relative;min-width:280px;max-width:90vw;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:14px}
  .modal h4{margin:0 0 10px 0}
  .modal input{width:100%;padding:10px;border:1px solid #d8c9ff;border-radius:10px;margin-bottom:10px;font-size:16px}
  .modal .actions{display:flex;gap:8px;justify-content:flex-end}
  .modal .actions button{height:38px;border:0;border-radius:10px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:700;padding:0 14px}
  .modal .actions .ghost{background:#fff;color:#5c30b5;border:1px solid #d8c9ff}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine" class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnUndo" class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnHand" class="btn ghost">üñê –†—É–∫–∞</button>
  </div>
  <button id="btnSettings" class="gear" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öô</button>

  <div id="panelWrap" class="panel-wrap" aria-hidden="true">
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <div id="panel" class="panel" role="dialog" aria-modal="true">
      <button id="btnClosePanel" class="close" title="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>

      <h4>–õ–∏–Ω–∏—è</h4>
      <div class="row">
        <label>–¢–æ–ª—â–∏–Ω–∞ (px)</label>
        <input id="linePx" type="range" min="2" max="48" value="12">
        <span id="linePxVal" class="val">12</span>
      </div>
      <div class="row">
        <label>–¶–≤–µ—Ç</label>
        <div class="chips" style="flex:1">
          <button class="chip" data-col="#8000ff" style="border-color:#8000ff;color:#8000ff">–§–∏–æ–ª–µ—Ç–æ–≤—ã–π</button>
          <button class="chip" data-col="#ff2d55" style="border-color:#ff2d55;color:#ff2d55">–†–æ–∑–æ–≤—ã–π</button>
          <button class="chip" data-col="#00b894" style="border-color:#00b894;color:#00b894">–ó–µ–ª—ë–Ω—ã–π</button>
          <button class="chip" data-col="#1e90ff" style="border-color:#1e90ff;color:#1e90ff">–°–∏–Ω–∏–π</button>
          <button class="chip" data-col="#111111" style="border-color:#333;color:#111">–ß—ë—Ä–Ω—ã–π</button>
        </div>
        <input id="lineColor" type="color" value="#8000ff" style="width:42px;height:32px;padding:0;border:1px solid #ccc;border-radius:8px">
      </div>

      <div class="hr"></div>
      <h4>–°–µ—Ç–∫–∞ 3D</h4>
      <div class="row"><div class="sw"><input id="gridOn" type="checkbox" checked><label for="gridOn">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–µ—Ç–∫—É</label></div></div>
      <div class="row"><label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</label><input id="gridAlpha" type="range" min="0" max="100" value="25"><span id="gridAlphaVal" class="val">25%</span></div>
      <div class="row"><label>–®–∞–≥ (px)</label><input id="gridStep" type="range" min="80" max="480" value="200"><span id="gridStepVal" class="val">200</span></div>
      <div class="row"><label>–£–≥–æ–ª (¬∞)</label><input id="gridAngle" type="range" min="-90" max="90" value="30"><span id="gridAngleVal" class="val">30</span></div>

      <div class="hr"></div>
      <h4>–ú–∞–≥–Ω–∏—Ç</h4>
      <div class="row"><div class="sw"><input id="snapOn" type="checkbox" checked><label for="snapOn">–ü—Ä–∏—Ç—è–≥–∏–≤–∞—Ç—å –∫ –∫–æ–Ω—Ü–∞–º –ª–∏–Ω–∏–π</label></div></div>
      <div class="row"><label>–†–∞–¥–∏—É—Å —É–∑–ª–∞ (px)</label><input id="snapRadius" type="range" min="8" max="60" value="22"><span id="snapRadiusVal" class="val">22</span></div>

      <div class="hr"></div>
      <h4>–ê—Ä–º–∞—Ç—É—Ä–∞</h4>
      <div class="row radio-row">
        <label class="radio"><input type="radio" name="comp" value="valve" checked> –í–µ–Ω—Ç–∏–ª—å (BV)</label>
        <label class="radio"><input type="radio" name="comp" value="check"> –û–±—Ä–∞—Ç–Ω—ã–π (NRV)</label>
        <label class="radio"><input type="radio" name="comp" value="pump"> –ù–∞—Å–æ—Å (P)</label>
      </div>
      <div class="row"><label>–†–∞–∑–º–µ—Ä (√ó)</label><input id="compScale" type="range" min="70" max="200" value="110"><span id="compScaleVal" class="val">1.10√ó</span></div>
      <div class="row" style="justify-content:flex-end;gap:8px">
        <button id="btnPlaceComp" class="btn">–í—Å—Ç–∞–≤–∏—Ç—å –∞—Ä–º–∞—Ç—É—Ä—É</button>
      </div>

      <div class="hr"></div>
      <h4>–ü–æ–¥–ø–∏—Å–∏ –Ω–∞ —Ç—Ä—É–±–µ</h4>
      <div class="row" style="justify-content:flex-end">
        <button id="btnAddLabel" class="btn ghost">–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å—å</button>
      </div>

      <div class="hr"></div>
      <h4>–§–æ—Ç–æ</h4>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <label style="min-width:auto">–ò—Å—Ç–æ—á–Ω–∏–∫</label>
        <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üì∑ –ö–∞–º–µ—Ä–∞
          <input id="fileCam" type="file" accept="image/*" capture="environment" style="position:absolute;inset:0;opacity:0">
        </label>
        <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üìÇ –ì–∞–ª–µ—Ä–µ—è
          <input id="fileGal" type="file" accept="image/*" style="position:absolute;inset:0;opacity:0">
        </label>
        <button id="btnExport" class="btn ghost" style="margin-left:auto">‚§ì PNG</button>
      </div>
    </div>
  </div>

  <!-- –ú–æ–¥–∞–ª–∫–∞ —Ç–µ–∫—Å—Ç–∞ -->
  <div id="textModal" class="modal" aria-hidden="true">
    <div class="bg"></div>
    <div class="card">
      <h4>–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å—å</h4>
      <input id="textInput" type="text" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: BV DN50 PN16" />
      <div class="actions">
        <button id="textCancel" class="ghost">–û—Ç–º–µ–Ω–∞</button>
        <button id="textOk">–û–ö</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(()=>{
  const DPR = Math.max(1, window.devicePixelRatio||1);
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d',{alpha:false});
  const toast=(t,ms=1500)=>{const el=document.getElementById('toast');el.textContent=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),ms);};
  function getCanvasPointXY(clientX, clientY){ const r=cv.getBoundingClientRect(); return { sx:(clientX-r.left)*(cv.width/r.width), sy:(clientY-r.top)*(cv.height/r.height) }; }

  const view={scale:1,tx:0,ty:0};
  let bg=null,bw=0,bh=0;

  const segs=[];   // {a:{x,y}, b:{x,y}}
  const comps=[];  // {segIndex, t, type, scale, refScale, std?:string}
  const labels=[]; // {segIndex, t, text, offset: number(px)}

  let mode='hand'; // hand | line | edit | place | label
  let first=null, preview=null;
  let editing=null;

  const params={
    linePx:12, lineColor:'#8000ff',
    grid:{ on:true, alpha:0.25, step:200, angleDeg:30 },
    snap:{ on:true, radiusPx:22 },
    comp:{ type:'valve', scale:1.10 }
  };

  function fit(){ cv.width=Math.round(innerWidth*DPR); cv.height=Math.round(innerHeight*DPR); if(bg && view.scale===1 && view.tx===0 && view.ty===0){ fitToScreen(); } need(); }
  addEventListener('resize',fit);
  function fitToScreen(){ if(!bg) return; const k=Math.min(cv.width/bw, cv.height/bh); view.scale=k; view.tx=(cv.width-bw*k)/2; view.ty=(cv.height-bh*k)/2; }
  const s2w=(sx,sy)=>({x:(sx-view.tx)/view.scale, y:(sy-view.ty)/view.scale});
  const w2s=(x,y)=>({x:x*view.scale+view.tx, y:y*view.scale+view.ty});
  function clampView(){ if(!bg) return; const W=cv.width,H=cv.height,CW=bw*view.scale,CH=bh*view.scale; const minTx=Math.min(0,W-CW),maxTx=Math.max(0,W-CW); const minTy=Math.min(0,H-CH),maxTy=Math.max(0,H-CH); view.tx=Math.min(maxTx,Math.max(minTx,view.tx)); view.ty=Math.min(maxTy,Math.max(minTy,view.ty)); }
  const darker=(hex,k=0.45)=>{const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return '#333'; let [r,g,b]=[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)]; r=Math.max(0,Math.floor(r*(1-k))); g=Math.max(0,Math.floor(g*(1-k))); b=Math.max(0,Math.floor(b*(1-k))); return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); };
  function drawGrid(){ const g=params.grid; if(!g.on||g.alpha<=0) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha=g.alpha; const W=cv.width,H=cv.height,step=g.step; const angles=[0,90,g.angleDeg,180-g.angleDeg]; angles.forEach(deg=>{ const rad=deg*Math.PI/180,vx=Math.cos(rad),vy=Math.sin(rad); const px=-vy,py=vx,N=Math.ceil((Math.max(W,H)+2000)/step); for(let k=-N;k<=N;k++){ const ox=W/2+px*k*step, oy=H/2+py*k*step; const A={x:ox - vx*20000, y:oy - vy*20000}, B={x:ox + vx*20000, y:oy + vy*20000}; const major=(k%3===0); ctx.strokeStyle=major?'#b7bcc8':'#cfd3dc'; ctx.lineWidth=major?1.6:1.0; ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); } }); ctx.restore(); ctx.globalAlpha=1; }
  function drawHandle(pt){ const p=w2s(pt.x,pt.y); ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#16a34a'; ctx.strokeStyle='#0f5132'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  function drawSegments(){ ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); const col=params.lineColor,sh=darker(col,0.45); for(const s of segs){ ctx.strokeStyle=sh; ctx.globalAlpha=.75; ctx.lineWidth=(params.linePx+2)/view.scale; ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke(); ctx.strokeStyle=col; ctx.globalAlpha=1; ctx.lineWidth=(params.linePx)/view.scale; ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke(); } }
  function segGeom(seg){ const vx=seg.b.x-seg.a.x, vy=seg.b.y-seg.a.y; const L=Math.hypot(vx,vy)||1; return {vx,vy,L,nx:vx/L,ny:vy/L}; }
  function compBasis(seg,t){ const g=segGeom(seg); const x=seg.a.x+g.nx*g.L*t, y=seg.a.y+g.ny*g.L*t; const ux=g.nx, uy=g.ny, nx=-uy, ny=ux; return {x,y,ux,uy,nx,ny}; }
  function compBaseWorld(refScale){ return (params.linePx / refScale); }

  // --- –†—É—á–∫–∞ –≤—Å–µ–≥–¥–∞ –≤–≤–µ—Ä—Ö (—ç–∫—Ä–∞–Ω–Ω–æ) ---
  function drawValve(seg,t,c){
    const b=compBasis(seg,t);
    const base=compBaseWorld(c.refScale), lw=base*1.0*c.scale, body=lw*6.0, thick=lw*1.3;
    ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.strokeStyle='#111'; ctx.lineWidth=thick; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(b.x - b.ux*body/2, b.y - b.uy*body/2); ctx.lineTo(b.x + b.ux*body/2, b.y + b.uy*body/2); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=lw*0.9; const r=lw*1.8;
    ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // —Ä—É—á–∫–∞: –≤–≤–µ—Ä—Ö –ø–æ —ç–∫—Ä–∞–Ω—É (0,-1 –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö) -> –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –Ω–∞ –º–∏—Ä–æ–≤–æ–π —Å–ª–æ–π –ø—Ä–æ—Å—Ç–æ –ª–∏–Ω–∏–µ–π –≤ —ç–∫—Ä–∞–Ω–Ω–æ–º —Å–ª–æ–µ:
    ctx.restore();
    const S=w2s(b.x,b.y);
    ctx.setTransform(1,0,0,1,0,0);
    const hLen = r*view.scale*1.6, hTh = lw*view.scale*0.9;
    ctx.strokeStyle='#111'; ctx.lineWidth=hTh; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(S.x, S.y); ctx.lineTo(S.x, S.y - hLen*0.75); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(S.x, S.y - hLen*0.55); ctx.lineTo(S.x + hLen*0.45, S.y - hLen*0.55); ctx.stroke();
    // ISO –±–µ–π–¥–∂
    drawBadge(S.x, S.y, 'BV');
  }
  function drawCheckValve(seg,t,c){
    const b=compBasis(seg,t);
    const base=compBaseWorld(c.refScale), lw=base*1.0*c.scale, body=lw*7.0, thick=lw*1.2, flange=lw*1.8;
    ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.strokeStyle='#111'; ctx.lineWidth=thick; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(b.x - b.ux*body/2 + b.nx*flange, b.y - b.uy*body/2 + b.ny*flange);
    ctx.lineTo(b.x - b.ux*body/2 - b.nx*flange, b.y - b.uy*body/2 - b.ny*flange); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(b.x + b.ux*body/2 + b.nx*flange, b.y + b.uy*body/2 + b.ny*flange);
    ctx.lineTo(b.x + b.ux*body/2 - b.nx*flange, b.y + b.uy*body/2 - b.ny*flange); ctx.stroke();
    const triLen=lw*3.0, triW=lw*2.2; ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=lw*0.9;
    ctx.beginPath(); ctx.moveTo(b.x - b.ux*(triLen/2), b.y - b.uy*(triLen/2));
    ctx.lineTo(b.x + b.ux*(triLen/2), b.y + b.uy*(triLen/2));
    ctx.lineTo(b.x + b.nx*(triW/2),   b.y + b.ny*(triW/2)); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
    const S=w2s(b.x,b.y); drawBadge(S.x,S.y,'NRV');
  }
  function drawPump(seg,t,c){
    const b=compBasis(seg,t);
    const base=compBaseWorld(c.refScale), lw=base*1.0*c.scale, R=lw*3.3;
    ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=lw*1.1; ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill(); ctx.stroke();
    const aLen=R*0.9, aW=lw*1.2; ctx.strokeStyle='#111'; ctx.lineWidth=aW; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(b.x - b.ux*aLen*0.4, b.y - b.uy*aLen*0.4); ctx.lineTo(b.x + b.ux*aLen*0.5, b.y + b.uy*aLen*0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(b.x + b.ux*aLen*0.5, b.y + b.uy*aLen*0.5);
    ctx.lineTo(b.x + b.ux*aLen*0.28 + (-b.uy)*aLen*0.22, b.y + b.uy*aLen*0.28 + ( b.ux)*aLen*0.22);
    ctx.lineTo(b.x + b.ux*aLen*0.28 - (-b.uy)*aLen*0.22, b.y + b.uy*aLen*0.28 - ( b.ux)*aLen*0.22);
    ctx.closePath(); ctx.fillStyle='#111'; ctx.fill();
    ctx.restore();
    const S=w2s(b.x,b.y); drawBadge(S.x,S.y,'P');
  }

  function drawBadge(sx,sy,txt){
    // –º–∞–ª–µ–Ω—å–∫–∏–π ISO-–±–µ–π–¥–∂ —Å–ø—Ä–∞–≤–∞-–≤–≤–µ—Ä—Ö—É –æ—Ç —Ç–æ—á–∫–∏ sx,sy (—ç–∫—Ä–∞–Ω–Ω—ã–µ)
    const padH=6, padV=4, r=7;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.font='700 11px system-ui,-apple-system,Segoe UI,Roboto';
    const w=ctx.measureText(txt).width + padH*2, h=18;
    const x=sx+8, y=sy-8-h;
    ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#111'; ctx.lineWidth=1;
    roundRect(x,y,w,h,r); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#111'; ctx.textBaseline='middle'; ctx.fillText(txt, x+padH, y+h/2);
  }
  function roundRect(x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

  function drawLabels(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.font='600 14px system-ui,-apple-system,Segoe UI,Roboto';
    for(const L of labels){
      const seg=segs[L.segIndex]; if(!seg) continue;
      const b=compBasis(seg,L.t);
      const S=w2s(b.x,b.y);
      const nx=b.nx, ny=b.ny; // –º–∏—Ä–æ–≤–æ–π –Ω–æ—Ä–º–∞–ª—å (–ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä –∫ —Ç—Ä—É–±–µ)
      // —ç–∫—Ä–∞–Ω–Ω—ã–π –æ—Ñ—Ñ—Å–µ—Ç –≤–≤–µ—Ä—Ö –Ω–∞ L.offset –∏ —á—É—Ç—å –≤–¥–æ–ª—å —Ç—Ä—É–±—ã:
      const off = L.offset ?? 18;
      const ex=S.x + 10*nx*view.scale;
      const ey=S.y - off; // –≤–≤–µ—Ä—Ö –ø–æ —ç–∫—Ä–∞–Ω—É
      // leader (—Ç–æ–Ω–∫–∞—è –ª–∏–Ω–∏—è –æ—Ç —Ç—Ä—É–±—ã –∫ –ø–æ–¥–ø–∏—Å–∏)
      ctx.strokeStyle='#555'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(S.x,S.y); ctx.lineTo(ex,ey); ctx.stroke();
      // –±–µ–π–¥–∂ –ø–æ–¥–ø–∏—Å–∏
      const padH=8, padV=6, r=8;
      const txt=L.text||''; const w=ctx.measureText(txt).width + padH*2; const h=24;
      ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#8000ff'; ctx.lineWidth=1;
      roundRect(ex, ey-h/2, w, h, r); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#111'; ctx.textBaseline='middle'; ctx.fillText(txt, ex+padH, ey);
    }
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);
    if(bg){ ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.drawImage(bg,0,0,bw,bh); }
    drawGrid(); drawSegments();
    // –∞—Ä–º–∞—Ç—É—Ä–∞ –ø–æ–≤–µ—Ä—Ö —Ç—Ä—É–±
    for(const c of comps){
      const seg=segs[c.segIndex]; if(!seg) continue;
      if(c.type==='valve') drawValve(seg,c.t,c);
      else if(c.type==='check') drawCheckValve(seg,c.t,c);
      else if(c.type==='pump') drawPump(seg,c.t,c);
    }
    drawLabels();

    if(first){
      const p=w2s(first.x,first.y); ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle='#ff3b30'; ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }
    if(first && preview){
      ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
      ctx.setLineDash([12/view.scale,8/view.scale]); ctx.strokeStyle=params.lineColor; ctx.lineWidth=Math.max(3,params.linePx-2)/view.scale;
      ctx.beginPath(); ctx.moveTo(first.x,first.y); ctx.lineTo(preview.x,preview.y); ctx.stroke(); ctx.setLineDash([]);
      const p=w2s(preview.x,preview.y); ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle=params.lineColor; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
    }
    if(mode==='edit' && editing){ const s=segs[editing.segIndex]; drawHandle(editing.end==='a'?s.a:s.b); }
  }
  let raf=0,dirty=false; const need=()=>{dirty=true;if(!raf){raf=requestAnimationFrame(()=>{raf=0;if(dirty){dirty=false;draw();}})}};

  function allNodes(){ const arr=[]; for(const s of segs){ arr.push(s.a,s.b); } return arr; }
  function snapToNodes(raw){ if(!params.snap.on) return raw; const R=params.snap.radiusPx/view.scale; let best=null,bestD=Infinity; for(const n of allNodes()){ const d=Math.hypot(n.x-raw.x,n.y-raw.y); if(d<bestD){bestD=d; best=n;} } if(best && bestD<=R) return {x:best.x,y:best.y}; return raw; }

  function findEndpointNear(sx,sy,rPx=20){ let best=null,bestD=Infinity; for(let i=0;i<segs.length;i++){ const s=segs[i]; const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y); const dA=Math.hypot(A.x-sx,A.y-sy), dB=Math.hypot(B.x-sx,B.y-sy); if(dA<bestD && dA<=rPx){best={segIndex:i,end:'a'};bestD=dA;} if(dB<bestD && dB<=rPx){best={segIndex:i,end:'b'};bestD=dB;} } return best; }
  function findNearestSegment(sx,sy,maxDistPx=28){ let bestI=-1,bestD=Infinity,bestT=0; for(let i=0;i<segs.length;i++){ const s=segs[i]; const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y); const vx=B.x-A.x,vy=B.y-A.y,len2=vx*vx+vy*vy; if(len2===0) continue; const t=Math.max(0,Math.min(1,((sx-A.x)*vx+(sy-A.y)*vy)/len2)); const px=A.x+vx*t, py=A.y+vy*t; const d=Math.hypot(px-sx,py-sy); if(d<bestD){bestD=d;bestI=i;bestT=t;} } if(bestI!==-1 && bestD<=maxDistPx) return {segIndex:bestI,t:bestT}; return null; }

  // touch gestures (pinch/zoom, tap-tap line, long hold edit)
  let touches=new Map(), prevCenter=null, prevDist=null;
  const TAP_MAX_TIME=300, TAP_MAX_MOVE=14*DPR; const downs=new Map();
  const HOLD_MS=500; let holdTimer=null, holdStartId=null;

  const touchCount=()=>touches.size;
  const centroid=()=>{ const a=[...touches.values()]; if(!a.length) return null; let sx=0,sy=0; for(const t of a){ sx+=t.sx; sy+=t.sy;} return {sx:sx/a.length, sy:sy/a.length}; };
  const distance2=(a,b)=>Math.hypot(a.sx-b.sx, a.sy-b.sy);

  cv.addEventListener('touchstart', e=>{
    e.preventDefault();
    const now=performance.now();
    for(const t of e.changedTouches){ const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY); touches.set(t.identifier,{sx,sy}); downs.set(t.identifier,{t0:now,sx,sy}); }
    if(touchCount()===2){ const arr=[...touches.values()]; prevCenter=centroid(); prevDist=distance2(arr[0],arr[1]); clearTimeout(holdTimer); holdTimer=null; holdStartId=null; }
    if(touchCount()===1 && !first && mode!=='place' && mode!=='label'){ const id=[...touches.keys()][0]; holdStartId=id; const pt=touches.get(id);
      holdTimer=setTimeout(()=>{ const d=downs.get(id); if(!d) return; const move=Math.hypot(pt.sx-d.sx, pt.sy-d.sy); if(move<=TAP_MAX_MOVE){ const hit=findEndpointNear(pt.sx,pt.sy, 24*DPR); if(hit){ mode='edit'; editing=hit; need(); toast('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–µ—Ä–µ—Ç–∞—â–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏'); } } }, HOLD_MS);
    }
  }, {passive:false});

  cv.addEventListener('touchmove', e=>{
    e.preventDefault();
    for(const t of e.changedTouches){ if(!touches.has(t.identifier)) continue; const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY); touches.set(t.identifier,{sx,sy}); }
    if(touchCount()===2){ const arr=[...touches.values()]; const nowCenter=centroid(), nowDist=distance2(arr[0],arr[1]);
      if(prevCenter && prevDist && nowCenter){ const k = nowDist>0 && prevDist>0 ? (nowDist/prevDist) : 1;
        view.tx = nowCenter.sx - k*(nowCenter.sx - view.tx); view.ty = nowCenter.sy - k*(nowCenter.sy - view.ty);
        view.scale = Math.max(0.2, Math.min(8, view.scale*k));
        view.tx += (nowCenter.sx - prevCenter.sx); view.ty += (nowCenter.sy - prevCenter.sy);
        clampView(); need();
      }
      prevCenter=nowCenter; prevDist=nowDist; clearTimeout(holdTimer); holdTimer=null; holdStartId=null; return;
    }
    if(touchCount()===1){ const only=[...touches.values()][0];
      if(mode==='edit' && editing){ const s=segs[editing.segIndex]; const raw=s2w(only.sx, only.sy); const snapped=snapToNodes(raw); if(editing.end==='a') s.a=snapped; else s.b=snapped; need(); return; }
      if(mode==='line' && first){ preview = s2w(only.sx, only.sy); need(); }
    }
  }, {passive:false});

  cv.addEventListener('touchend', e=>{
    e.preventDefault();
    const now=performance.now();
    for(const t of e.changedTouches){
      const down=downs.get(t.identifier);
      const {sx,sy}=getCanvasPointXY(t.clientX,t.clientY);
      const isTap=!!down && (now-down.t0<=TAP_MAX_TIME) && (Math.hypot(sx-down.sx, sy-down.sy)<=TAP_MAX_MOVE);

      if(mode==='edit' && editing){ const s=segs[editing.segIndex]; const snap=snapToNodes(s2w(sx,sy)); if(editing.end==='a') s.a=snap; else s.b=snap; mode='hand'; editing=null; need();
      }else if(isTap && mode==='line'){ const W=s2w(sx,sy); if(!first){ first=W; preview=null; need(); } else { segs.push({a:first,b=W}); first=null; preview=null; mode='hand'; need(); toast('–°–µ–≥–º–µ–Ω—Ç –≥–æ—Ç–æ–≤. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ.'); }
      }else if(isTap && mode==='place'){ const near=findNearestSegment(sx,sy,28*DPR); if(near){ const std = (params.comp.type==='valve'?'BV':(params.comp.type==='check'?'NRV':'P')); comps.push({segIndex:near.segIndex,t:near.t,type:params.comp.type,scale:params.comp.scale,refScale:view.scale,std}); mode='hand'; need(); toast('–ê—Ä–º–∞—Ç—É—Ä–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞'); } else { toast('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∞—Ä–º–∞—Ç—É—Ä—É'); }
      }else if(isTap && mode==='label'){ const near=findNearestSegment(sx,sy,28*DPR); if(near){ pendingLabel={segIndex:near.segIndex,t:near.t}; openTextModal(); } else { toast('–¢–∫–Ω–∏ –ø—Ä—è–º–æ –ø–æ —Ç—Ä—É–±–µ'); } }
      downs.delete(t.identifier); touches.delete(t.identifier);
    }
    if(touchCount()<2){ prevCenter=null; prevDist=null; }
    if(holdStartId!==null){ clearTimeout(holdTimer); holdTimer=null; holdStartId=null; }
  }, {passive:false});

  const hasTouch='ontouchstart' in window;
  if(!hasTouch){
    cv.addEventListener('wheel', e=>{ e.preventDefault(); const {sx,sy}=getCanvasPointXY(e.clientX,e.clientY); const k=e.deltaY<0?1.12:0.9; view.tx = sx - k*(sx - view.tx); view.ty = sy - k*(sy - view.ty); view.scale = Math.max(0.2, Math.min(8, view.scale*k)); clampView(); need(); }, {passive:false});
    let isDown=false,last=null;
    cv.addEventListener('mousedown', e=>{ isDown=true; last=getCanvasPointXY(e.clientX,e.clientY); });
    cv.addEventListener('mousemove', e=>{
      if(!isDown) return;
      const cur=getCanvasPointXY(e.clientX,e.clientY);
      if(mode==='edit' && editing){ const s=segs[editing.segIndex]; const snap=snapToNodes(s2w(cur.sx,cur.sy)); if(editing.end==='a') s.a=snap; else s.b=snap; need();
      }else if(mode!=='line'){ view.tx += (cur.sx-last.sx); view.ty += (cur.sy-last.sy); clampView(); need();
      }else if(mode==='line' && first){ preview=s2w(cur.sx,cur.sy); need(); }
      last=cur;
    });
    addEventListener('mouseup', e=>{
      if(!isDown) return; isDown=false;
      const {sx,sy}=getCanvasPointXY(e.clientX,e.clientY);
      if(mode==='edit' && editing){ const s=segs[editing.segIndex]; const snap=snapToNodes(s2w(sx,sy)); if(editing.end==='a') s.a=snap; else s.b=snap; mode='hand'; editing=null; need(); }
      else if(mode==='line'){ if(!first){ first=s2w(sx,sy); preview=null; need(); } else { segs.push({a:first,b:s2w(sx,sy)}); first=null; preview=null; mode='hand'; need(); } }
      else if(mode==='place'){ const near=findNearestSegment(sx,sy,24*DPR); if(near){ const std=(params.comp.type==='valve'?'BV':(params.comp.type==='check'?'NRV':'P')); comps.push({segIndex:near.segIndex,t:near.t,type:params.comp.type,scale:params.comp.scale,refScale:view.scale,std}); mode='hand'; need(); } }
      else if(mode==='label'){ const near=findNearestSegment(sx,sy,24*DPR); if(near){ pendingLabel={segIndex:near.segIndex,t:near.t}; openTextModal(); } }
    });
  }

  // UI
  const $=id=>document.getElementById(id);
  $('btnLine').onclick=()=>{ mode='line'; first=null; preview=null; toast('–†–µ–∂–∏–º: –ª–∏–Ω–∏—è (—Ç–∞–ø-—Ç–∞–ø)'); };
  $('btnUndo').onclick=()=>{ if(mode==='edit' && editing){ mode='hand'; editing=null; need(); return; } if(mode==='place'||mode==='label'){ mode='hand'; toast('–û—Ç–º–µ–Ω–∞'); return; } if(first){ first=null; preview=null; } else if(labels.length){ labels.pop(); } else if(comps.length){ comps.pop(); } else if(segs.length){ segs.pop(); } need(); };
  $('btnHand').onclick=()=>{ mode='hand'; first=null; preview=null; toast('–†—É–∫–∞: –ø–∞–Ω/–∑—É–º ‚Äî 2 –ø–∞–ª—å—Ü–∞'); };

  const wrap=$('panelWrap'), backdrop=document.getElementById('panelBackdrop'), panel=document.getElementById('panel');
  const openPanel=()=>{ wrap.classList.add('open'); wrap.setAttribute('aria-hidden','false'); };
  const closePanel=()=>{ wrap.classList.remove('open'); wrap.setAttribute('aria-hidden','true'); };
  $('btnSettings').onclick=openPanel; $('btnClosePanel').onclick=closePanel; backdrop.onclick=closePanel;
  ['pointerdown','pointermove','pointerup','touchstart','touchmove','touchend','mousedown','mousemove','mouseup','wheel','click'].forEach(ev=>{ panel.addEventListener(ev, e=>e.stopPropagation(), {passive:false}); });

  const linePx=$('linePx'), linePxVal=$('linePxVal'), lineColor=$('lineColor');
  linePx.oninput=e=>{ params.linePx=+e.target.value; linePxVal.textContent=e.target.value; need(); };
  lineColor.oninput=e=>{ params.lineColor=e.target.value; need(); };
  document.querySelectorAll('.chip').forEach(ch=>{ ch.addEventListener('click',()=>{ const col=ch.getAttribute('data-col'); params.lineColor=col; lineColor.value=col; need(); }); });

  const gridOn=$('gridOn'), gridAlpha=$('gridAlpha'), gridAlphaVal=$('gridAlphaVal');
  const gridStep=$('gridStep'), gridStepVal=$('gridStepVal');
  const gridAngle=$('gridAngle'), gridAngleVal=$('gridAngleVal');
  gridOn.onchange=e=>{ params.grid.on=!!e.target.checked; need(); };
  gridAlpha.oninput=e=>{ params.grid.alpha=(+e.target.value)/100; gridAlphaVal.textContent=e.target.value+'%'; need(); };
  gridStep.oninput=e=>{ params.grid.step=(+e.target.value|0); gridStepVal.textContent=e.target.value; need(); };
  gridAngle.oninput=e=>{ params.grid.angleDeg=(+e.target.value|0); gridAngleVal.textContent=e.target.value; need(); };

  const snapOn=$('snapOn'), snapRadius=$('snapRadius'), snapRadiusVal=$('snapRadiusVal');
  snapOn.onchange=e=>{ params.snap.on=!!e.target.checked; };
  snapRadius.oninput=e=>{ params.snap.radiusPx=+e.target.value|0; snapRadiusVal.textContent=e.target.value; };

  const compScale=$('compScale'), compScaleVal=$('compScaleVal');
  document.querySelectorAll('input[name="comp"]').forEach(r=>{ r.addEventListener('change',()=>{ params.comp.type=r.value; }); });
  compScale.oninput=e=>{ params.comp.scale=(+e.target.value)/100; compScaleVal.textContent=params.comp.scale.toFixed(2)+'√ó'; need(); };
  $('btnPlaceComp').onclick=()=>{ closePanel(); mode='place'; toast('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏ ‚Äî –∞—Ä–º–∞—Ç—É—Ä–∞ –≤—Å—Ç–∞–Ω–µ—Ç –≤ —ç—Ç–æ –º–µ—Å—Ç–æ'); };

  // –ü–æ–¥–ø–∏—Å–∏
  const textModal=document.getElementById('textModal');
  const textInput=document.getElementById('textInput');
  let pendingLabel=null;
  const openTextModal=()=>{ textInput.value=''; textModal.classList.add('show'); textModal.setAttribute('aria-hidden','false'); setTimeout(()=>textInput.focus(),0); };
  const closeTextModal=()=>{ textModal.classList.remove('show'); textModal.setAttribute('aria-hidden','true'); pendingLabel=null; };
  document.querySelector('#textModal .bg').onclick=closeTextModal;
  document.getElementById('textCancel').onclick=closeTextModal;
  document.getElementById('textOk').onclick=()=>{ const v=textInput.value.trim(); if(v && pendingLabel){ labels.push({segIndex:pendingLabel.segIndex, t:pendingLabel.t, text:v, offset:18}); need(); toast('–ü–æ–¥–ø–∏—Å—å –¥–æ–±–∞–≤–ª–µ–Ω–∞'); } closeTextModal(); mode='hand'; };
  $('btnAddLabel').onclick=()=>{ closePanel(); mode='label'; toast('–¢–∫–Ω–∏ –ø–æ —Ç—Ä—É–±–µ ‚Äî –ø–æ—è–≤–∏—Ç—Å—è –æ–∫–Ω–æ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞'); };

  // –§–æ—Ç–æ
  function loadImageFile(f){ if(!f) return; const img=new Image(); img.onload=()=>{ const maxSide=Math.max(img.naturalWidth,img.naturalHeight); let w=img.naturalWidth,h=img.naturalHeight; if(maxSide>2200){ const sc=2200/maxSide; w=Math.round(w*sc); h=Math.round(h*sc); } const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d',{alpha:false}).drawImage(img,0,0,w,h); bg=c; bw=w; bh=h; fitToScreen(); need(); toast('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ'); }; img.src=URL.createObjectURL(f); }
  document.getElementById('fileCam').onchange=e=>loadImageFile(e.target.files?.[0]);
  document.getElementById('fileGal').onchange=e=>loadImageFile(e.target.files?.[0]);
  document.getElementById('btnExport').onclick=()=>{ const url=cv.toDataURL('image/png',0.95); const a=document.createElement('a'); a.href=url; a.download='ProTrace.png'; a.click(); };

  fit();
  toast('–õ–∏–Ω–∏—è: –¢–ê–ü‚Üí–¢–ê–ü. –í–µ–Ω—Ç–∏–ª—å: —Ä—É—á–∫–∞ –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É. ISO-–±–µ–π–¥–∂–∏: BV / NRV / P. –ü–æ–¥–ø–∏—Å–∏ ‚Äî —á–µ—Ä–µ–∑ ¬´–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å—å¬ª.');
})();
</script>
</body>
</html>