<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pro Trace ‚Äî v819</title>
<style>
  :root{--violet:#8000ff; --violet2:#6b1dff; --border:#e7e3f7}
  html,body{margin:0;height:100%;background:#f2f3f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#fff;touch-action:none;user-select:none;-webkit-user-select:none}

  .bar{position:fixed;left:8px;right:56px;top:8px;z-index:1000;display:flex;gap:8px}
  .btn{height:44px;padding:0 16px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--violet2),var(--violet));color:#fff;font-weight:800}
  .btn.ghost{background:linear-gradient(180deg,#8c8c8c,#6a6a6a)}
  .gear{position:fixed;top:8px;right:8px;width:44px;height:44px;border-radius:12px;border:1px solid var(--border);background:#fff;color:#5b30c2;font-weight:800;z-index:1001}

  .panel-wrap{position:fixed;inset:0;z-index:1050;display:none}
  .panel-wrap.open{display:block}
  .panel-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.18)}
  .panel{position:absolute;top:64px;right:8px;background:#fff;border:1px solid var(--border);
         border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:12px;width:min(92vw,360px);
         max-height:80vh;overflow:auto}
  .panel h4{margin:6px 0 8px 0;font-size:15px}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{min-width:150px;font-size:13px;color:#444}
  .hr{height:1px;background:#eee;margin:10px 0}
  .close{position:sticky;top:0;margin:-6px -6px 6px auto;background:#fff;border:1px solid var(--border);width:32px;height:32px;border-radius:8px}

  .radio-row{display:flex;gap:10px;flex-wrap:wrap}
  .radio{display:flex;align-items:center;gap:6px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;font-size:12px;color:#333}
  .radio input{accent-color:#6b1dff}

  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#1f1f2e;color:#fff;padding:10px 12px;border-radius:12px;opacity:0;transition:.25s;z-index:1200;pointer-events:none;max-width:92vw;text-align:center}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine" class="btn">üìê –õ–∏–Ω–∏—è</button>
    <button id="btnUndo" class="btn ghost">‚Ü© –ù–∞–∑–∞–¥</button>
    <button id="btnHand" class="btn ghost">üñê –†—É–∫–∞</button>
  </div>
  <button id="btnSettings" class="gear" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öô</button>

  <div id="panelWrap" class="panel-wrap" aria-hidden="true">
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <div id="panel" class="panel" role="dialog" aria-modal="true">
      <button id="btnClosePanel" class="close" title="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>

      <h4>–§–æ—Ç–æ</h4>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üì∑ –ö–∞–º–µ—Ä–∞
          <input id="fileCam" type="file" accept="image/*" capture="environment" style="position:absolute;inset:0;opacity:0">
        </label>
        <label class="btn ghost" style="position:relative;min-width:120px;display:inline-flex;justify-content:center">üìÇ –ì–∞–ª–µ—Ä–µ—è
          <input id="fileGal" type="file" accept="image/*" style="position:absolute;inset:0;opacity:0">
        </label>
        <button id="btnExport" class="btn ghost" style="margin-left:auto">‚§ì PNG</button>
      </div>

      <div class="hr"></div>
      <h4>–ê—Ä–º–∞—Ç—É—Ä–∞</h4>
      <div class="row radio-row">
        <label class="radio"><input type="radio" name="comp" value="valve" checked> –®–∞—Ä–æ–≤—ã–π –∫—Ä–∞–Ω (BALL)</label>
        <label class="radio"><input type="radio" name="comp" value="check"> –û–±—Ä–∞—Ç–Ω—ã–π –∫–ª–∞–ø–∞–Ω (CHECK)</label>
        <label class="radio"><input type="radio" name="comp" value="pump"> –ù–∞—Å–æ—Å (PUMP)</label>
      </div>
      <div class="row">
        <label for="scale">–ú–∞—Å—à—Ç–∞–± –∞—Ä–º–∞—Ç—É—Ä—ã</label>
        <input id="scale" type="range" min="60" max="180" step="10" value="100" style="flex:1">
        <span id="scaleVal" style="width:48px;text-align:right;font-size:12px;color:#555">1.00√ó</span>
      </div>
      <div class="row" style="justify-content:flex-end;gap:8px">
        <button id="btnPlaceComp" class="btn">–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —Ç—Ä—É–±—É</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(()=>{
  // ===== helpers & global =====
  const toast=(t,ms=1600)=>{const el=document.getElementById('toast');el.textContent=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),ms);};
  window.addEventListener('error', e=>toast('–û—à–∏–±–∫–∞: '+(e.message||'unknown')));

  const DPR=Math.max(1,window.devicePixelRatio||1);
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d',{alpha:false});

  // ===== scene =====
  const view={scale:1,tx:0,ty:0};
  let bg=null,bw=0,bh=0;

  const segs=[];              // {a:{x,y}, b:{x,y}}
  const comps=[];             // {segIndex,t,type}

  let mode='hand';            // hand | line | edit | place
  let first=null, preview=null;
  let editing=null;

  const params={
    linePx:10,               // —Ç–æ–ª—â–∏–Ω–∞ —Ç—Ä—É–±—ã (–≤ –ø–∏–∫—Å–µ–ª—è—Ö —ç–∫—Ä–∞–Ω–∞)
    lineColor:'#1f6bff',
    snapRadiusPx:22
  };
  let compScale = 1.0;        // –º–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–∑–º–µ—Ä–∞ –∞—Ä–º–∞—Ç—É—Ä—ã (–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å —Ç—Ä—É–±–æ–π)

  const sPx = (px)=>px/view.scale; // —ç–∫—Ä–∞–Ω–Ω—ã–µ –ø–∏–∫—Å–µ–ª–∏ -> –º–∏—Ä–æ–≤—ã–µ –µ–¥–∏–Ω–∏—Ü—ã
  const darker=(hex,k=0.45)=>{const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return '#333'; let [r,g,b]=[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)]; r=Math.max(0,Math.floor(r*(1-k))); g=Math.max(0,Math.floor(g*(1-k))); b=Math.max(0,Math.floor(b*(1-k))); return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); };

  // ===== fit / coords =====
  function fit(){ cv.width=Math.round(innerWidth*DPR); cv.height=Math.round(innerHeight*DPR); if(bg && view.scale===1 && view.tx===0 && view.ty===0) fitToScreen(); need(); }
  addEventListener('resize',fit);
  function fitToScreen(){ if(!bg) return; const k=Math.min(cv.width/bw,cv.height/bh); view.scale=k; view.tx=(cv.width-bw*k)/2; view.ty=(cv.height-bh*k)/2; }
  const s2w=(sx,sy)=>({x:(sx-view.tx)/view.scale,y:(sy-view.ty)/view.scale});
  const w2s=(x,y)=>({x:x*view.scale+view.tx,y:y*view.scale+view.ty});
  function clampView(){ if(!bg) return; const W=cv.width,H=cv.height,CW=bw*view.scale,CH=bh*view.scale; const minTx=Math.min(0,W-CW),maxTx=Math.max(0,W-CW); const minTy=Math.min(0,H-CH),maxTy=Math.max(0,H-CH); view.tx=Math.min(maxTx,Math.max(minTx,view.tx)); view.ty=Math.min(maxTy,Math.max(minTy,view.ty)); }

  // ===== geometry helpers =====
  function drawSegments(){
    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    const col=params.lineColor, sh=darker(col,0.45);
    for(const s of segs){
      ctx.strokeStyle=sh; ctx.globalAlpha=.75; ctx.lineWidth=(params.linePx+2)/view.scale;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
      ctx.strokeStyle=col; ctx.globalAlpha=1; ctx.lineWidth=(params.linePx)/view.scale;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
    }
  }
  function drawHandleMarker(pt){
    const p=w2s(pt.x,pt.y); ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#16a34a'; ctx.strokeStyle='#0f5132'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }
  function segGeom(seg){ const vx=seg.b.x-seg.a.x, vy=seg.b.y-seg.a.y; const L=Math.hypot(vx,vy)||1; return {vx,vy,L,nx:vx/L,ny:vy/L}; }
  function compBasis(seg,t){ const g=segGeom(seg); const x=seg.a.x+g.nx*g.L*t, y=seg.a.y+g.ny*g.L*t; return {x,y,ux:g.nx,uy:g.ny,nx:-g.ny,ny:g.nx}; }

  function drawBadge(sx,sy,txt){
    const padH=6, r=7, h=18; ctx.setTransform(1,0,0,1,0,0); ctx.font='700 11px system-ui,-apple-system,Segoe UI,Roboto';
    const w=ctx.measureText(txt).width+padH*2; const x=sx+8, y=sy-8-h;
    ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#111'; ctx.lineWidth=1;
    ctx.beginPath(); const rr=Math.min(r,w/2,h/2);
    ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle='#111'; ctx.textBaseline='middle'; ctx.fillText(txt, x+padH, y+h/2);
  }

  // ===== components (–º–∞—Å—à—Ç–∞–±–∏—Ä—É—é—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å —Ç—Ä—É–±–æ–π) =====
  function drawBallValve(seg,t){
    // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —à–∞—Ä–æ–≤—ã–π –∫—Ä–∞–Ω: –∫–∞–ø—Å—É–ª–∞ (—Å–∫—Ä—É–≥–ª—ë–Ω–Ω—ã–µ —Ç–æ—Ä—Ü—ã), —à–∞—Ä, —à–µ–π–∫–∞ –∏ —É—Ç–æ–ª—â—ë–Ω–Ω—ã–π —Ä—ã—á–∞–≥
    const b=compBasis(seg,t);
    const base = sPx(params.linePx);
    const len   = base * 12 * compScale;   // –¥–ª–∏–Ω–∞ –∫–æ—Ä–ø—É—Å–∞ (–∫–∞–ø—Å—É–ª—ã)
    const radY  = base * 3.4 * compScale;  // —Ä–∞–¥–∏—É—Å –ø–æ–ø–µ—Ä—ë–∫ —Ç—Ä—É–±—ã (—Ç–æ–ª—â–∏–Ω–∞ –∫–æ—Ä–ø—É—Å–∞)
    const ballR = base * 2.3 * compScale;  // —Ä–∞–¥–∏—É—Å —à–∞—Ä–∞
    const neckH = base * 2.6 * compScale;  // –≤—ã—Å–æ—Ç–∞ —à–µ–π–∫–∏
    const neckR = base * 1.0 * compScale;  // —Ä–∞–¥–∏—É—Å —à–µ–π–∫–∏
    const hndlL = base * 7.0 * compScale;  // –¥–ª–∏–Ω–∞ —Ä—É—á–∫–∏
    const hndlW = base * 0.9 * compScale;  // —Ç–æ–ª—â–∏–Ω–∞ —Ä—É—á–∫–∏
    const lw    = Math.max(1, sPx(2.0));

    const Lx=b.x - b.ux*len/2, Ly=b.y - b.uy*len/2; // —Ü–µ–Ω—Ç—Ä –ª–µ–≤–æ–≥–æ —Ç–æ—Ä—Ü–∞
    const Rx=b.x + b.ux*len/2, Ry=b.y + b.uy*len/2; // —Ü–µ–Ω—Ç—Ä –ø—Ä–∞–≤–æ–≥–æ —Ç–æ—Ä—Ü–∞
    const theta = Math.atan2(b.ny, b.nx);           // —É–≥–æ–ª –Ω–æ—Ä–º–∞–ª–∏ (–ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä –∫ —Ç—Ä—É–±–µ)

    ctx.save();
    ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.strokeStyle='#111'; ctx.lineWidth=lw; ctx.lineJoin='round'; ctx.lineCap='round';

    // –ö–æ—Ä–ø—É—Å-–∫–∞–ø—Å—É–ª–∞ (–¥–≤–∞ –ø–æ–ª—É–æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ + –¥–≤–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã)
    ctx.beginPath();
    // –Ω–∏–∂–Ω—è—è –ø—Ä—è–º–∞—è (—Å -normal —Å—Ç–æ—Ä–æ–Ω—ã)
    ctx.moveTo(Lx - b.nx*radY, Ly - b.ny*radY);
    ctx.lineTo(Rx - b.nx*radY, Ry - b.ny*radY);
    // –ø—Ä–∞–≤—ã–π —Ç–æ—Ä–µ—Ü (–ø–æ–ª—É–æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å –æ—Ç -normal –∫ +normal)
    ctx.arc(Rx, Ry, radY, theta - Math.PI/2, theta + Math.PI/2, false);
    // –≤–µ—Ä—Ö–Ω—è—è –ø—Ä—è–º–∞—è (—Å +normal —Å—Ç–æ—Ä–æ–Ω—ã)
    ctx.lineTo(Lx + b.nx*radY, Ly + b.ny*radY);
    // –ª–µ–≤—ã–π —Ç–æ—Ä–µ—Ü (–ø–æ–ª—É–æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å –æ—Ç +normal –∫ -normal)
    ctx.arc(Lx, Ly, radY, theta + Math.PI/2, theta - Math.PI/2, false);
    ctx.closePath();
    ctx.stroke();

    // –ù–µ–±–æ–ª—å—à–∏–µ ¬´–ø–µ—Ä–µ—Ö–æ–¥—ã¬ª –∫ —Ç—Ä—É–±–µ (—Ç–æ–Ω–∫–∏–µ —Ñ–∞—Å–∫–∏)
    const cham = base*1.4*compScale;
    ctx.beginPath();
    ctx.moveTo(Lx - b.nx*(radY*0.65), Ly - b.ny*(radY*0.65));
    ctx.lineTo(Lx - b.ux*cham - b.nx*(radY*0.45), Ly - b.uy*cham - b.ny*(radY*0.45));
    ctx.moveTo(Lx + b.nx*(radY*0.65), Ly + b.ny*(radY*0.65));
    ctx.lineTo(Lx - b.ux*cham + b.nx*(radY*0.45), Ly - b.uy*cham + b.ny*(radY*0.45));
    ctx.moveTo(Rx - b.nx*(radY*0.65), Ry - b.ny*(radY*0.65));
    ctx.lineTo(Rx + b.ux*cham - b.nx*(radY*0.45), Ry + b.uy*cham - b.ny*(radY*0.45));
    ctx.moveTo(Rx + b.nx*(radY*0.65), Ry + b.ny*(radY*0.65));
    ctx.lineTo(Rx + b.ux*cham + b.nx*(radY*0.45), Ry + b.uy*cham + b.ny*(radY*0.45));
    ctx.stroke();

    // –®–∞—Ä
    ctx.beginPath(); ctx.arc(b.x,b.y,ballR,0,Math.PI*2); ctx.stroke();

    // –®–µ–π–∫–∞ (–∫—Ä—É–≥–ª–∞—è ¬´–∫—Ä—ã—à–∫–∞¬ª + —Å—Ç–æ–π–∫–∞ –ø–æ –Ω–æ—Ä–º–∞–ª–∏ –≤–≤–µ—Ä—Ö)
    const topX=b.x + b.nx*radY, topY=b.y + b.ny*radY;
    ctx.beginPath(); ctx.arc(b.x,b.y,neckR,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(topX,topY); ctx.stroke();

    // –†—ã—á–∞–≥ (—É—Ç–æ–ª—â—ë–Ω–Ω—ã–π)
    ctx.save();
    ctx.lineWidth=hndlW;
    ctx.beginPath();
    ctx.moveTo(topX, topY);
    ctx.lineTo(topX + b.ux*hndlL, topY + b.uy*hndlL);
    ctx.stroke();
    ctx.restore();

    ctx.restore();

    const S=w2s(b.x,b.y); drawBadge(S.x,S.y,'BALL');
  }

  function drawCheckValve(seg,t){
    const b=compBasis(seg,t);
    const base = sPx(params.linePx);
    const seatLen = base*9.0*compScale;
    const flangeR = base*2.8*compScale;
    const lw   = Math.max(1, sPx(2.0));

    ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.strokeStyle='#111'; ctx.lineWidth=lw;

    const Lx=b.x - b.ux*seatLen/2, Ly=b.y - b.uy*seatLen/2;
    const Rx=b.x + b.ux*seatLen/2, Ry=b.y + b.uy*seatLen/2;

    // —Ñ–ª–∞–Ω—Ü—ã
    ctx.beginPath(); ctx.arc(Lx,Ly,flangeR,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(Rx,Ry,flangeR,0,Math.PI*2); ctx.stroke();

    // –ø–µ—Ä–µ–º—ã—á–∫–∞
    ctx.lineWidth=Math.max(1, sPx(1.8));
    ctx.beginPath(); ctx.moveTo(Lx,Ly); ctx.lineTo(Rx,Ry); ctx.stroke();

    // —Å–∏–º–≤–æ–ª "–¥–≤–æ–π–Ω–æ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫"
    ctx.lineWidth=Math.max(1, sPx(2.2));
    const symLen = base*5.8*compScale, symW = base*3.6*compScale, ax=b.ux, ay=b.uy;
    const A = { x:b.x - ax*symLen/2 - b.nx*symW/2, y:b.y - ay*symLen/2 - b.ny*symW/2 };
    const B = { x:b.x - ax*symLen/2 + b.nx*symW/2, y:b.y - ay*symLen/2 + b.ny*symW/2 };
    const C = { x:b.x,                              y:b.y };
    const D = { x:b.x + ax*symLen/2 + b.nx*symW/2,  y:b.y + ay*symLen/2 + b.ny*symW/2 };
    const E = { x:b.x + ax*symLen/2 - b.nx*symW/2,  y:b.y + ay*symLen/2 - b.ny*symW/2 };
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(C.x,C.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(D.x,D.y); ctx.lineTo(C.x,C.y); ctx.lineTo(E.x,E.y); ctx.stroke();

    ctx.restore();
    const S=w2s(b.x,b.y); drawBadge(S.x,S.y,'CHECK');
  }

  function drawPump(seg,t){
    const b=compBasis(seg,t);
    const base = sPx(params.linePx);
    const R = base*4.0*compScale;
    const lw = Math.max(1, sPx(2.4));

    ctx.save(); ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
    ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=lw;
    ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill(); ctx.stroke();

    // –ª–æ–ø–∞—Å—Ç—å
    const aLen=R*0.9;
    ctx.strokeStyle='#111'; ctx.lineWidth=Math.max(1, sPx(2.2)); ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(b.x - b.ux*aLen*0.4, b.y - b.uy*aLen*0.4); ctx.lineTo(b.x + b.ux*aLen*0.5, b.y + b.uy*aLen*0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(b.x + b.ux*aLen*0.5, b.y + b.uy*aLen*0.5);
    ctx.lineTo(b.x + b.ux*aLen*0.28 + (-b.uy)*aLen*0.22, b.y + b.uy*aLen*0.28 + ( b.ux)*aLen*0.22);
    ctx.lineTo(b.x + b.ux*aLen*0.28 - (-b.uy)*aLen*0.22, b.y + b.uy*aLen*0.28 - ( b.ux)*aLen*0.22);
    ctx.closePath(); ctx.fillStyle='#111'; ctx.fill();

    ctx.restore();
    const S=w2s(b.x,b.y); drawBadge(S.x,S.y,'PUMP');
  }

  // ===== main draw =====
  function draw(){
    ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);
    if(bg){ ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty); ctx.drawImage(bg,0,0,bw,bh); }
    drawSegments();

    for(const c of comps){ const seg=segs[c.segIndex]; if(!seg) continue;
      if(c.type==='valve') drawBallValve(seg,c.t);
      else if(c.type==='check') drawCheckValve(seg,c.t);
      else if(c.type==='pump') drawPump(seg,c.t);
    }

    if(first){
      const p=w2s(first.x,first.y);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle='#ff3b30'; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }
    if(first && preview){
      ctx.setTransform(view.scale,0,0,view.scale,view.tx,view.ty);
      ctx.setLineDash([12/view.scale,8/view.scale]);
      ctx.strokeStyle=params.lineColor; ctx.lineWidth=Math.max(3,params.linePx-2)/view.scale;
      ctx.beginPath(); ctx.moveTo(first.x,first.y); ctx.lineTo(preview.x,preview.y); ctx.stroke();
      ctx.setLineDash([]);
      const p=w2s(preview.x,preview.y);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle=params.lineColor;
      ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
    }
    if(mode==='edit' && editing){ const s=segs[editing.segIndex]; drawHandleMarker(editing.end==='a'?s.a:s.b); }
  }
  let raf=0, dirty=false;
  const need=()=>{ dirty=true; if(!raf){ raf=requestAnimationFrame(()=>{ raf=0; if(dirty){ dirty=false; draw(); } }); } };

  // ===== hit & snap =====
  function allNodes(){ const out=[]; for(const s of segs){ out.push(s.a,s.b);} return out; }
  function snapToNodes(raw){ const R=params.snapRadiusPx/view.scale; let best=null,bd=Infinity;
    for(const n of allNodes()){ const d=Math.hypot(n.x-raw.x,n.y-raw.y); if(d<bd){ bd=d; best=n; } }
    if(best && bd<=R) return {x:best.x,y:best.y}; return raw;
  }
  function findEndpointNear(sx,sy,rPx=20){ let best=null,bd=Infinity;
    for(let i=0;i<segs.length;i++){ const s=segs[i]; const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y);
      const dA=Math.hypot(A.x-sx,A.y-sy), dB=Math.hypot(B.x-sx,B.y-sy);
      if(dA<bd && dA<=rPx){ best={segIndex:i,end:'a'}; bd=dA; }
      if(dB<bd && dB<=rPx){ best={segIndex=i,end:'b'}; bd=dB; }
    }
    return best;
  }
  function findNearestSegment(sx,sy,maxDistPx=28){ let bestI=-1,bd=Infinity,bt=0;
    for(let i=0;i<segs.length;i++){ const s=segs[i]; const A=w2s(s.a.x,s.a.y), B=w2s(s.b.x,s.b.y);
      const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy; if(len2===0) continue;
      const t=Math.max(0,Math.min(1,((sx-A.x)*vx+(sy-A.y)*vy)/len2));
      const pxs=A.x+vx*t, pys=A.y+vy*t, d=Math.hypot(pxs-sx,pys-sy);
      if(d<bd){ bd=d; bestI=i; bt=t; }
    }
    if(bestI!==-1 && bd<=maxDistPx) return {segIndex:bestI,t:bt};
    return null;
  }

  // ===== input: Pointer Events =====
  const TAP_TIME=300, TAP_MOVE=14*DPR, HOLD_MS=500;
  const pointers=new Map();     // id -> {sx,sy}
  const downs=new Map();        // id -> {t0,sx,sy}
  let prevCenter=null, prevDist=null;
  let holdTimer=null, holdId=null;

  function centroid(){ const a=[...pointers.values()]; if(!a.length) return null; let sx=0,sy=0; for(const p of a){ sx+=p.sx; sy+=p.sy; } return {sx:sx/a.length, sy:sy/a.length}; }
  function dist2(a,b){ return Math.hypot(a.sx-b.sx,a.sy-b.sy); }
  function canvasXY(e){ const r=cv.getBoundingClientRect(); return { sx:(e.clientX-r.left)*(cv.width/r.width), sy:(e.clientY-r.top)*(cv.height/r.height) }; }

  cv.addEventListener('pointerdown', e=>{
    e.preventDefault(); cv.setPointerCapture?.(e.pointerId);
    const {sx,sy}=canvasXY(e);
    pointers.set(e.pointerId,{sx,sy});
    downs.set(e.pointerId,{t0:performance.now(),sx,sy});
    if(pointers.size===2){
      prevCenter=centroid();
      const arr=[...pointers.values()];
      prevDist=Math.hypot(arr[0].sx-arr[1].sx, arr[0].sy-arr[1].sy);
      clearTimeout(holdTimer); holdTimer=null; holdId=null;
    }else if(pointers.size===1 && !first && mode!=='place'){
      holdId=e.pointerId;
      holdTimer=setTimeout(()=>{
        const d=downs.get(holdId), pt=pointers.get(holdId); if(!d||!pt) return;
        const mv=Math.hypot(pt.sx-d.sx, pt.sy-d.sy);
        if(mv<=TAP_MOVE){ const hit=findEndpointNear(pt.sx,pt.sy,24*DPR);
          if(hit){ mode='edit'; editing=hit; need(); toast('–ü—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ü–∞: –ø–µ—Ä–µ—Ç–∞—â–∏ –∏ –æ—Ç–ø—É—Å—Ç–∏'); }
        }
      }, HOLD_MS);
    }
  }, {passive:false});

  cv.addEventListener('pointermove', e=>{
    if(!pointers.has(e.pointerId)) return;
    const {sx,sy}=canvasXY(e);
    pointers.set(e.pointerId,{sx,sy});

    if(pointers.size===2){
      const arr=[...pointers.values()];
      const nowCenter=centroid();
      const nowDist=Math.hypot(arr[0].sx-arr[1].sx, arr[0].sy-arr[1].sy);
      if(prevCenter && prevDist && nowCenter){
        const k = nowDist>0 && prevDist>0 ? (nowDist/prevDist) : 1;
        view.tx = nowCenter.sx - k*(nowCenter.sx - view.tx);
        view.ty = nowCenter.sy - k*(nowCenter.sy - view.ty);
        view.scale = Math.max(0.2, Math.min(8, view.scale*k));
        view.tx += (nowCenter.sx - prevCenter.sx);
        view.ty += (nowCenter.sy - prevCenter.sy);
        clampView(); need();
      }
      prevCenter=nowCenter; prevDist=nowDist;
      clearTimeout(holdTimer); holdTimer=null; holdId=null;
      return;
    }

    const only=[...pointers.values()][0];
    if(mode==='edit' && editing){
      const s=segs[editing.segIndex]; const snap=snapToNodes(s2w(only.sx,only.sy));
      if(editing.end==='a') s.a=snap; else s.b=snap; need(); return;
    }
    if(mode==='hand'){
      const d=downs.get(e.pointerId); if(d){ view.tx += (only.sx - d.sx); view.ty += (only.sy - d.sy); d.sx=only.sx; d.sy=only.sy; clampView(); need(); }
    }
    if(mode==='line' && first){ preview=s2w(only.sx,only.sy); need(); }
  }, {passive:false});

  cv.addEventListener('pointerup', e=>{
    const d=downs.get(e.pointerId);
    const p=pointers.get(e.pointerId)||{sx:0,sy:0};
    const isTap = !!d && (performance.now()-d.t0<=TAP_TIME) && (Math.hypot(p.sx-d.sx, p.sy-d.sy)<=TAP_MOVE);

    if(mode==='edit' && editing){
      const snap=snapToNodes(s2w(p.sx,p.sy));
      const s=segs[editing.segIndex]; if(editing.end==='a') s.a=snap; else s.b=snap;
      mode='hand'; editing=null; need();
    }else if(isTap && mode==='line'){
      const W=s2w(p.sx,p.sy);
      if(!first){ first=W; preview=null; need(); }
      else{ segs.push({a:first,b:W}); first=null; preview=null; mode='hand'; need(); toast('–°–µ–≥–º–µ–Ω—Ç –≥–æ—Ç–æ–≤. –ù–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ.'); }
    }else if(isTap && mode==='place'){
      const near=findNearestSegment(p.sx,p.sy,28*DPR);
      if(near){ comps.push({segIndex:near.segIndex,t:near.t,type:currentComp}); mode='hand'; need(); toast('–ê—Ä–º–∞—Ç—É—Ä–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞'); }
      else{ toast('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∞—Ä–º–∞—Ç—É—Ä—É'); }
    }

    downs.delete(e.pointerId); pointers.delete(e.pointerId);
    if(pointers.size<2){ prevCenter=null; prevDist=null; }
    clearTimeout(holdTimer); holdTimer=null; holdId=null;
  }, {passive:false});
  cv.addEventListener('pointercancel', e=>{
    downs.delete(e.pointerId); pointers.delete(e.pointerId);
    if(pointers.size<2){ prevCenter=null; prevDist=null; }
    clearTimeout(holdTimer); holdTimer=null; holdId=null;
  }, {passive:false});

  // ===== UI =====
  const $=id=>document.getElementById(id);
  $('btnLine').onclick=()=>{ mode='line'; first=null; preview=null; toast('–†–µ–∂–∏–º: –ª–∏–Ω–∏—è (—Ç–∞–ø-—Ç–∞–ø)'); };
  $('btnUndo').onclick=()=>{ if(mode==='edit'&&editing){ mode='hand'; editing=null; need(); return; } if(mode==='place'){ mode='hand'; toast('–û—Ç–º–µ–Ω–∞'); return; } if(first){ first=null; preview=null; } else if(comps.length){ comps.pop(); } else if(segs.length){ segs.pop(); } need(); };
  $('btnHand').onclick=()=>{ mode='hand'; first=null; preview=null; toast('–†—É–∫–∞: –ø–∞–Ω/–∑—É–º ‚Äî 2 –ø–∞–ª—å—Ü–∞; –ø–∞–Ω –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º –≤ —Ä–µ–∂–∏–º–µ ¬´–†—É–∫–∞¬ª'); };

  const wrap=$('panelWrap'), backdrop=$('panelBackdrop'), panel=$('panel');
  const openPanel=()=>{ wrap.classList.add('open'); wrap.setAttribute('aria-hidden','false'); };
  const closePanel=()=>{ wrap.classList.remove('open'); wrap.setAttribute('aria-hidden','true'); };
  $('btnSettings').onclick=openPanel; $('btnClosePanel').onclick=closePanel; backdrop.onclick=closePanel;
  ['pointerdown','pointermove','pointerup','click','wheel'].forEach(ev=>panel.addEventListener(ev, e=>e.stopPropagation(), {passive:false}));

  // –≤–µ—Ä—Å–∏—è –∏–∑ URL
  const ver = new URLSearchParams(location.search).get('v') || 'v819';

  // –§–æ—Ç–æ
  function resetInputs(){ const c=$('fileCam'), g=$('fileGal'); if(c) c.value=''; if(g) g.value=''; }
  function loadImageFile(f){
    if(!f) return;
    const img=new Image();
    const url=URL.createObjectURL(f);
    img.onload=()=>{ 
      const maxSide=Math.max(img.naturalWidth,img.naturalHeight);
      let w=img.naturalWidth,h=img.naturalHeight;
      if(maxSide>2200){ const sc=2200/maxSide; w=Math.round(w*sc); h=Math.round(h*sc); }
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      c.getContext('2d',{alpha:false}).drawImage(img,0,0,w,h);
      bg=c; bw=w; bh=h; fitToScreen(); need(); toast('–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ');
      URL.revokeObjectURL(url);
      resetInputs();
    };
    img.onerror=()=>{ URL.revokeObjectURL(url); resetInputs(); toast('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); };
    img.src=url;
  }
  $('fileCam').onchange=e=>loadImageFile(e.target.files?.[0]);
  $('fileGal').onchange=e=>loadImageFile(e.target.files?.[0]);
  $('btnExport').onclick=()=>{
    const url=cv.toDa
    taURL('image/png',0.95);
    const a=document.createElement('a'); a.href=url; a.download='ProTrace.png'; a.click();
  };

  // –ê—Ä–º–∞—Ç—É—Ä–∞
  let currentComp='valve';
  document.querySelectorAll('input[name="comp"]').forEach(r=>r.addEventListener('change',()=>{ currentComp=r.value; }));

  const scaleInput=$('scale'), scaleVal=$('scaleVal');
  const updateScale=()=>{ compScale = Number(scaleInput.value)/100; scaleVal.textContent = compScale.toFixed(2)+'√ó'; need(); };
  scaleInput.addEventListener('input', updateScale); updateScale();

  $('btnPlaceComp').onclick=()=>{ closePanel(); mode='place'; toast('–¢–∫–Ω–∏ –ø–æ –ª–∏–Ω–∏–∏ ‚Äî –ø–æ—Å—Ç–∞–≤–ª—é –∞—Ä–º–∞—Ç—É—Ä—É'); };

  // —Å—Ç–∞—Ä—Ç
  fit();
  toast(`${ver}: —à–∞—Ä–æ–≤—ã–π –∫—Ä–∞–Ω ‚Äî –∫–∞–ø—Å—É–ª–∞, —à–∞—Ä, —à–µ–π–∫–∞, —É—Ç–æ–ª—â—ë–Ω–Ω—ã–π —Ä—ã—á–∞–≥. –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∏ –∑—É–º–µ.`);
})();
</script>
</body>
</html>
