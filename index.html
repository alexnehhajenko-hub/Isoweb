pe html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Pro Trace — единый зум (фото+трубы) и продолжение линии</title>
<style>
  :root{--bg:#ffffff;--fg:#0f1115;--ui:#f2f3f7;--bd:#d9dbe3;--acc:#2979ff}
  *{-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;overflow:hidden}
  #cv{position:fixed;inset:0;touch-action:none}
  .bar{position:fixed;left:10px;top:10px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  .btn{background:var(--ui);border:1px solid var(--bd);color:var(--fg);padding:10px 14px;border-radius:12px;font-weight:700}
  .btn.active{outline:2px solid var(--acc)}
  .zoom{position:fixed;right:10px;top:10px;display:flex;gap:8px;z-index:10}
  .zbtn{background:#fff;border:1px solid var(--bd);border-radius:12px;padding:10px 14px;font-weight:800}
  #status{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.65);color:#fff;padding:8px 12px;border-radius:10px;font-size:14px;z-index:11}
  #hud{position:fixed;right:10px;bottom:10px;z-index:11;background:rgba(0,0,0,.65);color:#fff;border-radius:10px;
    padding:8px 10px;display:none;align-items:center;gap:8px;flex-wrap:wrap}
  #hud .val{min-width:90px}
  #file{display:none}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="bar">
    <button id="btnLine"  class="btn">Линия</button>
    <button id="btnUndo"  class="btn">Назад</button>
    <button id="btnPhoto" class="btn">Фото</button>
    <button id="btnCenter" class="btn">Центр</button>
    <button id="btnSave"  class="btn">Сохранить</button>
  </div>
  <div class="zoom">
    <button id="btnMinus" class="zbtn">−</button>
    <button id="btnPlus"  class="zbtn">+</button>
  </div>

  <input id="file" type="file" accept="image/*"/>
  <div id="hud"><span class="val" id="hudAngle">∠ 0°</span><span class="val" id="hudLen">L 0</span></div>
  <div id="status">Линия → 1-й тап → 2-й тап. Панорамирование одним пальцем (вне рисования). +/− — общий зум (фото+трубы).</div>

<script>
(()=>{
// ===== Состояние (единый мир: фото + трубы под одной трансформацией)
const S={
  scale:1, ox:innerWidth/2, oy:innerHeight/2, minS:.2, maxS:8,
  img:null, iw:0, ih:0,
  // фото в мировых координатах
  bgX:0, bgY:0, bgS:1,
  pipe:40, grid:40,
  segs:[],
  state:'idle', first:null, preview:null,
  nodes:[], dragNode:null,
  pointers:new Map(), activeId:null, pinch:null,
  tap:{x:0,y:0,t:0,moved:false,id:null},
  cooldownUntil:0,
};
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const btnLine=byId('btnLine'), btnUndo=byId('btnUndo'), btnPhoto=byId('btnPhoto');
const btnCenter=byId('btnCenter'), btnSave=byId('btnSave');
const btnPlus=byId('btnPlus'), btnMinus=byId('btnMinus');
const fileInp=byId('file'); const statusEl=byId('status');
const hud=byId('hud'), hudAngle=byId('hudAngle'), hudLen=byId('hudLen');
function byId(id){return document.getElementById(id)}
const setStatus=t=>statusEl.textContent='Статус: '+t;

// ===== Размер
function resize(){
  const dpr=Math.max(1,devicePixelRatio||1);
  cv.width=Math.round(innerWidth*dpr); cv.height=Math.round(innerHeight*dpr);
  cv.style.width=innerWidth+'px'; cv.style.height=innerHeight+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
} addEventListener('resize',resize,{passive:true});

// ===== Координаты
const toWorld=(x,y)=>({x:(x-S.ox)/S.scale, y:(y-S.oy)/S.scale});
const toScreen=(x,y)=>({x:x*S.scale+S.ox, y:y*S.scale+S.oy});

// ===== Математика/снап
function vecInfo(a,b){const dx=b.x-a.x,dy=b.y-a.y;const L=Math.hypot(dx,dy);let d=(Math.atan2(dy,dx)*180/Math.PI+360)%360; if(d>180)d=360-d; return {L,deg:d};}
function dot(a,b){return a.x*b.x+a.y*b.y;} function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};} function scale(v,k){return {x:v.x*k,y:v.y*k};}
function len(v){return Math.hypot(v.x,v.y);} function clamp01(t){return Math.max(0,Math.min(1,t));}
function snap45(base,p){const dx=p.x-base.x,dy=p.y-base.y,L=Math.hypot(dx,dy);if(!L)return p; const step=Math.PI/4, s=Math.round(Math.atan2(dy,dx)/step)*step; return {x:base.x+Math.cos(s)*L,y:base.y+Math.sin(s)*L};}
function projectPointOnSeg(P,A,B){const v=sub(B,A);const L2=dot(v,v)||1;let t=dot(sub(P,A),v)/L2; t=clamp01(t); const Q=add(A,scale(v,t)); return {Q,t,dist:len(sub(P,Q))};}
function segIntersection(a1,a2,b1,b2){const r=sub(a2,a1),s=sub(b2,b1);const rxs=r.x*s.y-r.y*s.x;const qpxr=(b1.x-a1.x)*r.y-(b1.y-a1.y)*r.x;
  if(Math.abs(rxs)<1e-12) return null; const t=((b1.x-a1.x)*s.y-(b1.y-a1.y)*s.x)/rxs; const u=((b1.x-a1.x)*r.y-(b1.y-a1.y)*r.x)/rxs;
  if(t>=0&&t<=1&&u>=0&&u<=1) return {p:add(a1,scale(r,t)),ta:t,tb:u}; return null;}

// ===== Стык/Т-стык
const JOIN_PX=14, MIN_SEG_PX=18; // пороги на экране
function endWithJunction(start,end){
  const tolW=JOIN_PX/S.scale; let bestSnap=null,bestCross=null;
  for(const s of S.segs){ for(const P of [s.a,s.b]){ const pr=projectPointOnSeg(P,start,end); if(pr.dist<=tolW){ const d=pr.t*len(sub(end,start)); if(!bestSnap||d<bestSnap.dist) bestSnap={p:P,dist:d}; } } }
  for(let i=0;i<S.segs.length;i++){ const s=S.segs[i]; const inter=segIntersection(start,end,s.a,s.b);
    if(inter && inter.tb>1e-4 && inter.tb<1-1e-4){ const d=inter.ta*len(sub(end,start)); if(!bestCross||d<bestCross.dist) bestCross={p:inter.p,segIndex:i,dist:d}; } }
  if(bestCross && (!bestSnap || bestCross.dist<bestSnap.dist)) return {end:bestCross.p, split:bestCross};
  if(bestSnap) return {end:{x:bestSnap.p.x,y:bestSnap.p.y}, split:null};
  return {end,split:null};
}
function splitSegment(i,p){
  const s=S.segs[i]; if(!s) return; if(len(sub(p,s.a))<1e-6||len(sub(p,s.b))<1e-6) return;
  const A={x:s.a.x,y:s.a.y}, B={x:s.b.x,y:s.b.y};
  S.segs[i]={a:A,b:{x:p.x,y:p.y}}; S.segs.splice(i+1,0,{a:{x:p.x,y:p.y}, b:B});
}

// ===== Рендер (единая сцена)
function drawBGWorld(){
  if(!S.img) return;
  ctx.save(); // применяем трансформацию сцены
  ctx.setTransform(S.scale,0,0,S.scale,S.ox,S.oy);
  ctx.drawImage(S.img, S.bgX, S.bgY, S.iw*S.bgS, S.ih*S.bgS);
  ctx.restore();
}
function drawGrid(){
  const step=S.grid*S.scale; if(step<8) return;
  ctx.save(); ctx.strokeStyle='rgba(0,0,0,.10)'; ctx.lineWidth=1;
  const x0=((S.ox%step)+step)%step, y0=((S.oy%step)+step)%step;
  for(let x=x0;x<cv.width;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=y0;y<cv.height;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
  ctx.restore();
}
function drawPipes(){
  const W=Math.max(2,S.pipe*S.scale*0.45);
  ctx.lineCap='butt'; ctx.lineJoin='round'; ctx.miterLimit=6;
  // тень
  ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.lineWidth=W+3;
  for(const s of S.segs){ const a=toScreen(s.a.x,s.a.y), b=toScreen(s.b.x,s.b.y); ctx.beginPath(); ctx.moveTo(a.x+1,a.y+1); ctx.lineTo(b.x+1,b.y+1); ctx.stroke(); }
  // основная
  ctx.strokeStyle='#2f8cff'; ctx.lineWidth=W;
  for(const s of S.segs){ const a=toScreen(s.a.x,s.a.y), b=toScreen(s.b.x,s.b.y); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  // предпросмотр
  if(S.state==='awaitSecond'&&S.first&&S.preview){
    const a=toScreen(S.first.x,S.first.y), b=toScreen(S.preview.x,S.preview.y);
    ctx.strokeStyle='#7db6ff'; ctx.lineWidth=W; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  // маркер старта
  if(S.first){ const p=toScreen(S.first.x,S.first.y); ctx.fillStyle='#ff3b30'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); }
}
function updateHUD(a,b){ if(!a||!b){ hud.style.display='none'; return; } const {L,deg}=vecInfo(a,b); hudAngle.textContent=`∠ ${Math.round(deg)}°`; hudLen.textContent=`L ${Math.round(L)} мм`; hud.style.display='flex'; }
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  drawBGWorld(); drawGrid(); drawPipes();
  if(S.state==='awaitSecond'&&S.first&&S.preview) updateHUD(S.first,S.preview);
  else hud.style.display='none';
}

// ===== Узлы
function rebuildNodes(){ S.nodes.length=0; S.segs.forEach((s,i)=>{ S.nodes.push({x:s.a.x,y:s.a.y,seg:i,end:'a'}); S.nodes.push({x:s.b.x,y:s.b.y,seg:i,end:'b'}); });}
function pickNodeAt(x,y){ const p=toWorld(x,y); const tol=Math.max(10,S.pipe/2)/S.scale; let best=null,dmin=1e9;
  for(const n of S.nodes){ const d=Math.hypot(p.x-n.x,p.y-n.y); if(d<tol&&d<dmin){dmin=d; best=n;} } return best; }

// ===== Пинч/пан/рисование (только Pointer Events)
const TAP_MOVE=12, TAP_TIME=350, LONG_MS=450, COOLDOWN=200;
const allow = e => (e.pointerType==='touch'||e.pointerType==='pen'||e.pointerType==='unknown');
function updPtr(e){ S.pointers.set(e.pointerId,{id:e.pointerId,x:e.clientX,y:e.clientY}); }
function delPtr(e){ S.pointers.delete(e.pointerId); }
function centroid(){ const a=[...S.pointers.values()]; if(a.length<2) return null; return {x:(a[0].x+a[1].x)/2,y:(a[0].y+a[1].y)/2}; }
function distance(){ const a=[...S.pointers.values()]; if(a.length<2) return 0; return Math.hypot(a[1].x-a[0].x,a[1].y-a[0].y); }
function pinchBegin(){ const c=centroid(), d=distance(); if(!c||!d) return; S.pinch={cx:c.x,cy:c.y,d,sc:S.scale,ox:S.ox,oy:S.oy}; }
function pinchMove(){ if(!S.pinch) return; const c=centroid(), d=distance(); if(!c||!d) return;
  let ns=Math.max(S.minS,Math.min(S.maxS,S.pinch.sc*(d/S.pinch.d)));
  const wx=(S.pinch.cx-S.pinch.ox)/S.pinch.sc, wy=(S.pinch.cy-S.pinch.oy)/S.pinch.sc;
  S.scale=ns; S.ox=S.pinch.cx-wx*ns; S.oy=S.pinch.cy-wy*ns; draw();
}
function pinchEnd(){ S.pinch=null; }

cv.addEventListener('pointerdown', e=>{
  if(!allow(e)) return;
  if(performance.now()<S.cooldownUntil) return;
  cv.setPointerCapture(e.pointerId);
  updPtr(e);

  if(S.pointers.size===2){ pinchBegin(); return; }

  S.activeId=e.pointerId;
  S.tap={x:e.clientX,y:e.clientY,t:performance.now(),moved:false,id:e.pointerId};

  // если не рисуем — начнём панорамирование сцены
  if(S.state==='idle'){ S.isPanning=true; S.panPrev={x:e.clientX,y:e.clientY}; }
},{passive:false});

cv.addEventListener('pointermove', e=>{
  if(!allow(e)) return;
  const prev=S.pointers.get(e.pointerId);
  updPtr(e);

  if(S.tap.id===e.pointerId && Math.hypot(e.clientX-S.tap.x,e.clientY-S.tap.y)>TAP_MOVE){
    S.tap.moved=true;
  }

  if(S.pointers.size===2){ pinchMove(); return; }

  // панорамирование сцены
  if(S.state==='idle' && S.isPanning && prev){
    S.ox += (e.clientX - prev.x);
    S.oy += (e.clientY - prev.y);
    draw(); return;
  }

  // предпросмотр второй точки
  if(S.state==='awaitSecond' && e.pointerId===S.activeId && S.first){
    let p=toWorld(e.clientX,e.clientY);
    // лёгкий магнит 0/45/90
    p=snap45(S.first,p);
    S.preview=p; draw(); return;
  }
},{passive:false});

cv.addEventListener('pointerup', e=>{
  if(!allow(e)){ delPtr(e); return; }
  if(S.pointers.size<2 && S.pinch) pinchEnd();
  S.isPanning=false; S.panPrev=null;

  const now=performance.now();
  const isTap=(S.tap.id===e.pointerId)&&!S.tap.moved&&(now-S.tap.t<=TAP_TIME);

  if(isTap){
    if(S.state==='idle'){
      // старт рисования после кнопки «Линия»
    }
    if(S.state==='awaitFirst'){
      // если рядом с концом — привяжем первую точку к нему (для продолжения без «коротышей»)
      const near = pickNodeAt(e.clientX,e.clientY);
      S.first = near ? {x:near.x, y:near.y} : toWorld(e.clientX,e.clientY);
      S.preview=null; S.state='awaitSecond';
      setStatus('1-я точка. Поставь 2-ю.'); draw();
    }else if(S.state==='awaitSecond' && e.pointerId===S.activeId && S.first){
      let end=toWorld(e.clientX,e.clientY);
      end = snap45(S.first,end);
      // не создаём «очень короткие» сегменты
      const a=toScreen(S.first.x,S.first.y), b=toScreen(end.x,end.y);
      if(Math.hypot(b.x-a.x,b.y-a.y) < MIN_SEG_PX){ setStatus('Слишком коротко — ткни подальше'); return; }
      const {end:newEnd, split}=endWithJunction(S.first,end); if(split) splitSegment(split.segIndex,split.p);
      S.segs.push({a:{...S.first}, b:{x:newEnd.x,y:newEnd.y}});
      S.first=null; S.preview=null; S.state='idle'; btnLine.classList.remove('active');
      rebuildNodes(); setStatus('Линия готова. Для новой — снова «Линия».'); draw();
      S.cooldownUntil = now + COOLDOWN;
    }
  }
  S.activeId=null; delPtr(e);
},{passive:false});

cv.addEventListener('pointercancel', e=>{
  S.isPanning=false; S.panPrev=null; S.activeId=null; delPtr(e); if(S.pinch) pinchEnd();
});

// ===== Кнопки
btnLine.onclick=()=>{ S.state = (S.state==='idle') ? 'awaitFirst' : 'idle'; S.first=null; S.preview=null; btnLine.classList.toggle('active',S.state!=='idle');
  setStatus(S.state!=='idle'?'Режим ЛИНИЯ: ткни 1-ю точку':'Готов'); draw(); };
btnUndo.onclick=()=>{ if(S.state==='awaitSecond'&&S.first){ S.state='awaitFirst'; S.first=null; S.preview=null; setStatus('Старт снят'); draw(); return; }
  S.segs.pop(); rebuildNodes(); draw(); setStatus('Отменено'); };

btnPlus.onclick=()=>zoomAt(1.2);
btnMinus.onclick=()=>zoomAt(1/1.2);
function zoomAt(f){
  const cx=innerWidth/2, cy=innerHeight/2;
  const ns=Math.max(S.minS,Math.min(S.maxS,S.scale*f));
  const wx=(cx-S.ox)/S.scale, wy=(cy-S.oy)/S.scale;
  S.scale=ns; S.ox=cx-wx*ns; S.oy=cy-wy*ns; draw();
}

btnCenter.onclick=()=>{ S.scale=1; S.ox=innerWidth/2; S.oy=innerHeight/2; draw(); setStatus('Сцена по центру'); };
btnSave.onclick=()=>{ const off=document.createElement('canvas'); off.width=cv.width; off.height=cv.height; const o=off.getContext('2d'); o.drawImage(cv,0,0); const a=document.createElement('a'); a.href=off.toDataURL('image/png'); a.download='trace.png'; a.click(); };

btnPhoto.onclick=()=>fileInp.click();
fileInp.onchange=e=>{
  const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); const img=new Image();
  img.onload=()=>{
    S.img=img; S.iw=img.naturalWidth; S.ih=img.naturalHeight;
    // Вписываем фото в текущий экран — В МИРОВЫХ координатах
    const k=Math.min(innerWidth/S.iw, innerHeight/S.ih)*0.95;
    S.bgS = k / S.scale;            // масштаб фото в МИРЕ (чтобы визуально вписалось)
    S.bgX = ( (innerWidth/2 - S.ox)/S.scale ) - (S.iw*S.bgS)/2;
    S.bgY = ( (innerHeight/2- S.oy)/S.scale ) - (S.ih*S.bgS)/2;
    draw(); setStatus('Фото загружено (зум общий для фото и труб)');
  };
  img.src=url;
};

// ===== Старт
resize(); setStatus('Готов: фото и трубы зумятся вместе. «Линия» → 1-й → 2-й; продолжение от конца — без «коротышей».');
})();
</script>
</body>
</html>