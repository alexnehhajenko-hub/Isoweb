<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ —Ç—Ä—É–± –ø–æ —Ñ–æ—Ç–æ</title>
<style>
  :root { --ui:#1f2937; --accent:#6366f1; --bg:#111; --panel:rgba(20,20,22,.9); }
  html,body{height:100%;margin:0;background:#0f0f10;color:#fff;font-family:-apple-system,system-ui,Segoe UI,Roboto,Inter,Arial}
  #wrap{position:fixed;inset:0;overflow:hidden;touch-action:none}
  canvas{position:absolute;inset:0;background:#0d0f12}
  #ui{position:fixed;left:.5rem;top:.5rem;display:flex;gap:.5rem;flex-wrap:wrap;z-index:3}
  .btn{background:var(--panel);border:1px solid #2a2e37;color:#fff;border-radius:.8rem;padding:.55rem .9rem;font-weight:600}
  .btn.active{outline:2px solid var(--accent)}
  .row{display:flex;gap:.5rem;align-items:center}
  .panel{position:fixed;right:.5rem;top:.5rem;background:var(--panel);border:1px solid #2a2e37;border-radius:1rem;padding:.8rem;z-index:3}
  .panel h4{margin:.2rem 0 .6rem 0}
  .panel label{font-size:.92rem;opacity:.9;display:block;margin:.35rem 0 .15rem}
  input[type="range"]{width:200px}
  #hint{position:fixed;left:.5rem;bottom:.5rem;background:rgba(0,0,0,.6);padding:.5rem .7rem;border-radius:.7rem;font-size:.9rem}
  .sep{height:1px;background:#2a2e37;margin:.5rem 0}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <canvas id="overlay" style="pointer-events:none"></canvas>
</div>

<div id="ui">
  <button class="btn" id="photoBtn">üì∑ –§–æ—Ç–æ</button>
  <button class="btn" id="calibBtn">üìè –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</button>
  <button class="btn active" id="lineBtn">üìê –õ–∏–Ω–∏—è</button>
  <button class="btn" id="teeBtn">‚î¨ –¢—Ä–æ–π–Ω–∏–∫</button>
  <button class="btn" id="valveBtn">üö¶ –ö—Ä–∞–Ω</button>
  <button class="btn" id="undoBtn">‚Ü©Ô∏è –ù–∞–∑–∞–¥</button>
  <button class="btn" id="centerBtn">üéØ –¶–µ–Ω—Ç—Ä</button>
  <button class="btn" id="saveBtn">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
  <button class="btn" id="loadBtn">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
</div>

<div class="panel">
  <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</h4>
  <label>√ò, –º–º</label>
  <input id="diam" type="range" min="10" max="200" value="40"/>
  <div class="row"><span style="width:60px;opacity:.8">–°–µ—Ç–∫–∞</span>
    <input id="grid" type="range" min="0" max="80" value="40">
  </div>
  <label class="row"><input id="iso" type="checkbox" checked style="margin-right:.5rem">–ò–∑–æ–º–µ—Ç—Ä–∏—è (2.5D)</label>
  <div class="sep"></div>
  <label class="row"><input id="snap" type="checkbox" checked style="margin-right:.5rem">–ú–∞–≥–Ω–∏—Ç 0/45/90¬∞</label>
</div>

<div id="hint">–°—Ç–∞—Ç—É—Å: —Ä–µ–∂–∏–º –ª–∏–Ω–∏—è. –ö–∞–ª–∏–±—Ä—É–π —Ñ–æ—Ç–æ –ø–µ—Ä–µ–¥ —Ä–∏—Å–æ–≤–∞–Ω–∏–µ–º (üìè).</div>
<input id="file" type="file" accept="image/*" hidden/>
<input id="jsonFile" type="file" accept="application/json" hidden/>

<script>
const $ = id => document.getElementById(id);
const canvas = $('c'), ctx = canvas.getContext('2d');
const overlay = $('overlay'), octx = overlay.getContext('2d');
let W=innerWidth, H=innerHeight;
canvas.width = overlay.width = W;
canvas.height = overlay.height = H;

let state = {
  bg: null, bgW:0, bgH:0,
  // –º–∏—Ä–æ–≤—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ (–ø–∞–Ω/–∑—É–º) ‚Äî –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–ª—è —Ñ–æ—Ç–æ –∏ —Ç—Ä—É–±
  scale: 1, panX: 0, panY: 0,
  // –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞: –º–º/–ø–∏–∫—Å–µ–ª—å
  mmPerPx: 1, calibrated:false,
  mode: 'line', // line|calib|tee|valve
  pipes: [], // [{points:[{x,y}], d}]
  fittings: [], // [{type:'tee'|'valve', x,y, rot}]
  tempPts: [],
  snap: true,
  iso: true,
  grid: 40,
  dmm: 40
};

// ========= helpers
function toWorld(x,y){ // —ç–∫—Ä–∞–Ω -> –º–∏—Ä
  const s=state.scale; 
  return { x:(x - state.panX)/s, y:(y - state.panY)/s };
}
function toScreen(x,y){ // –º–∏—Ä -> —ç–∫—Ä–∞–Ω
  const s=state.scale;
  return { x: x*s + state.panX, y: y*s + state.panY };
}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function angle(a,b){
  return Math.atan2(b.y-a.y,b.x-a.x);
}
function snapAngle(rad){
  if(!state.snap) return rad;
  const step = Math.PI/4; // 45¬∞
  return Math.round(rad/step)*step;
}
function lerp(a,b,t){return a+(b-a)*t;}

// ========= drawing
function drawBG(){
  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.imageSmoothingEnabled = true;
  if(state.bg){
    const p = toScreen(0,0), s=state.scale;
    ctx.drawImage(state.bg, p.x, p.y, state.bgW*s, state.bgH*s);
  } else {
    ctx.fillStyle = '#0d0f12'; ctx.fillRect(0,0,W,H);
  }
  ctx.restore();
}

function drawGrid(){
  octx.clearRect(0,0,W,H);
  if(state.grid<=0) return;
  const step = state.grid; // –≤ –º–º
  const px = step / state.mmPerPx * state.scale;
  if(px<10) return; // —Å–ª–∏—à–∫–æ–º –º–µ–ª–∫–æ
  octx.save();
  octx.globalAlpha = 0.25;
  octx.strokeStyle = '#7aa0ff';
  octx.lineWidth = 1;
  // —Å–µ—Ç–∫—É —Ä–∏—Å—É–µ–º –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö, –Ω–æ —Å–¥–≤–∏–≥ —É—á–∏—Ç—ã–≤–∞–µ–º pan
  const offsetX = (state.panX % px + px) % px;
  const offsetY = (state.panY % px + px) % px;
  for(let x=offsetX; x<W; x+=px){ octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,H); octx.stroke(); }
  for(let y=offsetY; y<H; y+=px){ octx.beginPath(); octx.moveTo(0,y); octx.lineTo(W,y); octx.stroke(); }
  // –æ—Å–∏
  octx.globalAlpha=0.5; octx.strokeStyle='#ff6666';
  const zero = toScreen(0,0);
  octx.beginPath(); octx.moveTo(0,zero.y); octx.lineTo(W,zero.y); octx.stroke();
  octx.beginPath(); octx.moveTo(zero.x,0); octx.lineTo(zero.x,H); octx.stroke();
  octx.restore();
}

function roundedJoin(a,b,c,rPx){
  // –¥—É–≥–∞ –º–µ–∂–¥—É AB –∏ BC —Å —Ä–∞–¥–∏—É—Å–æ–º rPx (–≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –ø–∏–∫—Å–µ–ª—è—Ö)
  // –≤—ã—á–∏—Ç–∞–µ–º —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è –∏ —Ä–∏—Å—É–µ–º –¥—É–≥—É
  const A = toScreen(a.x,a.y), B = toScreen(b.x,b.y), C = toScreen(c.x,c.y);
  const v1 = Math.atan2(A.y-B.y, A.x-B.x);
  const v2 = Math.atan2(C.y-B.y, C.x-B.x);
  const angDiff = ((v2 - v1 + Math.PI*3)%(Math.PI*2))-Math.PI;
  const dir = Math.sign(angDiff)||1;
  const t = Math.min(dist(A,B), dist(B,C)) * .3; // –æ–≥—Ä–∞–Ω–∏—á–∏–º
  // —Ç–æ—á–∫–∞ –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –¥—É–≥–∏ –≤–¥–æ–ª—å –æ—Ç—Ä–µ–∑–∫–æ–≤
  const s1 = { x: B.x + Math.cos(v1)*(rPx), y: B.y + Math.sin(v1)*(rPx) };
  const s2 = { x: B.x + Math.cos(v2)*(rPx), y: B.y + Math.sin(v2)*(rPx) };
  // —Ü–µ–Ω—Ç—Ä –¥—É–≥–∏ –Ω–∞–π–¥—ë–º –∫–∞–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –Ω–æ—Ä–º–∞–ª–µ–π (–ø—Ä–∏–±–ª.)
  const n1 = v1 - dir*Math.PI/2, n2 = v2 + dir*Math.PI/2;
  // –ø—Ä—è–º–∞—è —á–µ—Ä–µ–∑ s1 –≤–¥–æ–ª—å n1 –∏ —á–µ—Ä–µ–∑ s2 –≤–¥–æ–ª—å n2
  const den = Math.sin(n1)*Math.cos(n2) - Math.cos(n1)*Math.sin(n2);
  let cx = s2.x*(Math.sin(n1)) - s1.x*(Math.sin(n2));
  let cy = s2.y*(Math.cos(n1)) - s1.y*(Math.cos(n2));
  cx/=den; cy/=den;
  // —Ä–∏—Å—É–µ–º
  ctx.beginPath();
  ctx.moveTo(s1.x, s1.y);
  const start = Math.atan2(s1.y-cy, s1.x-cx);
  const end   = Math.atan2(s2.y-cy, s2.x-cx);
  ctx.arc(cx,cy, rPx, start, end, dir<0);
  ctx.stroke();
}

function drawPipes(){
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';

  for(const p of state.pipes){
    const rWorld = p.d/2/state.mmPerPx;          // —Ä–∞–¥–∏—É—Å –≤ –º–∏—Ä–æ–≤—ã—Ö –ø–∏–∫—Å–µ–ª—è—Ö
    const r = rWorld * state.scale;              // —Ä–∞–¥–∏—É—Å –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –ø–∏–∫—Å–µ–ª—è—Ö
    // ¬´—Ç–µ–ª–æ¬ª —Ç—Ä—É–±—ã (—Ç–æ–ª—Å—Ç–∞—è –ª–∏–Ω–∏—è)
    ctx.strokeStyle = '#4c6fff';
    ctx.lineWidth = Math.max(2, r*1.8);
    for(let i=0;i<p.points.length-1;i++){
      const a = toScreen(p.points[i].x,p.points[i].y);
      const b = toScreen(p.points[i+1].x,p.points[i+1].y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    // ¬´–±–ª–∏–∫–∏¬ª –¥–ª—è –ø—Å–µ–≤–¥–æ-–æ–±—ä—ë–º–∞
    if(state.iso){
      ctx.strokeStyle = 'rgba(255,255,255,.55)';
      ctx.lineWidth = Math.max(1, r*0.35);
      for(let i=0;i<p.points.length-1;i++){
        const a = toScreen(p.points[i].x,p.points[i].y);
        const b = toScreen(p.points[i+1].x,p.points[i+1].y);
        // —Å–º–µ—â–∞–µ–º –ª–∏–Ω–∏—é –≤–≤–µ—Ä—Ö –Ω–∞ r*0.4 (–Ω–æ—Ä–º–∞–ª—å)
        const ang = Math.atan2(b.y-a.y,b.x-a.x) - Math.PI/2;
        const off = {x:Math.cos(ang)*r*0.45, y:Math.sin(ang)*r*0.45};
        ctx.beginPath(); ctx.moveTo(a.x+off.x,a.y+off.y); ctx.lineTo(b.x+off.x,b.y+off.y); ctx.stroke();
      }
    }
    // –æ—Ç–≤–æ–¥—ã –≤ –º–µ—Å—Ç–∞—Ö –∏–∑–ª–æ–º–æ–≤
    ctx.strokeStyle = '#4c6fff';
    ctx.lineWidth = Math.max(2, r*1.8);
    for(let i=1;i<p.points.length-1;i++){
      roundedJoin(p.points[i-1], p.points[i], p.points[i+1], r*1.2);
    }
    // —Ç–æ—Ä—Ü—ã
    for(const pt of [p.points[0], p.points[p.points.length-1]]){
      const s = toScreen(pt.x,pt.y);
      ctx.beginPath(); ctx.fillStyle='#4c6fff'; ctx.arc(s.x,s.y, r*0.95, 0, Math.PI*2); ctx.fill();
      if(state.iso){ ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,.55)'; ctx.arc(s.x-r*0.25,s.y-r*0.25, r*0.5, 0, Math.PI*2); ctx.fill(); }
    }
  }
  ctx.restore();
}

function drawFittings(){
  ctx.save();
  for(const f of state.fittings){
    const s = toScreen(f.x,f.y);
    ctx.translate(s.x,s.y);
    ctx.rotate(f.rot||0);
    if(f.type==='tee'){
      ctx.fillStyle='#ffd166';
      ctx.fillRect(-10,-6,20,12); // –∫–æ—Ä–ø—É—Å
      ctx.fillRect(-6,-20,12,14); // ¬´–Ω–æ–∂–∫–∞¬ª
    }else if(f.type==='valve'){
      ctx.fillStyle='#ff6b6b';
      ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#fff'; ctx.fillRect(-2,-14,4,28);
    }
    ctx.setTransform(1,0,0,1,0,0);
  }
  ctx.restore();
}

function render(){
  drawBG();
  drawGrid();
  drawPipes();
  drawFittings();
  requestAnimationFrame(()=>{});
}
render();

// ========= input (–ø–∞–Ω/–∑—É–º/–∫–ª–∏–∫)
let dragging=false, last={x:0,y:0};
let pinch=false, lastDist=0;

function setHint(t){ $('hint').textContent = '–°—Ç–∞—Ç—É—Å: '+t; }

wrap.addEventListener('pointerdown', e=>{
  wrap.setPointerCapture(e.pointerId);
  dragging=true; last.x=e.clientX; last.y=e.clientY;
  if(state.mode==='line'){
    const w = toWorld(e.clientX,e.clientY);
    if(state.tempPts.length===0){
      state.tempPts=[w];
    }else{
      // –Ω–∞–ø—Ä–∞–≤–ª—è–µ–º —Å–æ —Å–Ω–∞–ø–æ–º
      const a = state.tempPts[state.tempPts.length-1];
      let ang = angle(a,w); ang = snapAngle(ang);
      const len = dist(a,w);
      const p = { x: a.x + Math.cos(ang)*len, y: a.y + Math.sin(ang)*len };
      state.tempPts.push(p);
      // –µ—Å–ª–∏ –¥–≤–æ–π–Ω–æ–π —Ç–∞–ø –ø–æ –æ–¥–Ω–æ–π —Ç–æ—á–∫–µ ‚Äî –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç
      if(state.tempPts.length>=2 && dist(state.tempPts[state.tempPts.length-1], state.tempPts[state.tempPts.length-2])<3/state.scale){
        // –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ
      }
    }
  }else if(state.mode==='tee' || state.mode==='valve'){
    const w = toWorld(e.clientX,e.clientY);
    state.fittings.push({ type: state.mode==='tee'?'tee':'valve', x:w.x,y:w.y, rot:0});
    render(); setHint(`${state.mode==='tee'?'–¢—Ä–æ–π–Ω–∏–∫':'–ö—Ä–∞–Ω'} –ø–æ—Å—Ç–∞–≤–ª–µ–Ω`);
  }else if(state.mode==='calib'){
    const w = toWorld(e.clientX,e.clientY);
    state.tempPts.push(w);
    if(state.tempPts.length===2){
      const real = prompt('–í–≤–µ–¥–∏ —Ä–µ–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ (–º–º):', '1000');
      const px = dist(state.tempPts[0], state.tempPts[1]); // –≤ –º–∏—Ä–æ–≤—ã—Ö –ø–∏–∫—Å–µ–ª—è—Ö
      const mmPerPx = Number(real)/px;
      if(mmPerPx>0){ state.mmPerPx=mmPerPx; state.calibrated=true; setHint(`–ö–∞–ª–∏–±—Ä–æ–≤–∞–Ω–æ: ${mmPerPx.toFixed(3)} –º–º/px`); }
      state.tempPts=[];
    }else{
      setHint('–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞: –≤—ã–±–µ—Ä–∏ –≤—Ç–æ—Ä—É—é —Ç–æ—á–∫—É');
    }
  }
  render();
});

wrap.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const dx = e.clientX-last.x, dy=e.clientY-last.y;
  last.x=e.clientX; last.y=e.clientY;
  if(e.buttons===2 || (e.pointerType==='touch' && state.mode!=='line')){ // –¥–≤–µ –ø–∞–ª—å—Ü–∞/–≤—Ç–æ—Ä–∏—á–Ω–∞—è ‚Äî –ø–∞–Ω
    state.panX += dx; state.panY += dy;
  }else if(state.mode!=='line'){ // —Ä–µ–∂–∏–º—ã –Ω–µ —Ä–∏—Å—É—é—Ç ‚Äî –ø–∞–Ω
    state.panX += dx; state.panY += dy;
  }
  render();
});

wrap.addEventListener('pointerup', e=>{
  dragging=false; wrap.releasePointerCapture(e.pointerId);
  if(state.mode==='line' && state.tempPts.length>=2){
    // –µ—Å–ª–∏ –æ—Ç–ø—É—Å—Ç–∏–ª–∏ ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
    const pts = state.tempPts.slice(-2);
    // —Å–ª–∏–ø–∞–Ω–∏–µ –≤ –æ–¥–Ω—É —Ç—Ä—É–±—É
    let current = state.pipes[state.pipes.length-1];
    if(!current || current._closed){ current={points:[], d: state.dmm}; state.pipes.push(current); }
    if(current.points.length===0) current.points.push(pts[0]);
    current.points.push(pts[1]);
    current.d = state.dmm;
    setHint('–°–µ–≥–º–µ–Ω—Ç –≥–æ—Ç–æ–≤. –î–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –Ω–∞–∂–º–∏ ¬´–õ–∏–Ω–∏—è¬ª. | –ì–æ—Ç–æ–≤');
  }
});

wrap.addEventListener('wheel', e=>{
  const k = Math.exp(-e.deltaY*0.0015);
  // –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫—É—Ä—Å–æ—Ä–∞
  const wx = (e.clientX - state.panX)/state.scale;
  const wy = (e.clientY - state.panY)/state.scale;
  state.scale *= k;
  state.panX = e.clientX - wx*state.scale;
  state.panY = e.clientY - wy*state.scale;
  render();
});

// ========= UI
$('photoBtn').onclick = ()=> $('file').click();
$('file').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  const img = new Image(); img.onload=()=>{
    state.bg=img; state.bgW=img.width; state.bgH=img.height;
    // –≤–ø–∏—à–µ–º –≤ —ç–∫—Ä–∞–Ω
    const s = Math.min(W/img.width, H/img.height)*0.95;
    state.scale = s; state.panX = (W - img.width*s)/2; state.panY=(H - img.height*s)/2;
    render(); setHint('–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ù–∞–∂–º–∏ üìè –¥–ª—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏.');
  }; img.src = URL.createObjectURL(f);
};

$('calibBtn').onclick = ()=>{ state.mode='calib'; setActive(this,'calibBtn'); setHint('–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞: –≤—ã–±–µ—Ä–∏ 2 —Ç–æ—á–∫–∏ –∏ –≤–≤–µ–¥–∏ –¥–ª–∏–Ω—É.'); };
$('lineBtn').onclick  = ()=>{ state.mode='line'; setActive(this,'lineBtn'); setHint('–†–µ–∂–∏–º: –ª–∏–Ω–∏—è. –ö–ª–∏–∫–Ω–∏ –ø–æ —Ç–æ—á–∫–∞–º.'); };
$('teeBtn').onclick   = ()=>{ state.mode='tee'; setActive(this,'teeBtn'); setHint('–†–µ–∂–∏–º: —Ç—Ä–æ–π–Ω–∏–∫. –¢–∞–ø –ø–æ –º–µ—Å—Ç—É.'); };
$('valveBtn').onclick = ()=>{ state.mode='valve'; setActive(this,'valveBtn'); setHint('–†–µ–∂–∏–º: –∫—Ä–∞–Ω. –¢–∞–ø –ø–æ –º–µ—Å—Ç—É.'); };
$('undoBtn').onclick  = ()=>{
  if(state.pipes.length){ 
    const p = state.pipes[state.pipes.length-1];
    p.points.pop(); if(p.points.length<2) state.pipes.pop();
  } else if(state.fittings.length){ state.fittings.pop(); }
  render();
};
$('centerBtn').onclick= ()=>{
  if(state.bg){
    const s = Math.min(W/state.bgW, H/state.bgH)*0.95;
    state.scale=s; state.panX=(W-state.bgW*s)/2; state.panY=(H-state.bgH*s)/2;
  }else{ state.scale=1; state.panX=state.panY=0; }
  render();
};
$('saveBtn').onclick = ()=>{
  const data = { pipes:state.pipes, fittings:state.fittings, dmm:state.dmm, grid:state.grid, iso:state.iso, snap:state.snap, mmPerPx:state.mmPerPx };
  const blob = new Blob([JSON.stringify(data)],{type:'application/json'});
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='trace.json'; a.click();
};
$('loadBtn').onclick = ()=> $('jsonFile').click();
$('jsonFile').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  f.text().then(t=>{
    const d = JSON.parse(t);
    Object.assign(state, { pipes:d.pipes||[], fittings:d.fittings||[], dmm:d.dmm||40, grid:d.grid??40, iso:!!d.iso, snap:!!d.snap, mmPerPx:d.mmPerPx||1, calibrated:!!d.mmPerPx });
    render(); setHint('–ü—Ä–æ–µ–∫—Ç –∑–∞–≥—Ä—É–∂–µ–Ω.');
  });
};

$('diam').oninput  = e=>{ state.dmm = +e.target.value; render(); };
$('grid').oninput  = e=>{ state.grid = +e.target.value; render(); };
$('iso').onchange  = e=>{ state.iso  =  e.target.checked; render(); };
$('snap').onchange = e=>{ state.snap =  e.target.checked; };

function setActive(_, id){
  ['lineBtn','teeBtn','valveBtn','calibBtn'].forEach(b=>$ (b).classList.remove('active'));
  $(id).classList.add('active');
}

// —Ä–µ—Å–∞–π–∑
addEventListener('resize', ()=>{
  W=innerWidth; H=innerHeight; canvas.width=overlay.width=W; canvas.height=overlay.height=H; render();
});

// —Å—Ç–∞—Ä—Ç
render();
</script>
</body>
</html>